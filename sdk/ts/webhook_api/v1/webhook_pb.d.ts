/* eslint-disable */
/*Generated by GenDocu.com*/
// package: webhook_api.v1
// file: webhook_api/v1/webhook.proto

import * as jspb from "google-protobuf";
import * as common_v1_common_pb from "../../common/v1/common_pb";
import * as common_v1_packet_pb from "../../common/v1/packet_pb";

export class Webhook extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getOwnerId(): string;
  setOwnerId(value: string): void;

  getName(): string;
  setName(value: string): void;

  getWebhookUrl(): string;
  setWebhookUrl(value: string): void;

  clearSupportedEventsList(): void;
  getSupportedEventsList(): Array<EventTypeMap[keyof EventTypeMap]>;
  setSupportedEventsList(value: Array<EventTypeMap[keyof EventTypeMap]>): void;
  addSupportedEvents(value: EventTypeMap[keyof EventTypeMap], index?: number): EventTypeMap[keyof EventTypeMap];

  getDeliveryMethod(): DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap];
  setDeliveryMethod(value: DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Webhook.AsObject;
  static toObject(includeInstance: boolean, msg: Webhook): Webhook.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Webhook, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Webhook;
  static deserializeBinaryFromReader(message: Webhook, reader: jspb.BinaryReader): Webhook;
}

export namespace Webhook {
  export type AsObject = {
    id: string,
    ownerId: string,
    name: string,
    webhookUrl: string,
    supportedEventsList: Array<EventTypeMap[keyof EventTypeMap]>,
    deliveryMethod: DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap],
  }
}

export class CreateWalletPayload extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getDid(): string;
  setDid(value: string): void;

  getCreated(): string;
  setCreated(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateWalletPayload.AsObject;
  static toObject(includeInstance: boolean, msg: CreateWalletPayload): CreateWalletPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateWalletPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateWalletPayload;
  static deserializeBinaryFromReader(message: CreateWalletPayload, reader: jspb.BinaryReader): CreateWalletPayload;
}

export namespace CreateWalletPayload {
  export type AsObject = {
    name: string,
    did: string,
    created: string,
  }
}

export class PromissoryReceivedPayload extends jspb.Message {
  getWalletId(): string;
  setWalletId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PromissoryReceivedPayload.AsObject;
  static toObject(includeInstance: boolean, msg: PromissoryReceivedPayload): PromissoryReceivedPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PromissoryReceivedPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PromissoryReceivedPayload;
  static deserializeBinaryFromReader(message: PromissoryReceivedPayload, reader: jspb.BinaryReader): PromissoryReceivedPayload;
}

export namespace PromissoryReceivedPayload {
  export type AsObject = {
    walletId: string,
  }
}

export class PingPayload extends jspb.Message {
  getMessage(): string;
  setMessage(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PingPayload.AsObject;
  static toObject(includeInstance: boolean, msg: PingPayload): PingPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PingPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PingPayload;
  static deserializeBinaryFromReader(message: PingPayload, reader: jspb.BinaryReader): PingPayload;
}

export namespace PingPayload {
  export type AsObject = {
    message: string,
  }
}

export class ContractProposalCompletedPayload extends jspb.Message {
  getContractId(): string;
  setContractId(value: string): void;

  getOwnerId(): string;
  setOwnerId(value: string): void;

  getWalletId(): string;
  setWalletId(value: string): void;

  clearCommitmentsList(): void;
  getCommitmentsList(): Array<common_v1_packet_pb.Commitment>;
  setCommitmentsList(value: Array<common_v1_packet_pb.Commitment>): void;
  addCommitments(value?: common_v1_packet_pb.Commitment, index?: number): common_v1_packet_pb.Commitment;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractProposalCompletedPayload.AsObject;
  static toObject(includeInstance: boolean, msg: ContractProposalCompletedPayload): ContractProposalCompletedPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractProposalCompletedPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractProposalCompletedPayload;
  static deserializeBinaryFromReader(message: ContractProposalCompletedPayload, reader: jspb.BinaryReader): ContractProposalCompletedPayload;
}

export namespace ContractProposalCompletedPayload {
  export type AsObject = {
    contractId: string,
    ownerId: string,
    walletId: string,
    commitmentsList: Array<common_v1_packet_pb.Commitment.AsObject>,
  }
}

export class ContractPaymentCompletedPayload extends jspb.Message {
  getContractId(): string;
  setContractId(value: string): void;

  getOwnerId(): string;
  setOwnerId(value: string): void;

  getWalletId(): string;
  setWalletId(value: string): void;

  clearCommitmentsList(): void;
  getCommitmentsList(): Array<common_v1_packet_pb.Commitment>;
  setCommitmentsList(value: Array<common_v1_packet_pb.Commitment>): void;
  addCommitments(value?: common_v1_packet_pb.Commitment, index?: number): common_v1_packet_pb.Commitment;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractPaymentCompletedPayload.AsObject;
  static toObject(includeInstance: boolean, msg: ContractPaymentCompletedPayload): ContractPaymentCompletedPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractPaymentCompletedPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractPaymentCompletedPayload;
  static deserializeBinaryFromReader(message: ContractPaymentCompletedPayload, reader: jspb.BinaryReader): ContractPaymentCompletedPayload;
}

export namespace ContractPaymentCompletedPayload {
  export type AsObject = {
    contractId: string,
    ownerId: string,
    walletId: string,
    commitmentsList: Array<common_v1_packet_pb.Commitment.AsObject>,
  }
}

export class Event extends jspb.Message {
  getEventType(): EventTypeMap[keyof EventTypeMap];
  setEventType(value: EventTypeMap[keyof EventTypeMap]): void;

  getSignature(): string;
  setSignature(value: string): void;

  getEventId(): string;
  setEventId(value: string): void;

  getDeliveryDate(): string;
  setDeliveryDate(value: string): void;

  getOwnerId(): string;
  setOwnerId(value: string): void;

  hasWalletCreatedPayload(): boolean;
  clearWalletCreatedPayload(): void;
  getWalletCreatedPayload(): CreateWalletPayload | undefined;
  setWalletCreatedPayload(value?: CreateWalletPayload): void;

  hasPromissoryReceivedPayload(): boolean;
  clearPromissoryReceivedPayload(): void;
  getPromissoryReceivedPayload(): PromissoryReceivedPayload | undefined;
  setPromissoryReceivedPayload(value?: PromissoryReceivedPayload): void;

  hasPingPayload(): boolean;
  clearPingPayload(): void;
  getPingPayload(): PingPayload | undefined;
  setPingPayload(value?: PingPayload): void;

  hasContractProposalCompletedPayload(): boolean;
  clearContractProposalCompletedPayload(): void;
  getContractProposalCompletedPayload(): ContractProposalCompletedPayload | undefined;
  setContractProposalCompletedPayload(value?: ContractProposalCompletedPayload): void;

  hasContractPaymentCompletedPayload(): boolean;
  clearContractPaymentCompletedPayload(): void;
  getContractPaymentCompletedPayload(): ContractPaymentCompletedPayload | undefined;
  setContractPaymentCompletedPayload(value?: ContractPaymentCompletedPayload): void;

  getCreatedDate(): string;
  setCreatedDate(value: string): void;

  getPayloadCase(): Event.PayloadCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Event.AsObject;
  static toObject(includeInstance: boolean, msg: Event): Event.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Event, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Event;
  static deserializeBinaryFromReader(message: Event, reader: jspb.BinaryReader): Event;
}

export namespace Event {
  export type AsObject = {
    eventType: EventTypeMap[keyof EventTypeMap],
    signature: string,
    eventId: string,
    deliveryDate: string,
    ownerId: string,
    walletCreatedPayload?: CreateWalletPayload.AsObject,
    promissoryReceivedPayload?: PromissoryReceivedPayload.AsObject,
    pingPayload?: PingPayload.AsObject,
    contractProposalCompletedPayload?: ContractProposalCompletedPayload.AsObject,
    contractPaymentCompletedPayload?: ContractPaymentCompletedPayload.AsObject,
    createdDate: string,
  }

  export enum PayloadCase {
    PAYLOAD_NOT_SET = 0,
    WALLET_CREATED_PAYLOAD = 6,
    PROMISSORY_RECEIVED_PAYLOAD = 7,
    PING_PAYLOAD = 8,
    CONTRACT_PROPOSAL_COMPLETED_PAYLOAD = 10,
    CONTRACT_PAYMENT_COMPLETED_PAYLOAD = 11,
  }
}

export class CreateWebhookRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getName(): string;
  setName(value: string): void;

  clearSupportedEventsList(): void;
  getSupportedEventsList(): Array<EventTypeMap[keyof EventTypeMap]>;
  setSupportedEventsList(value: Array<EventTypeMap[keyof EventTypeMap]>): void;
  addSupportedEvents(value: EventTypeMap[keyof EventTypeMap], index?: number): EventTypeMap[keyof EventTypeMap];

  getWebhookUrl(): string;
  setWebhookUrl(value: string): void;

  getDeliveryMethod(): DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap];
  setDeliveryMethod(value: DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateWebhookRequest.AsObject;
  static toObject(includeInstance: boolean, msg: CreateWebhookRequest): CreateWebhookRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateWebhookRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateWebhookRequest;
  static deserializeBinaryFromReader(message: CreateWebhookRequest, reader: jspb.BinaryReader): CreateWebhookRequest;
}

export namespace CreateWebhookRequest {
  export type AsObject = {
    apiKey: string,
    name: string,
    supportedEventsList: Array<EventTypeMap[keyof EventTypeMap]>,
    webhookUrl: string,
    deliveryMethod: DeliveryMethodTypeMap[keyof DeliveryMethodTypeMap],
  }
}

export class CreateWebhookResponse extends jspb.Message {
  getWebhookPublicKey(): string;
  setWebhookPublicKey(value: string): void;

  hasWebhook(): boolean;
  clearWebhook(): void;
  getWebhook(): Webhook | undefined;
  setWebhook(value?: Webhook): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateWebhookResponse.AsObject;
  static toObject(includeInstance: boolean, msg: CreateWebhookResponse): CreateWebhookResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateWebhookResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateWebhookResponse;
  static deserializeBinaryFromReader(message: CreateWebhookResponse, reader: jspb.BinaryReader): CreateWebhookResponse;
}

export namespace CreateWebhookResponse {
  export type AsObject = {
    webhookPublicKey: string,
    webhook?: Webhook.AsObject,
  }
}

export class ListWebhooksRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPage(): number;
  setPage(value: number): void;

  getPageSize(): number;
  setPageSize(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListWebhooksRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListWebhooksRequest): ListWebhooksRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListWebhooksRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListWebhooksRequest;
  static deserializeBinaryFromReader(message: ListWebhooksRequest, reader: jspb.BinaryReader): ListWebhooksRequest;
}

export namespace ListWebhooksRequest {
  export type AsObject = {
    apiKey: string,
    page: number,
    pageSize: number,
  }
}

export class ListWebhooksResponse extends jspb.Message {
  clearWebhooksList(): void;
  getWebhooksList(): Array<Webhook>;
  setWebhooksList(value: Array<Webhook>): void;
  addWebhooks(value?: Webhook, index?: number): Webhook;

  getTotalOwnedWebhooks(): number;
  setTotalOwnedWebhooks(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListWebhooksResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListWebhooksResponse): ListWebhooksResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListWebhooksResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListWebhooksResponse;
  static deserializeBinaryFromReader(message: ListWebhooksResponse, reader: jspb.BinaryReader): ListWebhooksResponse;
}

export namespace ListWebhooksResponse {
  export type AsObject = {
    webhooksList: Array<Webhook.AsObject>,
    totalOwnedWebhooks: number,
  }
}

export class DeleteWebhookRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getWebhookId(): string;
  setWebhookId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeleteWebhookRequest.AsObject;
  static toObject(includeInstance: boolean, msg: DeleteWebhookRequest): DeleteWebhookRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeleteWebhookRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeleteWebhookRequest;
  static deserializeBinaryFromReader(message: DeleteWebhookRequest, reader: jspb.BinaryReader): DeleteWebhookRequest;
}

export namespace DeleteWebhookRequest {
  export type AsObject = {
    apiKey: string,
    webhookId: string,
  }
}

export class DeleteWebhookResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeleteWebhookResponse.AsObject;
  static toObject(includeInstance: boolean, msg: DeleteWebhookResponse): DeleteWebhookResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeleteWebhookResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeleteWebhookResponse;
  static deserializeBinaryFromReader(message: DeleteWebhookResponse, reader: jspb.BinaryReader): DeleteWebhookResponse;
}

export namespace DeleteWebhookResponse {
  export type AsObject = {
  }
}

export class EventRequest extends jspb.Message {
  hasEvent(): boolean;
  clearEvent(): void;
  getEvent(): Event | undefined;
  setEvent(value?: Event): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventRequest.AsObject;
  static toObject(includeInstance: boolean, msg: EventRequest): EventRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventRequest;
  static deserializeBinaryFromReader(message: EventRequest, reader: jspb.BinaryReader): EventRequest;
}

export namespace EventRequest {
  export type AsObject = {
    event?: Event.AsObject,
  }
}

export class EventResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventResponse.AsObject;
  static toObject(includeInstance: boolean, msg: EventResponse): EventResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventResponse;
  static deserializeBinaryFromReader(message: EventResponse, reader: jspb.BinaryReader): EventResponse;
}

export namespace EventResponse {
  export type AsObject = {
  }
}

export class ListEventsRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPage(): number;
  setPage(value: number): void;

  getPageSize(): number;
  setPageSize(value: number): void;

  hasFilters(): boolean;
  clearFilters(): void;
  getFilters(): common_v1_common_pb.Filter | undefined;
  setFilters(value?: common_v1_common_pb.Filter): void;

  hasSortBy(): boolean;
  clearSortBy(): void;
  getSortBy(): common_v1_common_pb.SortBy | undefined;
  setSortBy(value?: common_v1_common_pb.SortBy): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListEventsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListEventsRequest): ListEventsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListEventsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListEventsRequest;
  static deserializeBinaryFromReader(message: ListEventsRequest, reader: jspb.BinaryReader): ListEventsRequest;
}

export namespace ListEventsRequest {
  export type AsObject = {
    apiKey: string,
    page: number,
    pageSize: number,
    filters?: common_v1_common_pb.Filter.AsObject,
    sortBy?: common_v1_common_pb.SortBy.AsObject,
  }
}

export class ListEventsResponse extends jspb.Message {
  clearEventsList(): void;
  getEventsList(): Array<Event>;
  setEventsList(value: Array<Event>): void;
  addEvents(value?: Event, index?: number): Event;

  getTotalOwnedEvents(): number;
  setTotalOwnedEvents(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListEventsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListEventsResponse): ListEventsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListEventsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListEventsResponse;
  static deserializeBinaryFromReader(message: ListEventsResponse, reader: jspb.BinaryReader): ListEventsResponse;
}

export namespace ListEventsResponse {
  export type AsObject = {
    eventsList: Array<Event.AsObject>,
    totalOwnedEvents: number,
  }
}

export class RetryEventRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getEventId(): string;
  setEventId(value: string): void;

  getWebhookId(): string;
  setWebhookId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RetryEventRequest.AsObject;
  static toObject(includeInstance: boolean, msg: RetryEventRequest): RetryEventRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RetryEventRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RetryEventRequest;
  static deserializeBinaryFromReader(message: RetryEventRequest, reader: jspb.BinaryReader): RetryEventRequest;
}

export namespace RetryEventRequest {
  export type AsObject = {
    apiKey: string,
    eventId: string,
    webhookId: string,
  }
}

export class RetryEventResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RetryEventResponse.AsObject;
  static toObject(includeInstance: boolean, msg: RetryEventResponse): RetryEventResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RetryEventResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RetryEventResponse;
  static deserializeBinaryFromReader(message: RetryEventResponse, reader: jspb.BinaryReader): RetryEventResponse;
}

export namespace RetryEventResponse {
  export type AsObject = {
  }
}

export class PingRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getMessage(): string;
  setMessage(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PingRequest.AsObject;
  static toObject(includeInstance: boolean, msg: PingRequest): PingRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PingRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PingRequest;
  static deserializeBinaryFromReader(message: PingRequest, reader: jspb.BinaryReader): PingRequest;
}

export namespace PingRequest {
  export type AsObject = {
    apiKey: string,
    message: string,
  }
}

export class PingResponse extends jspb.Message {
  getMessage(): string;
  setMessage(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PingResponse.AsObject;
  static toObject(includeInstance: boolean, msg: PingResponse): PingResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PingResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PingResponse;
  static deserializeBinaryFromReader(message: PingResponse, reader: jspb.BinaryReader): PingResponse;
}

export namespace PingResponse {
  export type AsObject = {
    message: string,
  }
}

export class ListDeliveryHistoryRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPage(): number;
  setPage(value: number): void;

  getPageSize(): number;
  setPageSize(value: number): void;

  hasFilters(): boolean;
  clearFilters(): void;
  getFilters(): common_v1_common_pb.Filter | undefined;
  setFilters(value?: common_v1_common_pb.Filter): void;

  hasSortBy(): boolean;
  clearSortBy(): void;
  getSortBy(): common_v1_common_pb.SortBy | undefined;
  setSortBy(value?: common_v1_common_pb.SortBy): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListDeliveryHistoryRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListDeliveryHistoryRequest): ListDeliveryHistoryRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListDeliveryHistoryRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListDeliveryHistoryRequest;
  static deserializeBinaryFromReader(message: ListDeliveryHistoryRequest, reader: jspb.BinaryReader): ListDeliveryHistoryRequest;
}

export namespace ListDeliveryHistoryRequest {
  export type AsObject = {
    apiKey: string,
    page: number,
    pageSize: number,
    filters?: common_v1_common_pb.Filter.AsObject,
    sortBy?: common_v1_common_pb.SortBy.AsObject,
  }
}

export class ListDeliveryHistoryResponse extends jspb.Message {
  clearDeliveryHistoryList(): void;
  getDeliveryHistoryList(): Array<ListDeliveryHistoryResponse.DeliveryHistory>;
  setDeliveryHistoryList(value: Array<ListDeliveryHistoryResponse.DeliveryHistory>): void;
  addDeliveryHistory(value?: ListDeliveryHistoryResponse.DeliveryHistory, index?: number): ListDeliveryHistoryResponse.DeliveryHistory;

  getTotalOwnedDeliveryHistory(): number;
  setTotalOwnedDeliveryHistory(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListDeliveryHistoryResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListDeliveryHistoryResponse): ListDeliveryHistoryResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListDeliveryHistoryResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListDeliveryHistoryResponse;
  static deserializeBinaryFromReader(message: ListDeliveryHistoryResponse, reader: jspb.BinaryReader): ListDeliveryHistoryResponse;
}

export namespace ListDeliveryHistoryResponse {
  export type AsObject = {
    deliveryHistoryList: Array<ListDeliveryHistoryResponse.DeliveryHistory.AsObject>,
    totalOwnedDeliveryHistory: number,
  }

  export class DeliveryHistory extends jspb.Message {
    getId(): string;
    setId(value: string): void;

    getWebhookId(): string;
    setWebhookId(value: string): void;

    getEventId(): string;
    setEventId(value: string): void;

    getOwnerId(): string;
    setOwnerId(value: string): void;

    getDeliveryStage(): DeliveryStageMap[keyof DeliveryStageMap];
    setDeliveryStage(value: DeliveryStageMap[keyof DeliveryStageMap]): void;

    getCreated(): string;
    setCreated(value: string): void;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DeliveryHistory.AsObject;
    static toObject(includeInstance: boolean, msg: DeliveryHistory): DeliveryHistory.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DeliveryHistory, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DeliveryHistory;
    static deserializeBinaryFromReader(message: DeliveryHistory, reader: jspb.BinaryReader): DeliveryHistory;
  }

  export namespace DeliveryHistory {
    export type AsObject = {
      id: string,
      webhookId: string,
      eventId: string,
      ownerId: string,
      deliveryStage: DeliveryStageMap[keyof DeliveryStageMap],
      created: string,
    }
  }
}

export class ScheduledReaction extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getName(): string;
  setName(value: string): void;

  getReactionType(): ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap];
  setReactionType(value: ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap]): void;

  getCronTab(): string;
  setCronTab(value: string): void;

  hasCreateContractPayload(): boolean;
  clearCreateContractPayload(): void;
  getCreateContractPayload(): CreateContractReactionPayload | undefined;
  setCreateContractPayload(value?: CreateContractReactionPayload): void;

  getReactionPayloadCase(): ScheduledReaction.ReactionPayloadCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ScheduledReaction.AsObject;
  static toObject(includeInstance: boolean, msg: ScheduledReaction): ScheduledReaction.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ScheduledReaction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ScheduledReaction;
  static deserializeBinaryFromReader(message: ScheduledReaction, reader: jspb.BinaryReader): ScheduledReaction;
}

export namespace ScheduledReaction {
  export type AsObject = {
    id: string,
    name: string,
    reactionType: ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap],
    cronTab: string,
    createContractPayload?: CreateContractReactionPayload.AsObject,
  }

  export enum ReactionPayloadCase {
    REACTION_PAYLOAD_NOT_SET = 0,
    CREATE_CONTRACT_PAYLOAD = 5,
  }
}

export class CreateContractReactionPayload extends jspb.Message {
  getSenderWalletId(): string;
  setSenderWalletId(value: string): void;

  clearCommitmentsList(): void;
  getCommitmentsList(): Array<common_v1_packet_pb.Commitment>;
  setCommitmentsList(value: Array<common_v1_packet_pb.Commitment>): void;
  addCommitments(value?: common_v1_packet_pb.Commitment, index?: number): common_v1_packet_pb.Commitment;

  clearConditionsList(): void;
  getConditionsList(): Array<common_v1_packet_pb.Condition>;
  setConditionsList(value: Array<common_v1_packet_pb.Condition>): void;
  addConditions(value?: common_v1_packet_pb.Condition, index?: number): common_v1_packet_pb.Condition;

  getTimeoutSecs(): number;
  setTimeoutSecs(value: number): void;

  getMemo(): string;
  setMemo(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateContractReactionPayload.AsObject;
  static toObject(includeInstance: boolean, msg: CreateContractReactionPayload): CreateContractReactionPayload.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateContractReactionPayload, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateContractReactionPayload;
  static deserializeBinaryFromReader(message: CreateContractReactionPayload, reader: jspb.BinaryReader): CreateContractReactionPayload;
}

export namespace CreateContractReactionPayload {
  export type AsObject = {
    senderWalletId: string,
    commitmentsList: Array<common_v1_packet_pb.Commitment.AsObject>,
    conditionsList: Array<common_v1_packet_pb.Condition.AsObject>,
    timeoutSecs: number,
    memo: string,
  }
}

export class CreateScheduledReactionRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getName(): string;
  setName(value: string): void;

  getReactionType(): ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap];
  setReactionType(value: ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap]): void;

  getCronTab(): string;
  setCronTab(value: string): void;

  hasCreateContractPayload(): boolean;
  clearCreateContractPayload(): void;
  getCreateContractPayload(): CreateContractReactionPayload | undefined;
  setCreateContractPayload(value?: CreateContractReactionPayload): void;

  getReactionPayloadCase(): CreateScheduledReactionRequest.ReactionPayloadCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateScheduledReactionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: CreateScheduledReactionRequest): CreateScheduledReactionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateScheduledReactionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateScheduledReactionRequest;
  static deserializeBinaryFromReader(message: CreateScheduledReactionRequest, reader: jspb.BinaryReader): CreateScheduledReactionRequest;
}

export namespace CreateScheduledReactionRequest {
  export type AsObject = {
    apiKey: string,
    name: string,
    reactionType: ScheduleReactionTypeMap[keyof ScheduleReactionTypeMap],
    cronTab: string,
    createContractPayload?: CreateContractReactionPayload.AsObject,
  }

  export enum ReactionPayloadCase {
    REACTION_PAYLOAD_NOT_SET = 0,
    CREATE_CONTRACT_PAYLOAD = 5,
  }
}

export class CreateScheduledReactionResponse extends jspb.Message {
  hasScheduledReaction(): boolean;
  clearScheduledReaction(): void;
  getScheduledReaction(): ScheduledReaction | undefined;
  setScheduledReaction(value?: ScheduledReaction): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreateScheduledReactionResponse.AsObject;
  static toObject(includeInstance: boolean, msg: CreateScheduledReactionResponse): CreateScheduledReactionResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreateScheduledReactionResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreateScheduledReactionResponse;
  static deserializeBinaryFromReader(message: CreateScheduledReactionResponse, reader: jspb.BinaryReader): CreateScheduledReactionResponse;
}

export namespace CreateScheduledReactionResponse {
  export type AsObject = {
    scheduledReaction?: ScheduledReaction.AsObject,
  }
}

export class ListScheduledReactionsRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPage(): number;
  setPage(value: number): void;

  getPageSize(): number;
  setPageSize(value: number): void;

  hasFilters(): boolean;
  clearFilters(): void;
  getFilters(): common_v1_common_pb.Filter | undefined;
  setFilters(value?: common_v1_common_pb.Filter): void;

  hasSortBy(): boolean;
  clearSortBy(): void;
  getSortBy(): common_v1_common_pb.SortBy | undefined;
  setSortBy(value?: common_v1_common_pb.SortBy): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListScheduledReactionsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListScheduledReactionsRequest): ListScheduledReactionsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListScheduledReactionsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListScheduledReactionsRequest;
  static deserializeBinaryFromReader(message: ListScheduledReactionsRequest, reader: jspb.BinaryReader): ListScheduledReactionsRequest;
}

export namespace ListScheduledReactionsRequest {
  export type AsObject = {
    apiKey: string,
    page: number,
    pageSize: number,
    filters?: common_v1_common_pb.Filter.AsObject,
    sortBy?: common_v1_common_pb.SortBy.AsObject,
  }
}

export class ListScheduledReactionsResponse extends jspb.Message {
  clearScheduledReactionsList(): void;
  getScheduledReactionsList(): Array<ScheduledReaction>;
  setScheduledReactionsList(value: Array<ScheduledReaction>): void;
  addScheduledReactions(value?: ScheduledReaction, index?: number): ScheduledReaction;

  getTotalOwnedScheduledReactions(): number;
  setTotalOwnedScheduledReactions(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListScheduledReactionsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListScheduledReactionsResponse): ListScheduledReactionsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListScheduledReactionsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListScheduledReactionsResponse;
  static deserializeBinaryFromReader(message: ListScheduledReactionsResponse, reader: jspb.BinaryReader): ListScheduledReactionsResponse;
}

export namespace ListScheduledReactionsResponse {
  export type AsObject = {
    scheduledReactionsList: Array<ScheduledReaction.AsObject>,
    totalOwnedScheduledReactions: number,
  }
}

export class DeleteScheduledReactionRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getScheduledReactionId(): string;
  setScheduledReactionId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeleteScheduledReactionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: DeleteScheduledReactionRequest): DeleteScheduledReactionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeleteScheduledReactionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeleteScheduledReactionRequest;
  static deserializeBinaryFromReader(message: DeleteScheduledReactionRequest, reader: jspb.BinaryReader): DeleteScheduledReactionRequest;
}

export namespace DeleteScheduledReactionRequest {
  export type AsObject = {
    apiKey: string,
    scheduledReactionId: string,
  }
}

export class DeleteScheduledReactionResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeleteScheduledReactionResponse.AsObject;
  static toObject(includeInstance: boolean, msg: DeleteScheduledReactionResponse): DeleteScheduledReactionResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeleteScheduledReactionResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeleteScheduledReactionResponse;
  static deserializeBinaryFromReader(message: DeleteScheduledReactionResponse, reader: jspb.BinaryReader): DeleteScheduledReactionResponse;
}

export namespace DeleteScheduledReactionResponse {
  export type AsObject = {
  }
}

export class Prevalidation extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getName(): string;
  setName(value: string): void;

  hasConsideringContractPrevalidation(): boolean;
  clearConsideringContractPrevalidation(): void;
  getConsideringContractPrevalidation(): ConsideringContractPrevalidation | undefined;
  setConsideringContractPrevalidation(value?: ConsideringContractPrevalidation): void;

  getTriggerCase(): Prevalidation.TriggerCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Prevalidation.AsObject;
  static toObject(includeInstance: boolean, msg: Prevalidation): Prevalidation.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Prevalidation, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Prevalidation;
  static deserializeBinaryFromReader(message: Prevalidation, reader: jspb.BinaryReader): Prevalidation;
}

export namespace Prevalidation {
  export type AsObject = {
    id: string,
    name: string,
    consideringContractPrevalidation?: ConsideringContractPrevalidation.AsObject,
  }

  export enum TriggerCase {
    TRIGGER_NOT_SET = 0,
    CONSIDERING_CONTRACT_PREVALIDATION = 3,
  }
}

export class ConsideringContractPrevalidation extends jspb.Message {
  clearConditionList(): void;
  getConditionList(): Array<ConsideringContractPrevalidation.ValidationCondition>;
  setConditionList(value: Array<ConsideringContractPrevalidation.ValidationCondition>): void;
  addCondition(value?: ConsideringContractPrevalidation.ValidationCondition, index?: number): ConsideringContractPrevalidation.ValidationCondition;

  getOutcome(): ConsideringContractPrevalidation.ValidationOutcomeMap[keyof ConsideringContractPrevalidation.ValidationOutcomeMap];
  setOutcome(value: ConsideringContractPrevalidation.ValidationOutcomeMap[keyof ConsideringContractPrevalidation.ValidationOutcomeMap]): void;

  getLogicalBase(): common_v1_common_pb.LogicalOperatorMap[keyof common_v1_common_pb.LogicalOperatorMap];
  setLogicalBase(value: common_v1_common_pb.LogicalOperatorMap[keyof common_v1_common_pb.LogicalOperatorMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConsideringContractPrevalidation.AsObject;
  static toObject(includeInstance: boolean, msg: ConsideringContractPrevalidation): ConsideringContractPrevalidation.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConsideringContractPrevalidation, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConsideringContractPrevalidation;
  static deserializeBinaryFromReader(message: ConsideringContractPrevalidation, reader: jspb.BinaryReader): ConsideringContractPrevalidation;
}

export namespace ConsideringContractPrevalidation {
  export type AsObject = {
    conditionList: Array<ConsideringContractPrevalidation.ValidationCondition.AsObject>,
    outcome: ConsideringContractPrevalidation.ValidationOutcomeMap[keyof ConsideringContractPrevalidation.ValidationOutcomeMap],
    logicalBase: common_v1_common_pb.LogicalOperatorMap[keyof common_v1_common_pb.LogicalOperatorMap],
  }

  export class ValidationCondition extends jspb.Message {
    getTarget(): ConsideringContractPrevalidation.ValidationTargetMap[keyof ConsideringContractPrevalidation.ValidationTargetMap];
    setTarget(value: ConsideringContractPrevalidation.ValidationTargetMap[keyof ConsideringContractPrevalidation.ValidationTargetMap]): void;

    getOperator(): ValidationOperatorMap[keyof ValidationOperatorMap];
    setOperator(value: ValidationOperatorMap[keyof ValidationOperatorMap]): void;

    hasAmountValue(): boolean;
    clearAmountValue(): void;
    getAmountValue(): common_v1_common_pb.Amount | undefined;
    setAmountValue(value?: common_v1_common_pb.Amount): void;

    getValueCase(): ValidationCondition.ValueCase;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ValidationCondition.AsObject;
    static toObject(includeInstance: boolean, msg: ValidationCondition): ValidationCondition.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ValidationCondition, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ValidationCondition;
    static deserializeBinaryFromReader(message: ValidationCondition, reader: jspb.BinaryReader): ValidationCondition;
  }

  export namespace ValidationCondition {
    export type AsObject = {
      target: ConsideringContractPrevalidation.ValidationTargetMap[keyof ConsideringContractPrevalidation.ValidationTargetMap],
      operator: ValidationOperatorMap[keyof ValidationOperatorMap],
      amountValue?: common_v1_common_pb.Amount.AsObject,
    }

    export enum ValueCase {
      VALUE_NOT_SET = 0,
      AMOUNT_VALUE = 3,
    }
  }

  export interface ValidationTargetMap {
    VALIDATION_TARGET_UNSPECIFIED: 0;
    VALIDATION_TARGET_RECIPIENT_BALANCE: 1;
  }

  export const ValidationTarget: ValidationTargetMap;

  export interface ValidationOutcomeMap {
    CONSIDERING_CONTRACT_OUTCOME_UNSPECIFIED: 0;
    CONSIDERING_CONTRACT_OUTCOME_ACCEPTED: 1;
    CONSIDERING_CONTRACT_OUTCOME_REJECTED: 2;
  }

  export const ValidationOutcome: ValidationOutcomeMap;
}

export class CreatePrevalidationRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getName(): string;
  setName(value: string): void;

  hasConsideringContractPrevalidation(): boolean;
  clearConsideringContractPrevalidation(): void;
  getConsideringContractPrevalidation(): ConsideringContractPrevalidation | undefined;
  setConsideringContractPrevalidation(value?: ConsideringContractPrevalidation): void;

  getTriggerCase(): CreatePrevalidationRequest.TriggerCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreatePrevalidationRequest.AsObject;
  static toObject(includeInstance: boolean, msg: CreatePrevalidationRequest): CreatePrevalidationRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreatePrevalidationRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreatePrevalidationRequest;
  static deserializeBinaryFromReader(message: CreatePrevalidationRequest, reader: jspb.BinaryReader): CreatePrevalidationRequest;
}

export namespace CreatePrevalidationRequest {
  export type AsObject = {
    apiKey: string,
    name: string,
    consideringContractPrevalidation?: ConsideringContractPrevalidation.AsObject,
  }

  export enum TriggerCase {
    TRIGGER_NOT_SET = 0,
    CONSIDERING_CONTRACT_PREVALIDATION = 3,
  }
}

export class CreatePrevalidationResponse extends jspb.Message {
  hasPrevalidation(): boolean;
  clearPrevalidation(): void;
  getPrevalidation(): Prevalidation | undefined;
  setPrevalidation(value?: Prevalidation): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CreatePrevalidationResponse.AsObject;
  static toObject(includeInstance: boolean, msg: CreatePrevalidationResponse): CreatePrevalidationResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CreatePrevalidationResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CreatePrevalidationResponse;
  static deserializeBinaryFromReader(message: CreatePrevalidationResponse, reader: jspb.BinaryReader): CreatePrevalidationResponse;
}

export namespace CreatePrevalidationResponse {
  export type AsObject = {
    prevalidation?: Prevalidation.AsObject,
  }
}

export class ListPrevalidationsRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPage(): number;
  setPage(value: number): void;

  getPageSize(): number;
  setPageSize(value: number): void;

  hasFilters(): boolean;
  clearFilters(): void;
  getFilters(): common_v1_common_pb.Filter | undefined;
  setFilters(value?: common_v1_common_pb.Filter): void;

  hasSortBy(): boolean;
  clearSortBy(): void;
  getSortBy(): common_v1_common_pb.SortBy | undefined;
  setSortBy(value?: common_v1_common_pb.SortBy): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListPrevalidationsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ListPrevalidationsRequest): ListPrevalidationsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListPrevalidationsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListPrevalidationsRequest;
  static deserializeBinaryFromReader(message: ListPrevalidationsRequest, reader: jspb.BinaryReader): ListPrevalidationsRequest;
}

export namespace ListPrevalidationsRequest {
  export type AsObject = {
    apiKey: string,
    page: number,
    pageSize: number,
    filters?: common_v1_common_pb.Filter.AsObject,
    sortBy?: common_v1_common_pb.SortBy.AsObject,
  }
}

export class ListPrevalidationsResponse extends jspb.Message {
  clearPrevalidationsList(): void;
  getPrevalidationsList(): Array<Prevalidation>;
  setPrevalidationsList(value: Array<Prevalidation>): void;
  addPrevalidations(value?: Prevalidation, index?: number): Prevalidation;

  getTotalOwnedPrevalidations(): number;
  setTotalOwnedPrevalidations(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ListPrevalidationsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: ListPrevalidationsResponse): ListPrevalidationsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ListPrevalidationsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ListPrevalidationsResponse;
  static deserializeBinaryFromReader(message: ListPrevalidationsResponse, reader: jspb.BinaryReader): ListPrevalidationsResponse;
}

export namespace ListPrevalidationsResponse {
  export type AsObject = {
    prevalidationsList: Array<Prevalidation.AsObject>,
    totalOwnedPrevalidations: number,
  }
}

export class DeletePrevalidationRequest extends jspb.Message {
  getApiKey(): string;
  setApiKey(value: string): void;

  getPrevalidationId(): string;
  setPrevalidationId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeletePrevalidationRequest.AsObject;
  static toObject(includeInstance: boolean, msg: DeletePrevalidationRequest): DeletePrevalidationRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeletePrevalidationRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeletePrevalidationRequest;
  static deserializeBinaryFromReader(message: DeletePrevalidationRequest, reader: jspb.BinaryReader): DeletePrevalidationRequest;
}

export namespace DeletePrevalidationRequest {
  export type AsObject = {
    apiKey: string,
    prevalidationId: string,
  }
}

export class DeletePrevalidationResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DeletePrevalidationResponse.AsObject;
  static toObject(includeInstance: boolean, msg: DeletePrevalidationResponse): DeletePrevalidationResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DeletePrevalidationResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DeletePrevalidationResponse;
  static deserializeBinaryFromReader(message: DeletePrevalidationResponse, reader: jspb.BinaryReader): DeletePrevalidationResponse;
}

export namespace DeletePrevalidationResponse {
  export type AsObject = {
  }
}

export interface DeliveryStageMap {
  DELIVERY_STAGE_UNSPECIFIED: 0;
  DELIVERY_STAGE_FIRST_RETRY: 1;
  DELIVERY_STAGE_SECOND_RETRY: 2;
  DELIVERY_STAGE_THIRD_RETRY: 3;
  DELIVERY_STAGE_FOURTH_RETRY: 4;
  DELIVERY_STAGE_FIFTH_RETRY: 5;
  DELIVERY_STAGE_FAILED: 6;
  DELIVERY_STAGE_SUCCESS: 7;
}

export const DeliveryStage: DeliveryStageMap;

export interface EventTypeMap {
  EVENT_TYPE_UNSPECIFIED: 0;
  EVENT_TYPE_WALLET_CREATED: 1;
  EVENT_TYPE_PROMISSORY_RECEIVED: 2;
  EVENT_TYPE_PING: 3;
  EVENT_TYPE_CONTRACT_PROPOSAL_COMPLETED: 4;
  EVENT_TYPE_CONTRACT_PAYMENT_COMPLETED: 5;
}

export const EventType: EventTypeMap;

export interface DeliveryMethodTypeMap {
  DELIVERY_METHOD_TYPE_UNSPECIFIED: 0;
  DELIVERY_METHOD_TYPE_HTTP: 1;
  DELIVERY_METHOD_TYPE_GRPC: 2;
}

export const DeliveryMethodType: DeliveryMethodTypeMap;

export interface ScheduleReactionTypeMap {
  SCHEDULE_REACTION_TYPE_UNSPECIFIED: 0;
  SCHEDULE_REACTION_TYPE_CREATE_CONTRACT: 1;
}

export const ScheduleReactionType: ScheduleReactionTypeMap;

export interface ValidationOperatorMap {
  VALIDATION_OPERATOR_UNSPECIFIED: 0;
  VALIDATION_OPERATOR_EQUAL: 1;
  VALIDATION_OPERATOR_GREATER_THAN: 2;
  VALIDATION_OPERATOR_GREATER_THAN_OR_EQUAL: 3;
  VALIDATION_OPERATOR_LESS_THAN: 4;
  VALIDATION_OPERATOR_LESS_THAN_OR_EQUAL: 5;
}

export const ValidationOperator: ValidationOperatorMap;

