/* eslint-disable */
/*Generated by GenDocu.com*/
// package: common
// file: common/v1/common.proto

import * as jspb from "google-protobuf";

export class DynamicVerifier extends jspb.Message {
  getSignatureSystem(): SignatureSystemMap[keyof SignatureSystemMap];
  setSignatureSystem(value: SignatureSystemMap[keyof SignatureSystemMap]): void;

  getVerifier(): Uint8Array | string;
  getVerifier_asU8(): Uint8Array;
  getVerifier_asB64(): string;
  setVerifier(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DynamicVerifier.AsObject;
  static toObject(includeInstance: boolean, msg: DynamicVerifier): DynamicVerifier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DynamicVerifier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DynamicVerifier;
  static deserializeBinaryFromReader(message: DynamicVerifier, reader: jspb.BinaryReader): DynamicVerifier;
}

export namespace DynamicVerifier {
  export type AsObject = {
    signatureSystem: SignatureSystemMap[keyof SignatureSystemMap],
    verifier: Uint8Array | string,
  }
}

export class Amount extends jspb.Message {
  getCurrencyCode(): string;
  setCurrencyCode(value: string): void;

  getAmount(): number;
  setAmount(value: number): void;

  getDecimals(): number;
  setDecimals(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Amount.AsObject;
  static toObject(includeInstance: boolean, msg: Amount): Amount.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Amount, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Amount;
  static deserializeBinaryFromReader(message: Amount, reader: jspb.BinaryReader): Amount;
}

export namespace Amount {
  export type AsObject = {
    currencyCode: string,
    amount: number,
    decimals: number,
  }
}

export class Distribution extends jspb.Message {
  getValueMap(): jspb.Map<number, number>;
  clearValueMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Distribution.AsObject;
  static toObject(includeInstance: boolean, msg: Distribution): Distribution.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Distribution, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Distribution;
  static deserializeBinaryFromReader(message: Distribution, reader: jspb.BinaryReader): Distribution;
}

export namespace Distribution {
  export type AsObject = {
    valueMap: Array<[number, number]>,
  }
}

export class AuthenticationRequest extends jspb.Message {
  hasVerifier(): boolean;
  clearVerifier(): void;
  getVerifier(): DynamicVerifier | undefined;
  setVerifier(value?: DynamicVerifier): void;

  getConnectionId(): string;
  setConnectionId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AuthenticationRequest.AsObject;
  static toObject(includeInstance: boolean, msg: AuthenticationRequest): AuthenticationRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AuthenticationRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AuthenticationRequest;
  static deserializeBinaryFromReader(message: AuthenticationRequest, reader: jspb.BinaryReader): AuthenticationRequest;
}

export namespace AuthenticationRequest {
  export type AsObject = {
    verifier?: DynamicVerifier.AsObject,
    connectionId: string,
  }
}

export class AuthenticationResponse extends jspb.Message {
  getChallenge(): Uint8Array | string;
  getChallenge_asU8(): Uint8Array;
  getChallenge_asB64(): string;
  setChallenge(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AuthenticationResponse.AsObject;
  static toObject(includeInstance: boolean, msg: AuthenticationResponse): AuthenticationResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AuthenticationResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AuthenticationResponse;
  static deserializeBinaryFromReader(message: AuthenticationResponse, reader: jspb.BinaryReader): AuthenticationResponse;
}

export namespace AuthenticationResponse {
  export type AsObject = {
    challenge: Uint8Array | string,
  }
}

export class OneConnection extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OneConnection.AsObject;
  static toObject(includeInstance: boolean, msg: OneConnection): OneConnection.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OneConnection, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OneConnection;
  static deserializeBinaryFromReader(message: OneConnection, reader: jspb.BinaryReader): OneConnection;
}

export namespace OneConnection {
  export type AsObject = {
  }
}

export class ManyConnection extends jspb.Message {
  clearAssociatedVerifiersList(): void;
  getAssociatedVerifiersList(): Array<DynamicVerifier>;
  setAssociatedVerifiersList(value: Array<DynamicVerifier>): void;
  addAssociatedVerifiers(value?: DynamicVerifier, index?: number): DynamicVerifier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ManyConnection.AsObject;
  static toObject(includeInstance: boolean, msg: ManyConnection): ManyConnection.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ManyConnection, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ManyConnection;
  static deserializeBinaryFromReader(message: ManyConnection, reader: jspb.BinaryReader): ManyConnection;
}

export namespace ManyConnection {
  export type AsObject = {
    associatedVerifiersList: Array<DynamicVerifier.AsObject>,
  }
}

export class AssociatedConnection extends jspb.Message {
  hasPrimaryVerifier(): boolean;
  clearPrimaryVerifier(): void;
  getPrimaryVerifier(): DynamicVerifier | undefined;
  setPrimaryVerifier(value?: DynamicVerifier): void;

  hasAssociatedVerifier(): boolean;
  clearAssociatedVerifier(): void;
  getAssociatedVerifier(): DynamicVerifier | undefined;
  setAssociatedVerifier(value?: DynamicVerifier): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AssociatedConnection.AsObject;
  static toObject(includeInstance: boolean, msg: AssociatedConnection): AssociatedConnection.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AssociatedConnection, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AssociatedConnection;
  static deserializeBinaryFromReader(message: AssociatedConnection, reader: jspb.BinaryReader): AssociatedConnection;
}

export namespace AssociatedConnection {
  export type AsObject = {
    primaryVerifier?: DynamicVerifier.AsObject,
    associatedVerifier?: DynamicVerifier.AsObject,
  }
}

export class ConnectionRequest extends jspb.Message {
  hasOne(): boolean;
  clearOne(): void;
  getOne(): OneConnection | undefined;
  setOne(value?: OneConnection): void;

  hasMany(): boolean;
  clearMany(): void;
  getMany(): ManyConnection | undefined;
  setMany(value?: ManyConnection): void;

  hasSignature(): boolean;
  clearSignature(): void;
  getSignature(): AuthenticationSignature | undefined;
  setSignature(value?: AuthenticationSignature): void;

  getConnectionId(): string;
  setConnectionId(value: string): void;

  getRequestTypeCase(): ConnectionRequest.RequestTypeCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ConnectionRequest.AsObject;
  static toObject(includeInstance: boolean, msg: ConnectionRequest): ConnectionRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ConnectionRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ConnectionRequest;
  static deserializeBinaryFromReader(message: ConnectionRequest, reader: jspb.BinaryReader): ConnectionRequest;
}

export namespace ConnectionRequest {
  export type AsObject = {
    one?: OneConnection.AsObject,
    many?: ManyConnection.AsObject,
    signature?: AuthenticationSignature.AsObject,
    connectionId: string,
  }

  export enum RequestTypeCase {
    REQUEST_TYPE_NOT_SET = 0,
    ONE = 1,
    MANY = 2,
  }
}

export class AuthenticationSignature extends jspb.Message {
  hasVerifier(): boolean;
  clearVerifier(): void;
  getVerifier(): DynamicVerifier | undefined;
  setVerifier(value?: DynamicVerifier): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AuthenticationSignature.AsObject;
  static toObject(includeInstance: boolean, msg: AuthenticationSignature): AuthenticationSignature.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AuthenticationSignature, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AuthenticationSignature;
  static deserializeBinaryFromReader(message: AuthenticationSignature, reader: jspb.BinaryReader): AuthenticationSignature;
}

export namespace AuthenticationSignature {
  export type AsObject = {
    verifier?: DynamicVerifier.AsObject,
    signature: Uint8Array | string,
  }
}

export class AuthorizedSignatureResponse extends jspb.Message {
  getPromissoryFile(): Uint8Array | string;
  getPromissoryFile_asU8(): Uint8Array;
  getPromissoryFile_asB64(): string;
  setPromissoryFile(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AuthorizedSignatureResponse.AsObject;
  static toObject(includeInstance: boolean, msg: AuthorizedSignatureResponse): AuthorizedSignatureResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AuthorizedSignatureResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AuthorizedSignatureResponse;
  static deserializeBinaryFromReader(message: AuthorizedSignatureResponse, reader: jspb.BinaryReader): AuthorizedSignatureResponse;
}

export namespace AuthorizedSignatureResponse {
  export type AsObject = {
    promissoryFile: Uint8Array | string,
  }
}

export class Media extends jspb.Message {
  getMimeType(): string;
  setMimeType(value: string): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Media.AsObject;
  static toObject(includeInstance: boolean, msg: Media): Media.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Media, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Media;
  static deserializeBinaryFromReader(message: Media, reader: jspb.BinaryReader): Media;
}

export namespace Media {
  export type AsObject = {
    mimeType: string,
    data: Uint8Array | string,
  }
}

export class Role extends jspb.Message {
  getVerifier(): string;
  setVerifier(value: string): void;

  hasAuthorized(): boolean;
  clearAuthorized(): void;
  getAuthorized(): boolean;
  setAuthorized(value: boolean): void;

  hasIssuePermissions(): boolean;
  clearIssuePermissions(): void;
  getIssuePermissions(): Role.IssuePermissions | undefined;
  setIssuePermissions(value?: Role.IssuePermissions): void;

  getRoleEnumCase(): Role.RoleEnumCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Role.AsObject;
  static toObject(includeInstance: boolean, msg: Role): Role.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Role, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Role;
  static deserializeBinaryFromReader(message: Role, reader: jspb.BinaryReader): Role;
}

export namespace Role {
  export type AsObject = {
    verifier: string,
    authorized: boolean,
    issuePermissions?: Role.IssuePermissions.AsObject,
  }

  export class IssuePermissions extends jspb.Message {
    clearInnerList(): void;
    getInnerList(): Array<Amount>;
    setInnerList(value: Array<Amount>): void;
    addInner(value?: Amount, index?: number): Amount;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): IssuePermissions.AsObject;
    static toObject(includeInstance: boolean, msg: IssuePermissions): IssuePermissions.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: IssuePermissions, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): IssuePermissions;
    static deserializeBinaryFromReader(message: IssuePermissions, reader: jspb.BinaryReader): IssuePermissions;
  }

  export namespace IssuePermissions {
    export type AsObject = {
      innerList: Array<Amount.AsObject>,
    }
  }

  export enum RoleEnumCase {
    ROLE_ENUM_NOT_SET = 0,
    AUTHORIZED = 3,
    ISSUE_PERMISSIONS = 4,
  }
}

export class GetVerifierRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVerifierRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetVerifierRequest): GetVerifierRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVerifierRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVerifierRequest;
  static deserializeBinaryFromReader(message: GetVerifierRequest, reader: jspb.BinaryReader): GetVerifierRequest;
}

export namespace GetVerifierRequest {
  export type AsObject = {
  }
}

export class GetVerifierResponse extends jspb.Message {
  hasBytes(): boolean;
  clearBytes(): void;
  getBytes(): DynamicVerifier | undefined;
  setBytes(value?: DynamicVerifier): void;

  getMultibase(): string;
  setMultibase(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetVerifierResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetVerifierResponse): GetVerifierResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetVerifierResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetVerifierResponse;
  static deserializeBinaryFromReader(message: GetVerifierResponse, reader: jspb.BinaryReader): GetVerifierResponse;
}

export namespace GetVerifierResponse {
  export type AsObject = {
    bytes?: DynamicVerifier.AsObject,
    multibase: string,
  }
}

export class GetServiceTypeRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetServiceTypeRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetServiceTypeRequest): GetServiceTypeRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetServiceTypeRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetServiceTypeRequest;
  static deserializeBinaryFromReader(message: GetServiceTypeRequest, reader: jspb.BinaryReader): GetServiceTypeRequest;
}

export namespace GetServiceTypeRequest {
  export type AsObject = {
  }
}

export class GetServiceTypeResponse extends jspb.Message {
  getServiceType(): ServiceTypeMap[keyof ServiceTypeMap];
  setServiceType(value: ServiceTypeMap[keyof ServiceTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetServiceTypeResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetServiceTypeResponse): GetServiceTypeResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetServiceTypeResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetServiceTypeResponse;
  static deserializeBinaryFromReader(message: GetServiceTypeResponse, reader: jspb.BinaryReader): GetServiceTypeResponse;
}

export namespace GetServiceTypeResponse {
  export type AsObject = {
    serviceType: ServiceTypeMap[keyof ServiceTypeMap],
  }
}

export class GetInstanceRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetInstanceRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetInstanceRequest): GetInstanceRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetInstanceRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetInstanceRequest;
  static deserializeBinaryFromReader(message: GetInstanceRequest, reader: jspb.BinaryReader): GetInstanceRequest;
}

export namespace GetInstanceRequest {
  export type AsObject = {
  }
}

export class GetInstanceResponse extends jspb.Message {
  getInstanceId(): string;
  setInstanceId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetInstanceResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetInstanceResponse): GetInstanceResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetInstanceResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetInstanceResponse;
  static deserializeBinaryFromReader(message: GetInstanceResponse, reader: jspb.BinaryReader): GetInstanceResponse;
}

export namespace GetInstanceResponse {
  export type AsObject = {
    instanceId: string,
  }
}

export class StartFundsChangeRequest extends jspb.Message {
  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): Amount | undefined;
  setAmount(value?: Amount): void;

  getPromissory(): string;
  setPromissory(value: string): void;

  getUserReference(): string;
  setUserReference(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StartFundsChangeRequest.AsObject;
  static toObject(includeInstance: boolean, msg: StartFundsChangeRequest): StartFundsChangeRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StartFundsChangeRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StartFundsChangeRequest;
  static deserializeBinaryFromReader(message: StartFundsChangeRequest, reader: jspb.BinaryReader): StartFundsChangeRequest;
}

export namespace StartFundsChangeRequest {
  export type AsObject = {
    amount?: Amount.AsObject,
    promissory: string,
    userReference: string,
  }
}

export class StartFundsChangeResponse extends jspb.Message {
  getUetr(): string;
  setUetr(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StartFundsChangeResponse.AsObject;
  static toObject(includeInstance: boolean, msg: StartFundsChangeResponse): StartFundsChangeResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StartFundsChangeResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StartFundsChangeResponse;
  static deserializeBinaryFromReader(message: StartFundsChangeResponse, reader: jspb.BinaryReader): StartFundsChangeResponse;
}

export namespace StartFundsChangeResponse {
  export type AsObject = {
    uetr: string,
  }
}

export class FilterItem extends jspb.Message {
  getField(): string;
  setField(value: string): void;

  getOperator(): FilterItem.FilterOperatorMap[keyof FilterItem.FilterOperatorMap];
  setOperator(value: FilterItem.FilterOperatorMap[keyof FilterItem.FilterOperatorMap]): void;

  hasStrValue(): boolean;
  clearStrValue(): void;
  getStrValue(): string;
  setStrValue(value: string): void;

  hasIntValue(): boolean;
  clearIntValue(): void;
  getIntValue(): number;
  setIntValue(value: number): void;

  hasBoolValue(): boolean;
  clearBoolValue(): void;
  getBoolValue(): boolean;
  setBoolValue(value: boolean): void;

  hasRfc3339DatetimeValue(): boolean;
  clearRfc3339DatetimeValue(): void;
  getRfc3339DatetimeValue(): string;
  setRfc3339DatetimeValue(value: string): void;

  hasUuidValue(): boolean;
  clearUuidValue(): void;
  getUuidValue(): string;
  setUuidValue(value: string): void;

  getValueCase(): FilterItem.ValueCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FilterItem.AsObject;
  static toObject(includeInstance: boolean, msg: FilterItem): FilterItem.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FilterItem, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FilterItem;
  static deserializeBinaryFromReader(message: FilterItem, reader: jspb.BinaryReader): FilterItem;
}

export namespace FilterItem {
  export type AsObject = {
    field: string,
    operator: FilterItem.FilterOperatorMap[keyof FilterItem.FilterOperatorMap],
    strValue: string,
    intValue: number,
    boolValue: boolean,
    rfc3339DatetimeValue: string,
    uuidValue: string,
  }

  export interface FilterOperatorMap {
    FILTER_OPERATOR_UNSPECIFIED: 0;
    FILTER_OPERATOR_EQ: 1;
    FILTER_OPERATOR_NE: 2;
    FILTER_OPERATOR_GT: 3;
    FILTER_OPERATOR_GTE: 4;
    FILTER_OPERATOR_LT: 5;
    FILTER_OPERATOR_LTE: 6;
    FILTER_OPERATOR_IN: 7;
    FILTER_OPERATOR_NOT_IN: 8;
  }

  export const FilterOperator: FilterOperatorMap;

  export enum ValueCase {
    VALUE_NOT_SET = 0,
    STR_VALUE = 3,
    INT_VALUE = 4,
    BOOL_VALUE = 5,
    RFC3339_DATETIME_VALUE = 6,
    UUID_VALUE = 7,
  }
}

export class Filter extends jspb.Message {
  clearFiltersList(): void;
  getFiltersList(): Array<FilterItem>;
  setFiltersList(value: Array<FilterItem>): void;
  addFilters(value?: FilterItem, index?: number): FilterItem;

  getOperator(): LogicalOperatorMap[keyof LogicalOperatorMap];
  setOperator(value: LogicalOperatorMap[keyof LogicalOperatorMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Filter.AsObject;
  static toObject(includeInstance: boolean, msg: Filter): Filter.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Filter, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Filter;
  static deserializeBinaryFromReader(message: Filter, reader: jspb.BinaryReader): Filter;
}

export namespace Filter {
  export type AsObject = {
    filtersList: Array<FilterItem.AsObject>,
    operator: LogicalOperatorMap[keyof LogicalOperatorMap],
  }
}

export class SortItem extends jspb.Message {
  getField(): string;
  setField(value: string): void;

  getDirection(): SortDirectionMap[keyof SortDirectionMap];
  setDirection(value: SortDirectionMap[keyof SortDirectionMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SortItem.AsObject;
  static toObject(includeInstance: boolean, msg: SortItem): SortItem.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SortItem, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SortItem;
  static deserializeBinaryFromReader(message: SortItem, reader: jspb.BinaryReader): SortItem;
}

export namespace SortItem {
  export type AsObject = {
    field: string,
    direction: SortDirectionMap[keyof SortDirectionMap],
  }
}

export class SortBy extends jspb.Message {
  clearItemsList(): void;
  getItemsList(): Array<SortItem>;
  setItemsList(value: Array<SortItem>): void;
  addItems(value?: SortItem, index?: number): SortItem;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SortBy.AsObject;
  static toObject(includeInstance: boolean, msg: SortBy): SortBy.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SortBy, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SortBy;
  static deserializeBinaryFromReader(message: SortBy, reader: jspb.BinaryReader): SortBy;
}

export namespace SortBy {
  export type AsObject = {
    itemsList: Array<SortItem.AsObject>,
  }
}

export class AssetAuthority extends jspb.Message {
  getVerifier(): string;
  setVerifier(value: string): void;

  getUrl(): string;
  setUrl(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AssetAuthority.AsObject;
  static toObject(includeInstance: boolean, msg: AssetAuthority): AssetAuthority.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AssetAuthority, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AssetAuthority;
  static deserializeBinaryFromReader(message: AssetAuthority, reader: jspb.BinaryReader): AssetAuthority;
}

export namespace AssetAuthority {
  export type AsObject = {
    verifier: string,
    url: string,
  }
}

export class AssetDenomination extends jspb.Message {
  clearDenominationsList(): void;
  getDenominationsList(): Array<number>;
  setDenominationsList(value: Array<number>): void;
  addDenominations(value: number, index?: number): number;

  getPrecision(): number;
  setPrecision(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AssetDenomination.AsObject;
  static toObject(includeInstance: boolean, msg: AssetDenomination): AssetDenomination.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AssetDenomination, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AssetDenomination;
  static deserializeBinaryFromReader(message: AssetDenomination, reader: jspb.BinaryReader): AssetDenomination;
}

export namespace AssetDenomination {
  export type AsObject = {
    denominationsList: Array<number>,
    precision: number,
  }
}

export interface ServiceTypeMap {
  UNKNOWNSERVICE: 0;
  GATEWAY: 1;
  NOTARY: 2;
  AUTHORITY: 3;
  TREASURY: 4;
  EMISSARY: 5;
  SHARED: 6;
  IDENTITY: 7;
  VAULT: 8;
  CUSTODIALWALLET: 9;
  ISSUER: 10;
  OVERLOAD: 11;
  FAUCET: 12;
  TRANSACTIONMANAGER: 13;
}

export const ServiceType: ServiceTypeMap;

export interface SignatureSystemMap {
  SIGNATURE_SYSTEM_UNSPECIFIED: 0;
  SIGNATURE_SYSTEM_ED25519: 1;
  SIGNATURE_SYSTEM_SECP256K1: 2;
}

export const SignatureSystem: SignatureSystemMap;

export interface LogicalOperatorMap {
  LOGICAL_OPERATOR_UNSPECIFIED: 0;
  LOGICAL_OPERATOR_AND: 1;
  LOGICAL_OPERATOR_OR: 2;
}

export const LogicalOperator: LogicalOperatorMap;

export interface SortDirectionMap {
  SORT_DIRECTION_UNSPECIFIED: 0;
  SORT_DIRECTION_ASCENDING: 1;
  SORT_DIRECTION_DESCENDING: 2;
}

export const SortDirection: SortDirectionMap;

