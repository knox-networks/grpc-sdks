/* eslint-disable */
/*Generated by GenDocu.com*/
// package: common
// file: common/v1/packet.proto

import * as jspb from "google-protobuf";
import * as common_v1_common_pb from "../../common/v1/common_pb";

export class Packet extends jspb.Message {
  getPacketType(): PacketTypeMap[keyof PacketTypeMap];
  setPacketType(value: PacketTypeMap[keyof PacketTypeMap]): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  getChannel(): string;
  setChannel(value: string): void;

  hasSender(): boolean;
  clearSender(): void;
  getSender(): common_v1_common_pb.DynamicVerifier | undefined;
  setSender(value?: common_v1_common_pb.DynamicVerifier): void;

  hasRecipient(): boolean;
  clearRecipient(): void;
  getRecipient(): common_v1_common_pb.DynamicVerifier | undefined;
  setRecipient(value?: common_v1_common_pb.DynamicVerifier): void;

  getNonce(): Uint8Array | string;
  getNonce_asU8(): Uint8Array;
  getNonce_asB64(): string;
  setNonce(value: Uint8Array | string): void;

  hasTransactionHeader(): boolean;
  clearTransactionHeader(): void;
  getTransactionHeader(): TransactionHeader | undefined;
  setTransactionHeader(value?: TransactionHeader): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Packet.AsObject;
  static toObject(includeInstance: boolean, msg: Packet): Packet.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Packet, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Packet;
  static deserializeBinaryFromReader(message: Packet, reader: jspb.BinaryReader): Packet;
}

export namespace Packet {
  export type AsObject = {
    packetType: PacketTypeMap[keyof PacketTypeMap],
    data: Uint8Array | string,
    channel: string,
    sender?: common_v1_common_pb.DynamicVerifier.AsObject,
    recipient?: common_v1_common_pb.DynamicVerifier.AsObject,
    nonce: Uint8Array | string,
    transactionHeader?: TransactionHeader.AsObject,
  }
}

export class TransactionHeader extends jspb.Message {
  hasStarter(): boolean;
  clearStarter(): void;
  getStarter(): common_v1_common_pb.DynamicVerifier | undefined;
  setStarter(value?: common_v1_common_pb.DynamicVerifier): void;

  hasResponder(): boolean;
  clearResponder(): void;
  getResponder(): common_v1_common_pb.DynamicVerifier | undefined;
  setResponder(value?: common_v1_common_pb.DynamicVerifier): void;

  getUetr(): string;
  setUetr(value: string): void;

  getTimestamp(): number;
  setTimestamp(value: number): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  getUserReference(): string;
  setUserReference(value: string): void;

  clearRelatedUetrsList(): void;
  getRelatedUetrsList(): Array<string>;
  setRelatedUetrsList(value: Array<string>): void;
  addRelatedUetrs(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TransactionHeader.AsObject;
  static toObject(includeInstance: boolean, msg: TransactionHeader): TransactionHeader.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TransactionHeader, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TransactionHeader;
  static deserializeBinaryFromReader(message: TransactionHeader, reader: jspb.BinaryReader): TransactionHeader;
}

export namespace TransactionHeader {
  export type AsObject = {
    starter?: common_v1_common_pb.DynamicVerifier.AsObject,
    responder?: common_v1_common_pb.DynamicVerifier.AsObject,
    uetr: string,
    timestamp: number,
    signature: Uint8Array | string,
    userReference: string,
    relatedUetrsList: Array<string>,
  }
}

export class LockedPromissory extends jspb.Message {
  getPromissory(): Uint8Array | string;
  getPromissory_asU8(): Uint8Array;
  getPromissory_asB64(): string;
  setPromissory(value: Uint8Array | string): void;

  getLockId(): string;
  setLockId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LockedPromissory.AsObject;
  static toObject(includeInstance: boolean, msg: LockedPromissory): LockedPromissory.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LockedPromissory, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LockedPromissory;
  static deserializeBinaryFromReader(message: LockedPromissory, reader: jspb.BinaryReader): LockedPromissory;
}

export namespace LockedPromissory {
  export type AsObject = {
    promissory: Uint8Array | string,
    lockId: string,
  }
}

export class LockPromissoryBatchData extends jspb.Message {
  getLockId(): string;
  setLockId(value: string): void;

  clearPromissoryBatchList(): void;
  getPromissoryBatchList(): Array<Uint8Array | string>;
  getPromissoryBatchList_asU8(): Array<Uint8Array>;
  getPromissoryBatchList_asB64(): Array<string>;
  setPromissoryBatchList(value: Array<Uint8Array | string>): void;
  addPromissoryBatch(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LockPromissoryBatchData.AsObject;
  static toObject(includeInstance: boolean, msg: LockPromissoryBatchData): LockPromissoryBatchData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LockPromissoryBatchData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LockPromissoryBatchData;
  static deserializeBinaryFromReader(message: LockPromissoryBatchData, reader: jspb.BinaryReader): LockPromissoryBatchData;
}

export namespace LockPromissoryBatchData {
  export type AsObject = {
    lockId: string,
    promissoryBatchList: Array<Uint8Array | string>,
  }
}

export class LockPromissoryBatchAckData extends jspb.Message {
  getLockId(): string;
  setLockId(value: string): void;

  clearAcksList(): void;
  getAcksList(): Array<LockedPromissoryAck>;
  setAcksList(value: Array<LockedPromissoryAck>): void;
  addAcks(value?: LockedPromissoryAck, index?: number): LockedPromissoryAck;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LockPromissoryBatchAckData.AsObject;
  static toObject(includeInstance: boolean, msg: LockPromissoryBatchAckData): LockPromissoryBatchAckData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LockPromissoryBatchAckData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LockPromissoryBatchAckData;
  static deserializeBinaryFromReader(message: LockPromissoryBatchAckData, reader: jspb.BinaryReader): LockPromissoryBatchAckData;
}

export namespace LockPromissoryBatchAckData {
  export type AsObject = {
    lockId: string,
    acksList: Array<LockedPromissoryAck.AsObject>,
  }
}

export class LockedPromissoryAck extends jspb.Message {
  getPreviousOwner(): string;
  setPreviousOwner(value: string): void;

  getOwner(): string;
  setOwner(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): common_v1_common_pb.Amount | undefined;
  setAmount(value?: common_v1_common_pb.Amount): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): LockedPromissoryAck.AsObject;
  static toObject(includeInstance: boolean, msg: LockedPromissoryAck): LockedPromissoryAck.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: LockedPromissoryAck, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): LockedPromissoryAck;
  static deserializeBinaryFromReader(message: LockedPromissoryAck, reader: jspb.BinaryReader): LockedPromissoryAck;
}

export namespace LockedPromissoryAck {
  export type AsObject = {
    previousOwner: string,
    owner: string,
    amount?: common_v1_common_pb.Amount.AsObject,
  }
}

export class BatchedPromissory extends jspb.Message {
  clearPromissoryBatchList(): void;
  getPromissoryBatchList(): Array<Uint8Array | string>;
  getPromissoryBatchList_asU8(): Array<Uint8Array>;
  getPromissoryBatchList_asB64(): Array<string>;
  setPromissoryBatchList(value: Array<Uint8Array | string>): void;
  addPromissoryBatch(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BatchedPromissory.AsObject;
  static toObject(includeInstance: boolean, msg: BatchedPromissory): BatchedPromissory.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BatchedPromissory, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BatchedPromissory;
  static deserializeBinaryFromReader(message: BatchedPromissory, reader: jspb.BinaryReader): BatchedPromissory;
}

export namespace BatchedPromissory {
  export type AsObject = {
    promissoryBatchList: Array<Uint8Array | string>,
  }
}

export class SimplePaymentRequest extends jspb.Message {
  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): common_v1_common_pb.Amount | undefined;
  setAmount(value?: common_v1_common_pb.Amount): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SimplePaymentRequest.AsObject;
  static toObject(includeInstance: boolean, msg: SimplePaymentRequest): SimplePaymentRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SimplePaymentRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SimplePaymentRequest;
  static deserializeBinaryFromReader(message: SimplePaymentRequest, reader: jspb.BinaryReader): SimplePaymentRequest;
}

export namespace SimplePaymentRequest {
  export type AsObject = {
    amount?: common_v1_common_pb.Amount.AsObject,
  }
}

export class SimplePaymentAck extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SimplePaymentAck.AsObject;
  static toObject(includeInstance: boolean, msg: SimplePaymentAck): SimplePaymentAck.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SimplePaymentAck, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SimplePaymentAck;
  static deserializeBinaryFromReader(message: SimplePaymentAck, reader: jspb.BinaryReader): SimplePaymentAck;
}

export namespace SimplePaymentAck {
  export type AsObject = {
  }
}

export class SimplePaymentNack extends jspb.Message {
  getRejectionReason(): SimplePaymentNack.RejectionReasonMap[keyof SimplePaymentNack.RejectionReasonMap];
  setRejectionReason(value: SimplePaymentNack.RejectionReasonMap[keyof SimplePaymentNack.RejectionReasonMap]): void;

  getOther(): string;
  setOther(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SimplePaymentNack.AsObject;
  static toObject(includeInstance: boolean, msg: SimplePaymentNack): SimplePaymentNack.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SimplePaymentNack, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SimplePaymentNack;
  static deserializeBinaryFromReader(message: SimplePaymentNack, reader: jspb.BinaryReader): SimplePaymentNack;
}

export namespace SimplePaymentNack {
  export type AsObject = {
    rejectionReason: SimplePaymentNack.RejectionReasonMap[keyof SimplePaymentNack.RejectionReasonMap],
    other: string,
  }

  export interface RejectionReasonMap {
    REASON_UNKNOWN: 0;
    REASON_OTHER: 1;
    REASON_AMOUNT_EMPTY: 2;
    REASON_CHANGE_REQUEST_AMOUNT_MISMATCH: 3;
  }

  export const RejectionReason: RejectionReasonMap;
}

export class SimplePaymentResponse extends jspb.Message {
  hasReceivedAmount(): boolean;
  clearReceivedAmount(): void;
  getReceivedAmount(): common_v1_common_pb.Amount | undefined;
  setReceivedAmount(value?: common_v1_common_pb.Amount): void;

  clearReceivedPromissoriesList(): void;
  getReceivedPromissoriesList(): Array<string>;
  setReceivedPromissoriesList(value: Array<string>): void;
  addReceivedPromissories(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SimplePaymentResponse.AsObject;
  static toObject(includeInstance: boolean, msg: SimplePaymentResponse): SimplePaymentResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SimplePaymentResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SimplePaymentResponse;
  static deserializeBinaryFromReader(message: SimplePaymentResponse, reader: jspb.BinaryReader): SimplePaymentResponse;
}

export namespace SimplePaymentResponse {
  export type AsObject = {
    receivedAmount?: common_v1_common_pb.Amount.AsObject,
    receivedPromissoriesList: Array<string>,
  }
}

export class FundsChangeRequest extends jspb.Message {
  hasGrossAmount(): boolean;
  clearGrossAmount(): void;
  getGrossAmount(): common_v1_common_pb.Amount | undefined;
  setGrossAmount(value?: common_v1_common_pb.Amount): void;

  hasExactAmount(): boolean;
  clearExactAmount(): void;
  getExactAmount(): common_v1_common_pb.Amount | undefined;
  setExactAmount(value?: common_v1_common_pb.Amount): void;

  hasFees(): boolean;
  clearFees(): void;
  getFees(): common_v1_common_pb.Amount | undefined;
  setFees(value?: common_v1_common_pb.Amount): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FundsChangeRequest.AsObject;
  static toObject(includeInstance: boolean, msg: FundsChangeRequest): FundsChangeRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FundsChangeRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FundsChangeRequest;
  static deserializeBinaryFromReader(message: FundsChangeRequest, reader: jspb.BinaryReader): FundsChangeRequest;
}

export namespace FundsChangeRequest {
  export type AsObject = {
    grossAmount?: common_v1_common_pb.Amount.AsObject,
    exactAmount?: common_v1_common_pb.Amount.AsObject,
    fees?: common_v1_common_pb.Amount.AsObject,
  }
}

export class FundsChangeAck extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FundsChangeAck.AsObject;
  static toObject(includeInstance: boolean, msg: FundsChangeAck): FundsChangeAck.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FundsChangeAck, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FundsChangeAck;
  static deserializeBinaryFromReader(message: FundsChangeAck, reader: jspb.BinaryReader): FundsChangeAck;
}

export namespace FundsChangeAck {
  export type AsObject = {
  }
}

export class FundsChangeNack extends jspb.Message {
  getRejectionReason(): FundsChangeNack.RejectionReasonMap[keyof FundsChangeNack.RejectionReasonMap];
  setRejectionReason(value: FundsChangeNack.RejectionReasonMap[keyof FundsChangeNack.RejectionReasonMap]): void;

  getOther(): string;
  setOther(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FundsChangeNack.AsObject;
  static toObject(includeInstance: boolean, msg: FundsChangeNack): FundsChangeNack.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FundsChangeNack, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FundsChangeNack;
  static deserializeBinaryFromReader(message: FundsChangeNack, reader: jspb.BinaryReader): FundsChangeNack;
}

export namespace FundsChangeNack {
  export type AsObject = {
    rejectionReason: FundsChangeNack.RejectionReasonMap[keyof FundsChangeNack.RejectionReasonMap],
    other: string,
  }

  export interface RejectionReasonMap {
    REASON_UNKNOWN: 0;
    REASON_OTHER: 1;
    REASON_AMOUNT_EMPTY: 2;
    REASON_AMOUNTS_MISMATCH: 3;
  }

  export const RejectionReason: RejectionReasonMap;
}

export class CancelTransaction extends jspb.Message {
  getRejectionReason(): CancelTransaction.RejectionReasonMap[keyof CancelTransaction.RejectionReasonMap];
  setRejectionReason(value: CancelTransaction.RejectionReasonMap[keyof CancelTransaction.RejectionReasonMap]): void;

  getOther(): string;
  setOther(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CancelTransaction.AsObject;
  static toObject(includeInstance: boolean, msg: CancelTransaction): CancelTransaction.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CancelTransaction, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CancelTransaction;
  static deserializeBinaryFromReader(message: CancelTransaction, reader: jspb.BinaryReader): CancelTransaction;
}

export namespace CancelTransaction {
  export type AsObject = {
    rejectionReason: CancelTransaction.RejectionReasonMap[keyof CancelTransaction.RejectionReasonMap],
    other: string,
  }

  export interface RejectionReasonMap {
    REASON_UNKNOWN: 0;
    REASON_OTHER: 1;
    REASON_MISMATCHED_TRANSACTIONS: 2;
  }

  export const RejectionReason: RejectionReasonMap;
}

export class Commitment extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getRecipient(): string;
  setRecipient(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): common_v1_common_pb.Amount | undefined;
  setAmount(value?: common_v1_common_pb.Amount): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Commitment.AsObject;
  static toObject(includeInstance: boolean, msg: Commitment): Commitment.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Commitment, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Commitment;
  static deserializeBinaryFromReader(message: Commitment, reader: jspb.BinaryReader): Commitment;
}

export namespace Commitment {
  export type AsObject = {
    sender: string,
    recipient: string,
    amount?: common_v1_common_pb.Amount.AsObject,
  }
}

export class TimeoutCondition extends jspb.Message {
  getTimeout(): number;
  setTimeout(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TimeoutCondition.AsObject;
  static toObject(includeInstance: boolean, msg: TimeoutCondition): TimeoutCondition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TimeoutCondition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TimeoutCondition;
  static deserializeBinaryFromReader(message: TimeoutCondition, reader: jspb.BinaryReader): TimeoutCondition;
}

export namespace TimeoutCondition {
  export type AsObject = {
    timeout: number,
  }
}

export class HashCondition extends jspb.Message {
  getPresenter(): string;
  setPresenter(value: string): void;

  getHash(): Uint8Array | string;
  getHash_asU8(): Uint8Array;
  getHash_asB64(): string;
  setHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): HashCondition.AsObject;
  static toObject(includeInstance: boolean, msg: HashCondition): HashCondition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: HashCondition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): HashCondition;
  static deserializeBinaryFromReader(message: HashCondition, reader: jspb.BinaryReader): HashCondition;
}

export namespace HashCondition {
  export type AsObject = {
    presenter: string,
    hash: Uint8Array | string,
  }
}

export class Condition extends jspb.Message {
  hasTimeout(): boolean;
  clearTimeout(): void;
  getTimeout(): TimeoutCondition | undefined;
  setTimeout(value?: TimeoutCondition): void;

  hasHash(): boolean;
  clearHash(): void;
  getHash(): HashCondition | undefined;
  setHash(value?: HashCondition): void;

  getConditionCase(): Condition.ConditionCase;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Condition.AsObject;
  static toObject(includeInstance: boolean, msg: Condition): Condition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Condition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Condition;
  static deserializeBinaryFromReader(message: Condition, reader: jspb.BinaryReader): Condition;
}

export namespace Condition {
  export type AsObject = {
    timeout?: TimeoutCondition.AsObject,
    hash?: HashCondition.AsObject,
  }

  export enum ConditionCase {
    CONDITION_NOT_SET = 0,
    TIMEOUT = 1,
    HASH = 2,
  }
}

export class Contract extends jspb.Message {
  getUrn(): string;
  setUrn(value: string): void;

  getId(): string;
  setId(value: string): void;

  clearCommitmentsList(): void;
  getCommitmentsList(): Array<Commitment>;
  setCommitmentsList(value: Array<Commitment>): void;
  addCommitments(value?: Commitment, index?: number): Commitment;

  clearConditionsList(): void;
  getConditionsList(): Array<Condition>;
  setConditionsList(value: Array<Condition>): void;
  addConditions(value?: Condition, index?: number): Condition;

  getSignatoriesMap(): jspb.Map<string, Uint8Array | string>;
  clearSignatoriesMap(): void;
  getMemo(): string;
  setMemo(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Contract.AsObject;
  static toObject(includeInstance: boolean, msg: Contract): Contract.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Contract, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Contract;
  static deserializeBinaryFromReader(message: Contract, reader: jspb.BinaryReader): Contract;
}

export namespace Contract {
  export type AsObject = {
    urn: string,
    id: string,
    commitmentsList: Array<Commitment.AsObject>,
    conditionsList: Array<Condition.AsObject>,
    signatoriesMap: Array<[string, Uint8Array | string]>,
    memo: string,
  }
}

export class Secret extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getSecret(): string;
  setSecret(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Secret.AsObject;
  static toObject(includeInstance: boolean, msg: Secret): Secret.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Secret, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Secret;
  static deserializeBinaryFromReader(message: Secret, reader: jspb.BinaryReader): Secret;
}

export namespace Secret {
  export type AsObject = {
    id: string,
    secret: string,
  }
}

export interface PacketTypeMap {
  UNKNOWN: 0;
  UNSUPPORTED: 1;
  AUTHENTICATE: 2;
  RETURNTOSENDER: 3;
  TERMINATESTREAM: 4;
  KEEPALIVE: 5;
  ACKNOWLEDGEMENT: 6;
  AUTHENTICATEREQUEST: 7;
  AUTHENTICATERESPONSE: 8;
  ADDASSOCIATEDCONNECTION: 9;
  DROPASSOCIATEDCONNECTION: 10;
  PROMISSORY: 100;
  AUTHORIZEPROMISSORY: 101;
  AUTHORIZEANDFORWARDPROMISSORY: 102;
  ARCHIVEPROMISSORY: 103;
  PROMISSORYRECEIPT: 104;
  LOCKPROMISSORY: 105;
  LOCKPROMISSORYACK: 106;
  AUTHORIZELOCKEDPROMISSORIES: 107;
  AUTHORIZATIONSTATUS: 108;
  RETRIEVEASSETS: 109;
  PROMISSORYBATCH: 110;
  LOCKPROMISSORYBATCH: 111;
  LOCKPROMISSORYBATCHACK: 112;
  RETRIEVEASSETSBATCH: 113;
  ROLLBACKLOCKEDPROMISSORIES: 114;
  ROLLBACKLOCKEDPROMISSORIESACK: 115;
  AUTHORIZEANDFORWARDPROMISSORYBATCH: 116;
  VALIDATIONBLOCKBATCH: 117;
  AUTHORIZEDBLOCKBATCH: 118;
  IDENTITYREQUEST: 200;
  IDENTITYRESPONSE: 201;
  IDENTITYPROOF: 202;
  NOTARYNOTARIZEPROMISSORY: 300;
  NOTARYNOTARIZEANDFORWARDPROMISSORY: 301;
  EMISSARYCONNECTIONIDENTITY: 400;
  CONTRACTPROPOSAL: 500;
  CONTRACTACK: 501;
  CONTRACTSIGNATURE: 502;
  CONTRACTCOMPLETE: 503;
  REMITTANCEREQUEST: 700;
  REMITTANCERESPONSE: 701;
  SPREQUEST: 1000;
  SPACK: 1001;
  SPNACK: 1002;
  SPSTATUS: 1003;
  SPSTART: 1004;
  FCREQUEST: 1100;
  FCACK: 1101;
  FCNACK: 1102;
  CPREQUEST: 1300;
  CPACK: 1301;
  CPNACK: 1302;
  CPCONTRACT: 1303;
  CPCONTRACTACK: 1304;
  CPASSETSAUTHORIZED: 1305;
  CPCOMPLETE: 1306;
  REQUESTSECRET: 1308;
  PRESENTSECRET: 1309;
  CPASSETSRETURNED: 1310;
}

export const PacketType: PacketTypeMap;

export interface ContractTypeMap {
  CONTRACT_TYPE_UNSPECIFIED: 0;
  CONTRACT_TYPE_PAYMENT: 1;
  CONTRACT_TYPE_SWAP: 2;
  CONTRACT_TYPE_RELAY: 3;
  CONTRACT_TYPE_CUSTOM: 4;
}

export const ContractType: ContractTypeMap;

