// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: common/v1/packet.proto
// Protobuf C++ Version: 5.27.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fpacket_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fpacket_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common/v1/common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2fv1_2fpacket_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fv1_2fpacket_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2fv1_2fpacket_2eproto;
namespace common {
class AssociatedUetrConnection;
struct AssociatedUetrConnectionDefaultTypeInternal;
extern AssociatedUetrConnectionDefaultTypeInternal _AssociatedUetrConnection_default_instance_;
class BatchedPromissory;
struct BatchedPromissoryDefaultTypeInternal;
extern BatchedPromissoryDefaultTypeInternal _BatchedPromissory_default_instance_;
class CancelTransaction;
struct CancelTransactionDefaultTypeInternal;
extern CancelTransactionDefaultTypeInternal _CancelTransaction_default_instance_;
class Commitment;
struct CommitmentDefaultTypeInternal;
extern CommitmentDefaultTypeInternal _Commitment_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class Contract;
struct ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class Contract_SignatoriesEntry_DoNotUse;
struct Contract_SignatoriesEntry_DoNotUseDefaultTypeInternal;
extern Contract_SignatoriesEntry_DoNotUseDefaultTypeInternal _Contract_SignatoriesEntry_DoNotUse_default_instance_;
class FundsChangeAck;
struct FundsChangeAckDefaultTypeInternal;
extern FundsChangeAckDefaultTypeInternal _FundsChangeAck_default_instance_;
class FundsChangeNack;
struct FundsChangeNackDefaultTypeInternal;
extern FundsChangeNackDefaultTypeInternal _FundsChangeNack_default_instance_;
class FundsChangeRequest;
struct FundsChangeRequestDefaultTypeInternal;
extern FundsChangeRequestDefaultTypeInternal _FundsChangeRequest_default_instance_;
class HashCondition;
struct HashConditionDefaultTypeInternal;
extern HashConditionDefaultTypeInternal _HashCondition_default_instance_;
class MintCondition;
struct MintConditionDefaultTypeInternal;
extern MintConditionDefaultTypeInternal _MintCondition_default_instance_;
class Packet;
struct PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class RedeemCondition;
struct RedeemConditionDefaultTypeInternal;
extern RedeemConditionDefaultTypeInternal _RedeemCondition_default_instance_;
class SimplePaymentAck;
struct SimplePaymentAckDefaultTypeInternal;
extern SimplePaymentAckDefaultTypeInternal _SimplePaymentAck_default_instance_;
class SimplePaymentNack;
struct SimplePaymentNackDefaultTypeInternal;
extern SimplePaymentNackDefaultTypeInternal _SimplePaymentNack_default_instance_;
class SimplePaymentRequest;
struct SimplePaymentRequestDefaultTypeInternal;
extern SimplePaymentRequestDefaultTypeInternal _SimplePaymentRequest_default_instance_;
class SimplePaymentResponse;
struct SimplePaymentResponseDefaultTypeInternal;
extern SimplePaymentResponseDefaultTypeInternal _SimplePaymentResponse_default_instance_;
class TimeoutCondition;
struct TimeoutConditionDefaultTypeInternal;
extern TimeoutConditionDefaultTypeInternal _TimeoutCondition_default_instance_;
class TransactionHeader;
struct TransactionHeaderDefaultTypeInternal;
extern TransactionHeaderDefaultTypeInternal _TransactionHeader_default_instance_;
class TransactionHeader_MetadataEntry_DoNotUse;
struct TransactionHeader_MetadataEntry_DoNotUseDefaultTypeInternal;
extern TransactionHeader_MetadataEntry_DoNotUseDefaultTypeInternal _TransactionHeader_MetadataEntry_DoNotUse_default_instance_;
}  // namespace common
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace common {
enum SimplePaymentNack_RejectionReason : int {
  SimplePaymentNack_RejectionReason_REASON_UNKNOWN = 0,
  SimplePaymentNack_RejectionReason_REASON_OTHER = 1,
  SimplePaymentNack_RejectionReason_REASON_AMOUNT_EMPTY = 2,
  SimplePaymentNack_RejectionReason_REASON_CHANGE_REQUEST_AMOUNT_MISMATCH = 3,
  SimplePaymentNack_RejectionReason_SimplePaymentNack_RejectionReason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SimplePaymentNack_RejectionReason_SimplePaymentNack_RejectionReason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SimplePaymentNack_RejectionReason_IsValid(int value);
extern const uint32_t SimplePaymentNack_RejectionReason_internal_data_[];
constexpr SimplePaymentNack_RejectionReason SimplePaymentNack_RejectionReason_RejectionReason_MIN = static_cast<SimplePaymentNack_RejectionReason>(0);
constexpr SimplePaymentNack_RejectionReason SimplePaymentNack_RejectionReason_RejectionReason_MAX = static_cast<SimplePaymentNack_RejectionReason>(3);
constexpr int SimplePaymentNack_RejectionReason_RejectionReason_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SimplePaymentNack_RejectionReason_descriptor();
template <typename T>
const std::string& SimplePaymentNack_RejectionReason_Name(T value) {
  static_assert(std::is_same<T, SimplePaymentNack_RejectionReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RejectionReason_Name().");
  return SimplePaymentNack_RejectionReason_Name(static_cast<SimplePaymentNack_RejectionReason>(value));
}
template <>
inline const std::string& SimplePaymentNack_RejectionReason_Name(SimplePaymentNack_RejectionReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SimplePaymentNack_RejectionReason_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SimplePaymentNack_RejectionReason_Parse(absl::string_view name, SimplePaymentNack_RejectionReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SimplePaymentNack_RejectionReason>(
      SimplePaymentNack_RejectionReason_descriptor(), name, value);
}
enum FundsChangeNack_RejectionReason : int {
  FundsChangeNack_RejectionReason_REASON_UNKNOWN = 0,
  FundsChangeNack_RejectionReason_REASON_OTHER = 1,
  FundsChangeNack_RejectionReason_REASON_AMOUNT_EMPTY = 2,
  FundsChangeNack_RejectionReason_REASON_AMOUNTS_MISMATCH = 3,
  FundsChangeNack_RejectionReason_FundsChangeNack_RejectionReason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FundsChangeNack_RejectionReason_FundsChangeNack_RejectionReason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FundsChangeNack_RejectionReason_IsValid(int value);
extern const uint32_t FundsChangeNack_RejectionReason_internal_data_[];
constexpr FundsChangeNack_RejectionReason FundsChangeNack_RejectionReason_RejectionReason_MIN = static_cast<FundsChangeNack_RejectionReason>(0);
constexpr FundsChangeNack_RejectionReason FundsChangeNack_RejectionReason_RejectionReason_MAX = static_cast<FundsChangeNack_RejectionReason>(3);
constexpr int FundsChangeNack_RejectionReason_RejectionReason_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
FundsChangeNack_RejectionReason_descriptor();
template <typename T>
const std::string& FundsChangeNack_RejectionReason_Name(T value) {
  static_assert(std::is_same<T, FundsChangeNack_RejectionReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RejectionReason_Name().");
  return FundsChangeNack_RejectionReason_Name(static_cast<FundsChangeNack_RejectionReason>(value));
}
template <>
inline const std::string& FundsChangeNack_RejectionReason_Name(FundsChangeNack_RejectionReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FundsChangeNack_RejectionReason_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FundsChangeNack_RejectionReason_Parse(absl::string_view name, FundsChangeNack_RejectionReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FundsChangeNack_RejectionReason>(
      FundsChangeNack_RejectionReason_descriptor(), name, value);
}
enum CancelTransaction_RejectionReason : int {
  CancelTransaction_RejectionReason_REASON_UNKNOWN = 0,
  CancelTransaction_RejectionReason_REASON_OTHER = 1,
  CancelTransaction_RejectionReason_REASON_MISMATCHED_TRANSACTIONS = 2,
  CancelTransaction_RejectionReason_CancelTransaction_RejectionReason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CancelTransaction_RejectionReason_CancelTransaction_RejectionReason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CancelTransaction_RejectionReason_IsValid(int value);
extern const uint32_t CancelTransaction_RejectionReason_internal_data_[];
constexpr CancelTransaction_RejectionReason CancelTransaction_RejectionReason_RejectionReason_MIN = static_cast<CancelTransaction_RejectionReason>(0);
constexpr CancelTransaction_RejectionReason CancelTransaction_RejectionReason_RejectionReason_MAX = static_cast<CancelTransaction_RejectionReason>(2);
constexpr int CancelTransaction_RejectionReason_RejectionReason_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CancelTransaction_RejectionReason_descriptor();
template <typename T>
const std::string& CancelTransaction_RejectionReason_Name(T value) {
  static_assert(std::is_same<T, CancelTransaction_RejectionReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RejectionReason_Name().");
  return CancelTransaction_RejectionReason_Name(static_cast<CancelTransaction_RejectionReason>(value));
}
template <>
inline const std::string& CancelTransaction_RejectionReason_Name(CancelTransaction_RejectionReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CancelTransaction_RejectionReason_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CancelTransaction_RejectionReason_Parse(absl::string_view name, CancelTransaction_RejectionReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CancelTransaction_RejectionReason>(
      CancelTransaction_RejectionReason_descriptor(), name, value);
}
enum PacketType : int {
  Unknown = 0,
  Unsupported = 1,
  Authenticate = 2,
  ConnectionAuthenticated = 7,
  ReturnToSender = 3,
  TerminateStream = 4,
  KeepAlive = 5,
  Acknowledgement = 6,
  AddAssociatedConnection = 9,
  DropAssociatedConnection = 10,
  AssociatedConnectionAdded = 11,
  AssociatedConnectionDropped = 12,
  Report = 50,
  Promissory = 100,
  AuthorizePromissory = 101,
  AuthorizeAndForwardPromissory = 102,
  ArchivePromissory = 103,
  PromissoryReceipt = 104,
  AuthorizationStatus = 108,
  RetrieveAssets = 109,
  PromissoryBatch = 110,
  LockPromissoryBatch = 111,
  LockPromissoryBatchAck = 112,
  RetrieveAssetsBatch = 113,
  AuthorizeAndForwardPromissoryBatch = 116,
  ValidationBlockBatch = 117,
  AuthorizedBlockBatch = 118,
  MintPromissory = 119,
  FreshPromissoryBatch = 120,
  MintedPromissoryBatch = 121,
  RedeemValidationBlockBatch = 122,
  IdentityRequest = 200,
  IdentityResponse = 201,
  IdentityProof = 202,
  AuthorizationFailed = 300,
  EmissaryConnectionIdentity = 400,
  ContractProposal = 500,
  ContractProposalAck = 501,
  ContractProposalNack = 502,
  ContractSignature = 503,
  ContractComplete = 504,
  RecoveryData = 600,
  RemittanceRequest = 700,
  RemittanceResponse = 701,
  TxnContract = 1303,
  TxnContractAck = 1304,
  TxnAssetsAuthorized = 1305,
  TxnSecretRequest = 1308,
  TxnSecretPresent = 1309,
  TxnAssetsReturned = 1310,
  TxnRecover = 1311,
  PacketType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PacketType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PacketType_IsValid(int value);
extern const uint32_t PacketType_internal_data_[];
constexpr PacketType PacketType_MIN = static_cast<PacketType>(0);
constexpr PacketType PacketType_MAX = static_cast<PacketType>(1311);
constexpr int PacketType_ARRAYSIZE = 1311 + 1;
const ::google::protobuf::EnumDescriptor*
PacketType_descriptor();
template <typename T>
const std::string& PacketType_Name(T value) {
  static_assert(std::is_same<T, PacketType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PacketType_Name().");
  return ::google::protobuf::internal::NameOfEnum(PacketType_descriptor(), value);
}
inline bool PacketType_Parse(absl::string_view name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
      PacketType_descriptor(), name, value);
}
enum HashAlgorithm : int {
  SHA256 = 0,
  SHA512 = 1,
  SHA3_256 = 2,
  SHA3_512 = 3,
  KECCAK256 = 4,
  KECCAK512 = 5,
  HashAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HashAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HashAlgorithm_IsValid(int value);
extern const uint32_t HashAlgorithm_internal_data_[];
constexpr HashAlgorithm HashAlgorithm_MIN = static_cast<HashAlgorithm>(0);
constexpr HashAlgorithm HashAlgorithm_MAX = static_cast<HashAlgorithm>(5);
constexpr int HashAlgorithm_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
HashAlgorithm_descriptor();
template <typename T>
const std::string& HashAlgorithm_Name(T value) {
  static_assert(std::is_same<T, HashAlgorithm>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HashAlgorithm_Name().");
  return HashAlgorithm_Name(static_cast<HashAlgorithm>(value));
}
template <>
inline const std::string& HashAlgorithm_Name(HashAlgorithm value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HashAlgorithm_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool HashAlgorithm_Parse(absl::string_view name, HashAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashAlgorithm>(
      HashAlgorithm_descriptor(), name, value);
}
enum ContractType : int {
  CONTRACT_TYPE_UNSPECIFIED = 0,
  CONTRACT_TYPE_PAYMENT = 1,
  CONTRACT_TYPE_SWAP = 2,
  CONTRACT_TYPE_RELAY = 3,
  CONTRACT_TYPE_CUSTOM = 4,
  CONTRACT_TYPE_MINT = 5,
  CONTRACT_TYPE_REDEEM = 6,
  ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractType_IsValid(int value);
extern const uint32_t ContractType_internal_data_[];
constexpr ContractType ContractType_MIN = static_cast<ContractType>(0);
constexpr ContractType ContractType_MAX = static_cast<ContractType>(6);
constexpr int ContractType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ContractType_descriptor();
template <typename T>
const std::string& ContractType_Name(T value) {
  static_assert(std::is_same<T, ContractType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractType_Name().");
  return ContractType_Name(static_cast<ContractType>(value));
}
template <>
inline const std::string& ContractType_Name(ContractType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ContractType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ContractType_Parse(absl::string_view name, ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractType>(
      ContractType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TransactionHeader_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          TransactionHeader_MetadataEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      TransactionHeader_MetadataEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TransactionHeader_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TransactionHeader_MetadataEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TransactionHeader_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TransactionHeader_MetadataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TransactionHeader_MetadataEntry_DoNotUse*>(
        &_TransactionHeader_MetadataEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class TimeoutCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.TimeoutCondition) */ {
 public:
  inline TimeoutCondition() : TimeoutCondition(nullptr) {}
  ~TimeoutCondition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimeoutCondition(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimeoutCondition(const TimeoutCondition& from) : TimeoutCondition(nullptr, from) {}
  inline TimeoutCondition(TimeoutCondition&& from) noexcept
      : TimeoutCondition(nullptr, std::move(from)) {}
  inline TimeoutCondition& operator=(const TimeoutCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeoutCondition& operator=(TimeoutCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeoutCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeoutCondition* internal_default_instance() {
    return reinterpret_cast<const TimeoutCondition*>(
        &_TimeoutCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TimeoutCondition& a, TimeoutCondition& b) { a.Swap(&b); }
  inline void Swap(TimeoutCondition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeoutCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeoutCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TimeoutCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeoutCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimeoutCondition& from) { TimeoutCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeoutCondition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.TimeoutCondition"; }

 protected:
  explicit TimeoutCondition(::google::protobuf::Arena* arena);
  TimeoutCondition(::google::protobuf::Arena* arena, const TimeoutCondition& from);
  TimeoutCondition(::google::protobuf::Arena* arena, TimeoutCondition&& from) noexcept
      : TimeoutCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeoutFieldNumber = 1,
  };
  // uint64 timeout = 1;
  void clear_timeout() ;
  ::uint64_t timeout() const;
  void set_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_timeout() const;
  void _internal_set_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:common.TimeoutCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TimeoutCondition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimeoutCondition& from_msg);
    ::uint64_t timeout_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class SimplePaymentNack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.SimplePaymentNack) */ {
 public:
  inline SimplePaymentNack() : SimplePaymentNack(nullptr) {}
  ~SimplePaymentNack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimplePaymentNack(
      ::google::protobuf::internal::ConstantInitialized);

  inline SimplePaymentNack(const SimplePaymentNack& from) : SimplePaymentNack(nullptr, from) {}
  inline SimplePaymentNack(SimplePaymentNack&& from) noexcept
      : SimplePaymentNack(nullptr, std::move(from)) {}
  inline SimplePaymentNack& operator=(const SimplePaymentNack& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimplePaymentNack& operator=(SimplePaymentNack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimplePaymentNack& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimplePaymentNack* internal_default_instance() {
    return reinterpret_cast<const SimplePaymentNack*>(
        &_SimplePaymentNack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SimplePaymentNack& a, SimplePaymentNack& b) { a.Swap(&b); }
  inline void Swap(SimplePaymentNack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimplePaymentNack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimplePaymentNack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SimplePaymentNack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimplePaymentNack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimplePaymentNack& from) { SimplePaymentNack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SimplePaymentNack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.SimplePaymentNack"; }

 protected:
  explicit SimplePaymentNack(::google::protobuf::Arena* arena);
  SimplePaymentNack(::google::protobuf::Arena* arena, const SimplePaymentNack& from);
  SimplePaymentNack(::google::protobuf::Arena* arena, SimplePaymentNack&& from) noexcept
      : SimplePaymentNack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RejectionReason = SimplePaymentNack_RejectionReason;
  static constexpr RejectionReason REASON_UNKNOWN = SimplePaymentNack_RejectionReason_REASON_UNKNOWN;
  static constexpr RejectionReason REASON_OTHER = SimplePaymentNack_RejectionReason_REASON_OTHER;
  static constexpr RejectionReason REASON_AMOUNT_EMPTY = SimplePaymentNack_RejectionReason_REASON_AMOUNT_EMPTY;
  static constexpr RejectionReason REASON_CHANGE_REQUEST_AMOUNT_MISMATCH = SimplePaymentNack_RejectionReason_REASON_CHANGE_REQUEST_AMOUNT_MISMATCH;
  static inline bool RejectionReason_IsValid(int value) {
    return SimplePaymentNack_RejectionReason_IsValid(value);
  }
  static constexpr RejectionReason RejectionReason_MIN = SimplePaymentNack_RejectionReason_RejectionReason_MIN;
  static constexpr RejectionReason RejectionReason_MAX = SimplePaymentNack_RejectionReason_RejectionReason_MAX;
  static constexpr int RejectionReason_ARRAYSIZE = SimplePaymentNack_RejectionReason_RejectionReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RejectionReason_descriptor() {
    return SimplePaymentNack_RejectionReason_descriptor();
  }
  template <typename T>
  static inline const std::string& RejectionReason_Name(T value) {
    return SimplePaymentNack_RejectionReason_Name(value);
  }
  static inline bool RejectionReason_Parse(absl::string_view name, RejectionReason* value) {
    return SimplePaymentNack_RejectionReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOtherFieldNumber = 2,
    kRejectionReasonFieldNumber = 1,
  };
  // string other = 2;
  void clear_other() ;
  const std::string& other() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other(Arg_&& arg, Args_... args);
  std::string* mutable_other();
  PROTOBUF_NODISCARD std::string* release_other();
  void set_allocated_other(std::string* value);

  private:
  const std::string& _internal_other() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_other(
      const std::string& value);
  std::string* _internal_mutable_other();

  public:
  // .common.SimplePaymentNack.RejectionReason rejection_reason = 1;
  void clear_rejection_reason() ;
  ::common::SimplePaymentNack_RejectionReason rejection_reason() const;
  void set_rejection_reason(::common::SimplePaymentNack_RejectionReason value);

  private:
  ::common::SimplePaymentNack_RejectionReason _internal_rejection_reason() const;
  void _internal_set_rejection_reason(::common::SimplePaymentNack_RejectionReason value);

  public:
  // @@protoc_insertion_point(class_scope:common.SimplePaymentNack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SimplePaymentNack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SimplePaymentNack& from_msg);
    ::google::protobuf::internal::ArenaStringPtr other_;
    int rejection_reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class SimplePaymentAck final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:common.SimplePaymentAck) */ {
 public:
  inline SimplePaymentAck() : SimplePaymentAck(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimplePaymentAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline SimplePaymentAck(const SimplePaymentAck& from) : SimplePaymentAck(nullptr, from) {}
  inline SimplePaymentAck(SimplePaymentAck&& from) noexcept
      : SimplePaymentAck(nullptr, std::move(from)) {}
  inline SimplePaymentAck& operator=(const SimplePaymentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimplePaymentAck& operator=(SimplePaymentAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimplePaymentAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimplePaymentAck* internal_default_instance() {
    return reinterpret_cast<const SimplePaymentAck*>(
        &_SimplePaymentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SimplePaymentAck& a, SimplePaymentAck& b) { a.Swap(&b); }
  inline void Swap(SimplePaymentAck* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimplePaymentAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimplePaymentAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SimplePaymentAck>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SimplePaymentAck& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SimplePaymentAck& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.SimplePaymentAck"; }

 protected:
  explicit SimplePaymentAck(::google::protobuf::Arena* arena);
  SimplePaymentAck(::google::protobuf::Arena* arena, const SimplePaymentAck& from);
  SimplePaymentAck(::google::protobuf::Arena* arena, SimplePaymentAck&& from) noexcept
      : SimplePaymentAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:common.SimplePaymentAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SimplePaymentAck_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SimplePaymentAck& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class RedeemCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.RedeemCondition) */ {
 public:
  inline RedeemCondition() : RedeemCondition(nullptr) {}
  ~RedeemCondition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RedeemCondition(
      ::google::protobuf::internal::ConstantInitialized);

  inline RedeemCondition(const RedeemCondition& from) : RedeemCondition(nullptr, from) {}
  inline RedeemCondition(RedeemCondition&& from) noexcept
      : RedeemCondition(nullptr, std::move(from)) {}
  inline RedeemCondition& operator=(const RedeemCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedeemCondition& operator=(RedeemCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedeemCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedeemCondition* internal_default_instance() {
    return reinterpret_cast<const RedeemCondition*>(
        &_RedeemCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RedeemCondition& a, RedeemCondition& b) { a.Swap(&b); }
  inline void Swap(RedeemCondition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedeemCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedeemCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RedeemCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RedeemCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RedeemCondition& from) { RedeemCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RedeemCondition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.RedeemCondition"; }

 protected:
  explicit RedeemCondition(::google::protobuf::Arena* arena);
  RedeemCondition(::google::protobuf::Arena* arena, const RedeemCondition& from);
  RedeemCondition(::google::protobuf::Arena* arena, RedeemCondition&& from) noexcept
      : RedeemCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIssuerFieldNumber = 1,
  };
  // string issuer = 1;
  void clear_issuer() ;
  const std::string& issuer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_issuer(Arg_&& arg, Args_... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* value);

  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(
      const std::string& value);
  std::string* _internal_mutable_issuer();

  public:
  // @@protoc_insertion_point(class_scope:common.RedeemCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RedeemCondition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RedeemCondition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr issuer_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class HashCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.HashCondition) */ {
 public:
  inline HashCondition() : HashCondition(nullptr) {}
  ~HashCondition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashCondition(
      ::google::protobuf::internal::ConstantInitialized);

  inline HashCondition(const HashCondition& from) : HashCondition(nullptr, from) {}
  inline HashCondition(HashCondition&& from) noexcept
      : HashCondition(nullptr, std::move(from)) {}
  inline HashCondition& operator=(const HashCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashCondition& operator=(HashCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashCondition* internal_default_instance() {
    return reinterpret_cast<const HashCondition*>(
        &_HashCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(HashCondition& a, HashCondition& b) { a.Swap(&b); }
  inline void Swap(HashCondition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HashCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HashCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HashCondition& from) { HashCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HashCondition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.HashCondition"; }

 protected:
  explicit HashCondition(::google::protobuf::Arena* arena);
  HashCondition(::google::protobuf::Arena* arena, const HashCondition& from);
  HashCondition(::google::protobuf::Arena* arena, HashCondition&& from) noexcept
      : HashCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPresenterFieldNumber = 1,
    kHashFieldNumber = 2,
    kAlgorithmOidFieldNumber = 3,
  };
  // string presenter = 1;
  void clear_presenter() ;
  const std::string& presenter() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_presenter(Arg_&& arg, Args_... args);
  std::string* mutable_presenter();
  PROTOBUF_NODISCARD std::string* release_presenter();
  void set_allocated_presenter(std::string* value);

  private:
  const std::string& _internal_presenter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_presenter(
      const std::string& value);
  std::string* _internal_mutable_presenter();

  public:
  // bytes hash = 2;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // bytes algorithm_oid = 3;
  void clear_algorithm_oid() ;
  const std::string& algorithm_oid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm_oid(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm_oid();
  PROTOBUF_NODISCARD std::string* release_algorithm_oid();
  void set_allocated_algorithm_oid(std::string* value);

  private:
  const std::string& _internal_algorithm_oid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm_oid(
      const std::string& value);
  std::string* _internal_mutable_algorithm_oid();

  public:
  // @@protoc_insertion_point(class_scope:common.HashCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_HashCondition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HashCondition& from_msg);
    ::google::protobuf::internal::ArenaStringPtr presenter_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::google::protobuf::internal::ArenaStringPtr algorithm_oid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class FundsChangeNack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.FundsChangeNack) */ {
 public:
  inline FundsChangeNack() : FundsChangeNack(nullptr) {}
  ~FundsChangeNack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FundsChangeNack(
      ::google::protobuf::internal::ConstantInitialized);

  inline FundsChangeNack(const FundsChangeNack& from) : FundsChangeNack(nullptr, from) {}
  inline FundsChangeNack(FundsChangeNack&& from) noexcept
      : FundsChangeNack(nullptr, std::move(from)) {}
  inline FundsChangeNack& operator=(const FundsChangeNack& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundsChangeNack& operator=(FundsChangeNack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundsChangeNack& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundsChangeNack* internal_default_instance() {
    return reinterpret_cast<const FundsChangeNack*>(
        &_FundsChangeNack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FundsChangeNack& a, FundsChangeNack& b) { a.Swap(&b); }
  inline void Swap(FundsChangeNack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundsChangeNack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundsChangeNack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FundsChangeNack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FundsChangeNack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FundsChangeNack& from) { FundsChangeNack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FundsChangeNack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.FundsChangeNack"; }

 protected:
  explicit FundsChangeNack(::google::protobuf::Arena* arena);
  FundsChangeNack(::google::protobuf::Arena* arena, const FundsChangeNack& from);
  FundsChangeNack(::google::protobuf::Arena* arena, FundsChangeNack&& from) noexcept
      : FundsChangeNack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RejectionReason = FundsChangeNack_RejectionReason;
  static constexpr RejectionReason REASON_UNKNOWN = FundsChangeNack_RejectionReason_REASON_UNKNOWN;
  static constexpr RejectionReason REASON_OTHER = FundsChangeNack_RejectionReason_REASON_OTHER;
  static constexpr RejectionReason REASON_AMOUNT_EMPTY = FundsChangeNack_RejectionReason_REASON_AMOUNT_EMPTY;
  static constexpr RejectionReason REASON_AMOUNTS_MISMATCH = FundsChangeNack_RejectionReason_REASON_AMOUNTS_MISMATCH;
  static inline bool RejectionReason_IsValid(int value) {
    return FundsChangeNack_RejectionReason_IsValid(value);
  }
  static constexpr RejectionReason RejectionReason_MIN = FundsChangeNack_RejectionReason_RejectionReason_MIN;
  static constexpr RejectionReason RejectionReason_MAX = FundsChangeNack_RejectionReason_RejectionReason_MAX;
  static constexpr int RejectionReason_ARRAYSIZE = FundsChangeNack_RejectionReason_RejectionReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RejectionReason_descriptor() {
    return FundsChangeNack_RejectionReason_descriptor();
  }
  template <typename T>
  static inline const std::string& RejectionReason_Name(T value) {
    return FundsChangeNack_RejectionReason_Name(value);
  }
  static inline bool RejectionReason_Parse(absl::string_view name, RejectionReason* value) {
    return FundsChangeNack_RejectionReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOtherFieldNumber = 2,
    kRejectionReasonFieldNumber = 1,
  };
  // string other = 2;
  void clear_other() ;
  const std::string& other() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other(Arg_&& arg, Args_... args);
  std::string* mutable_other();
  PROTOBUF_NODISCARD std::string* release_other();
  void set_allocated_other(std::string* value);

  private:
  const std::string& _internal_other() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_other(
      const std::string& value);
  std::string* _internal_mutable_other();

  public:
  // .common.FundsChangeNack.RejectionReason rejection_reason = 1;
  void clear_rejection_reason() ;
  ::common::FundsChangeNack_RejectionReason rejection_reason() const;
  void set_rejection_reason(::common::FundsChangeNack_RejectionReason value);

  private:
  ::common::FundsChangeNack_RejectionReason _internal_rejection_reason() const;
  void _internal_set_rejection_reason(::common::FundsChangeNack_RejectionReason value);

  public:
  // @@protoc_insertion_point(class_scope:common.FundsChangeNack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FundsChangeNack_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FundsChangeNack& from_msg);
    ::google::protobuf::internal::ArenaStringPtr other_;
    int rejection_reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class FundsChangeAck final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:common.FundsChangeAck) */ {
 public:
  inline FundsChangeAck() : FundsChangeAck(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FundsChangeAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline FundsChangeAck(const FundsChangeAck& from) : FundsChangeAck(nullptr, from) {}
  inline FundsChangeAck(FundsChangeAck&& from) noexcept
      : FundsChangeAck(nullptr, std::move(from)) {}
  inline FundsChangeAck& operator=(const FundsChangeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundsChangeAck& operator=(FundsChangeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundsChangeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundsChangeAck* internal_default_instance() {
    return reinterpret_cast<const FundsChangeAck*>(
        &_FundsChangeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(FundsChangeAck& a, FundsChangeAck& b) { a.Swap(&b); }
  inline void Swap(FundsChangeAck* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundsChangeAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundsChangeAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FundsChangeAck>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FundsChangeAck& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FundsChangeAck& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.FundsChangeAck"; }

 protected:
  explicit FundsChangeAck(::google::protobuf::Arena* arena);
  FundsChangeAck(::google::protobuf::Arena* arena, const FundsChangeAck& from);
  FundsChangeAck(::google::protobuf::Arena* arena, FundsChangeAck&& from) noexcept
      : FundsChangeAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:common.FundsChangeAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FundsChangeAck_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FundsChangeAck& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class Contract_SignatoriesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Contract_SignatoriesEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_BYTES> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Contract_SignatoriesEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES>;
  Contract_SignatoriesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Contract_SignatoriesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Contract_SignatoriesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Contract_SignatoriesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Contract_SignatoriesEntry_DoNotUse*>(
        &_Contract_SignatoriesEntry_DoNotUse_default_instance_);
  }
const ::google::protobuf::Message::ClassData* GetClassData() const final;
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class CancelTransaction final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.CancelTransaction) */ {
 public:
  inline CancelTransaction() : CancelTransaction(nullptr) {}
  ~CancelTransaction() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelTransaction(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelTransaction(const CancelTransaction& from) : CancelTransaction(nullptr, from) {}
  inline CancelTransaction(CancelTransaction&& from) noexcept
      : CancelTransaction(nullptr, std::move(from)) {}
  inline CancelTransaction& operator=(const CancelTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelTransaction& operator=(CancelTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelTransaction* internal_default_instance() {
    return reinterpret_cast<const CancelTransaction*>(
        &_CancelTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(CancelTransaction& a, CancelTransaction& b) { a.Swap(&b); }
  inline void Swap(CancelTransaction* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelTransaction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelTransaction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CancelTransaction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelTransaction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelTransaction& from) { CancelTransaction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelTransaction* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.CancelTransaction"; }

 protected:
  explicit CancelTransaction(::google::protobuf::Arena* arena);
  CancelTransaction(::google::protobuf::Arena* arena, const CancelTransaction& from);
  CancelTransaction(::google::protobuf::Arena* arena, CancelTransaction&& from) noexcept
      : CancelTransaction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RejectionReason = CancelTransaction_RejectionReason;
  static constexpr RejectionReason REASON_UNKNOWN = CancelTransaction_RejectionReason_REASON_UNKNOWN;
  static constexpr RejectionReason REASON_OTHER = CancelTransaction_RejectionReason_REASON_OTHER;
  static constexpr RejectionReason REASON_MISMATCHED_TRANSACTIONS = CancelTransaction_RejectionReason_REASON_MISMATCHED_TRANSACTIONS;
  static inline bool RejectionReason_IsValid(int value) {
    return CancelTransaction_RejectionReason_IsValid(value);
  }
  static constexpr RejectionReason RejectionReason_MIN = CancelTransaction_RejectionReason_RejectionReason_MIN;
  static constexpr RejectionReason RejectionReason_MAX = CancelTransaction_RejectionReason_RejectionReason_MAX;
  static constexpr int RejectionReason_ARRAYSIZE = CancelTransaction_RejectionReason_RejectionReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RejectionReason_descriptor() {
    return CancelTransaction_RejectionReason_descriptor();
  }
  template <typename T>
  static inline const std::string& RejectionReason_Name(T value) {
    return CancelTransaction_RejectionReason_Name(value);
  }
  static inline bool RejectionReason_Parse(absl::string_view name, RejectionReason* value) {
    return CancelTransaction_RejectionReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kOtherFieldNumber = 2,
    kRejectionReasonFieldNumber = 1,
  };
  // string other = 2;
  void clear_other() ;
  const std::string& other() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other(Arg_&& arg, Args_... args);
  std::string* mutable_other();
  PROTOBUF_NODISCARD std::string* release_other();
  void set_allocated_other(std::string* value);

  private:
  const std::string& _internal_other() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_other(
      const std::string& value);
  std::string* _internal_mutable_other();

  public:
  // .common.CancelTransaction.RejectionReason rejection_reason = 1;
  void clear_rejection_reason() ;
  ::common::CancelTransaction_RejectionReason rejection_reason() const;
  void set_rejection_reason(::common::CancelTransaction_RejectionReason value);

  private:
  ::common::CancelTransaction_RejectionReason _internal_rejection_reason() const;
  void _internal_set_rejection_reason(::common::CancelTransaction_RejectionReason value);

  public:
  // @@protoc_insertion_point(class_scope:common.CancelTransaction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_CancelTransaction_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelTransaction& from_msg);
    ::google::protobuf::internal::ArenaStringPtr other_;
    int rejection_reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class BatchedPromissory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.BatchedPromissory) */ {
 public:
  inline BatchedPromissory() : BatchedPromissory(nullptr) {}
  ~BatchedPromissory() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BatchedPromissory(
      ::google::protobuf::internal::ConstantInitialized);

  inline BatchedPromissory(const BatchedPromissory& from) : BatchedPromissory(nullptr, from) {}
  inline BatchedPromissory(BatchedPromissory&& from) noexcept
      : BatchedPromissory(nullptr, std::move(from)) {}
  inline BatchedPromissory& operator=(const BatchedPromissory& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchedPromissory& operator=(BatchedPromissory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchedPromissory& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchedPromissory* internal_default_instance() {
    return reinterpret_cast<const BatchedPromissory*>(
        &_BatchedPromissory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BatchedPromissory& a, BatchedPromissory& b) { a.Swap(&b); }
  inline void Swap(BatchedPromissory* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchedPromissory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchedPromissory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BatchedPromissory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchedPromissory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BatchedPromissory& from) { BatchedPromissory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BatchedPromissory* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.BatchedPromissory"; }

 protected:
  explicit BatchedPromissory(::google::protobuf::Arena* arena);
  BatchedPromissory(::google::protobuf::Arena* arena, const BatchedPromissory& from);
  BatchedPromissory(::google::protobuf::Arena* arena, BatchedPromissory&& from) noexcept
      : BatchedPromissory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPromissoryBatchFieldNumber = 1,
  };
  // repeated bytes promissory_batch = 1;
  int promissory_batch_size() const;
  private:
  int _internal_promissory_batch_size() const;

  public:
  void clear_promissory_batch() ;
  const std::string& promissory_batch(int index) const;
  std::string* mutable_promissory_batch(int index);
  void set_promissory_batch(int index, const std::string& value);
  void set_promissory_batch(int index, std::string&& value);
  void set_promissory_batch(int index, const char* value);
  void set_promissory_batch(int index, const void* value, std::size_t size);
  void set_promissory_batch(int index, absl::string_view value);
  std::string* add_promissory_batch();
  void add_promissory_batch(const std::string& value);
  void add_promissory_batch(std::string&& value);
  void add_promissory_batch(const char* value);
  void add_promissory_batch(const void* value, std::size_t size);
  void add_promissory_batch(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& promissory_batch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_promissory_batch();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_promissory_batch() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_promissory_batch();

  public:
  // @@protoc_insertion_point(class_scope:common.BatchedPromissory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_BatchedPromissory_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BatchedPromissory& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> promissory_batch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class TransactionHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.TransactionHeader) */ {
 public:
  inline TransactionHeader() : TransactionHeader(nullptr) {}
  ~TransactionHeader() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TransactionHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline TransactionHeader(const TransactionHeader& from) : TransactionHeader(nullptr, from) {}
  inline TransactionHeader(TransactionHeader&& from) noexcept
      : TransactionHeader(nullptr, std::move(from)) {}
  inline TransactionHeader& operator=(const TransactionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionHeader& operator=(TransactionHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionHeader* internal_default_instance() {
    return reinterpret_cast<const TransactionHeader*>(
        &_TransactionHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TransactionHeader& a, TransactionHeader& b) { a.Swap(&b); }
  inline void Swap(TransactionHeader* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TransactionHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransactionHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TransactionHeader& from) { TransactionHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransactionHeader* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.TransactionHeader"; }

 protected:
  explicit TransactionHeader(::google::protobuf::Arena* arena);
  TransactionHeader(::google::protobuf::Arena* arena, const TransactionHeader& from);
  TransactionHeader(::google::protobuf::Arena* arena, TransactionHeader&& from) noexcept
      : TransactionHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRelatedUetrsFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kUetrFieldNumber = 1,
    kUrnFieldNumber = 2,
    kMemoFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // repeated string related_uetrs = 5;
  int related_uetrs_size() const;
  private:
  int _internal_related_uetrs_size() const;

  public:
  void clear_related_uetrs() ;
  const std::string& related_uetrs(int index) const;
  std::string* mutable_related_uetrs(int index);
  void set_related_uetrs(int index, const std::string& value);
  void set_related_uetrs(int index, std::string&& value);
  void set_related_uetrs(int index, const char* value);
  void set_related_uetrs(int index, const char* value, std::size_t size);
  void set_related_uetrs(int index, absl::string_view value);
  std::string* add_related_uetrs();
  void add_related_uetrs(const std::string& value);
  void add_related_uetrs(std::string&& value);
  void add_related_uetrs(const char* value);
  void add_related_uetrs(const char* value, std::size_t size);
  void add_related_uetrs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& related_uetrs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_related_uetrs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_related_uetrs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_related_uetrs();

  public:
  // map<string, string> metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<std::string, std::string>& metadata() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_metadata();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_metadata() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_metadata();

  public:
  // string uetr = 1;
  void clear_uetr() ;
  const std::string& uetr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uetr(Arg_&& arg, Args_... args);
  std::string* mutable_uetr();
  PROTOBUF_NODISCARD std::string* release_uetr();
  void set_allocated_uetr(std::string* value);

  private:
  const std::string& _internal_uetr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uetr(
      const std::string& value);
  std::string* _internal_mutable_uetr();

  public:
  // string urn = 2;
  void clear_urn() ;
  const std::string& urn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_urn(Arg_&& arg, Args_... args);
  std::string* mutable_urn();
  PROTOBUF_NODISCARD std::string* release_urn();
  void set_allocated_urn(std::string* value);

  private:
  const std::string& _internal_urn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_urn(
      const std::string& value);
  std::string* _internal_mutable_urn();

  public:
  // string memo = 3;
  void clear_memo() ;
  const std::string& memo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memo(Arg_&& arg, Args_... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* value);

  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(
      const std::string& value);
  std::string* _internal_mutable_memo();

  public:
  // uint64 timestamp = 4;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:common.TransactionHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      65, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TransactionHeader_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TransactionHeader& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> related_uetrs_;
    ::google::protobuf::internal::MapField<TransactionHeader_MetadataEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    ::google::protobuf::internal::ArenaStringPtr uetr_;
    ::google::protobuf::internal::ArenaStringPtr urn_;
    ::google::protobuf::internal::ArenaStringPtr memo_;
    ::uint64_t timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class SimplePaymentResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.SimplePaymentResponse) */ {
 public:
  inline SimplePaymentResponse() : SimplePaymentResponse(nullptr) {}
  ~SimplePaymentResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimplePaymentResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SimplePaymentResponse(const SimplePaymentResponse& from) : SimplePaymentResponse(nullptr, from) {}
  inline SimplePaymentResponse(SimplePaymentResponse&& from) noexcept
      : SimplePaymentResponse(nullptr, std::move(from)) {}
  inline SimplePaymentResponse& operator=(const SimplePaymentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimplePaymentResponse& operator=(SimplePaymentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimplePaymentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimplePaymentResponse* internal_default_instance() {
    return reinterpret_cast<const SimplePaymentResponse*>(
        &_SimplePaymentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SimplePaymentResponse& a, SimplePaymentResponse& b) { a.Swap(&b); }
  inline void Swap(SimplePaymentResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimplePaymentResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimplePaymentResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SimplePaymentResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimplePaymentResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimplePaymentResponse& from) { SimplePaymentResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SimplePaymentResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.SimplePaymentResponse"; }

 protected:
  explicit SimplePaymentResponse(::google::protobuf::Arena* arena);
  SimplePaymentResponse(::google::protobuf::Arena* arena, const SimplePaymentResponse& from);
  SimplePaymentResponse(::google::protobuf::Arena* arena, SimplePaymentResponse&& from) noexcept
      : SimplePaymentResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReceivedPromissoriesFieldNumber = 2,
    kReceivedAmountFieldNumber = 1,
  };
  // repeated string received_promissories = 2;
  int received_promissories_size() const;
  private:
  int _internal_received_promissories_size() const;

  public:
  void clear_received_promissories() ;
  const std::string& received_promissories(int index) const;
  std::string* mutable_received_promissories(int index);
  void set_received_promissories(int index, const std::string& value);
  void set_received_promissories(int index, std::string&& value);
  void set_received_promissories(int index, const char* value);
  void set_received_promissories(int index, const char* value, std::size_t size);
  void set_received_promissories(int index, absl::string_view value);
  std::string* add_received_promissories();
  void add_received_promissories(const std::string& value);
  void add_received_promissories(std::string&& value);
  void add_received_promissories(const char* value);
  void add_received_promissories(const char* value, std::size_t size);
  void add_received_promissories(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& received_promissories() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_received_promissories();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_received_promissories() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_received_promissories();

  public:
  // .common.Amount received_amount = 1;
  bool has_received_amount() const;
  void clear_received_amount() ;
  const ::common::Amount& received_amount() const;
  PROTOBUF_NODISCARD ::common::Amount* release_received_amount();
  ::common::Amount* mutable_received_amount();
  void set_allocated_received_amount(::common::Amount* value);
  void unsafe_arena_set_allocated_received_amount(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_received_amount();

  private:
  const ::common::Amount& _internal_received_amount() const;
  ::common::Amount* _internal_mutable_received_amount();

  public:
  // @@protoc_insertion_point(class_scope:common.SimplePaymentResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      58, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SimplePaymentResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SimplePaymentResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> received_promissories_;
    ::common::Amount* received_amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class SimplePaymentRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.SimplePaymentRequest) */ {
 public:
  inline SimplePaymentRequest() : SimplePaymentRequest(nullptr) {}
  ~SimplePaymentRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SimplePaymentRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SimplePaymentRequest(const SimplePaymentRequest& from) : SimplePaymentRequest(nullptr, from) {}
  inline SimplePaymentRequest(SimplePaymentRequest&& from) noexcept
      : SimplePaymentRequest(nullptr, std::move(from)) {}
  inline SimplePaymentRequest& operator=(const SimplePaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimplePaymentRequest& operator=(SimplePaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimplePaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimplePaymentRequest* internal_default_instance() {
    return reinterpret_cast<const SimplePaymentRequest*>(
        &_SimplePaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SimplePaymentRequest& a, SimplePaymentRequest& b) { a.Swap(&b); }
  inline void Swap(SimplePaymentRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimplePaymentRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimplePaymentRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SimplePaymentRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimplePaymentRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SimplePaymentRequest& from) { SimplePaymentRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SimplePaymentRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.SimplePaymentRequest"; }

 protected:
  explicit SimplePaymentRequest(::google::protobuf::Arena* arena);
  SimplePaymentRequest(::google::protobuf::Arena* arena, const SimplePaymentRequest& from);
  SimplePaymentRequest(::google::protobuf::Arena* arena, SimplePaymentRequest&& from) noexcept
      : SimplePaymentRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAmountFieldNumber = 1,
  };
  // .common.Amount amount = 1;
  bool has_amount() const;
  void clear_amount() ;
  const ::common::Amount& amount() const;
  PROTOBUF_NODISCARD ::common::Amount* release_amount();
  ::common::Amount* mutable_amount();
  void set_allocated_amount(::common::Amount* value);
  void unsafe_arena_set_allocated_amount(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_amount();

  private:
  const ::common::Amount& _internal_amount() const;
  ::common::Amount* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:common.SimplePaymentRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SimplePaymentRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SimplePaymentRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::common::Amount* amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class FundsChangeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.FundsChangeRequest) */ {
 public:
  inline FundsChangeRequest() : FundsChangeRequest(nullptr) {}
  ~FundsChangeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FundsChangeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FundsChangeRequest(const FundsChangeRequest& from) : FundsChangeRequest(nullptr, from) {}
  inline FundsChangeRequest(FundsChangeRequest&& from) noexcept
      : FundsChangeRequest(nullptr, std::move(from)) {}
  inline FundsChangeRequest& operator=(const FundsChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundsChangeRequest& operator=(FundsChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundsChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundsChangeRequest* internal_default_instance() {
    return reinterpret_cast<const FundsChangeRequest*>(
        &_FundsChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(FundsChangeRequest& a, FundsChangeRequest& b) { a.Swap(&b); }
  inline void Swap(FundsChangeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundsChangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundsChangeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FundsChangeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FundsChangeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FundsChangeRequest& from) { FundsChangeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FundsChangeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.FundsChangeRequest"; }

 protected:
  explicit FundsChangeRequest(::google::protobuf::Arena* arena);
  FundsChangeRequest(::google::protobuf::Arena* arena, const FundsChangeRequest& from);
  FundsChangeRequest(::google::protobuf::Arena* arena, FundsChangeRequest&& from) noexcept
      : FundsChangeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGrossAmountFieldNumber = 1,
    kExactAmountFieldNumber = 2,
    kFeesFieldNumber = 3,
  };
  // .common.Amount gross_amount = 1;
  bool has_gross_amount() const;
  void clear_gross_amount() ;
  const ::common::Amount& gross_amount() const;
  PROTOBUF_NODISCARD ::common::Amount* release_gross_amount();
  ::common::Amount* mutable_gross_amount();
  void set_allocated_gross_amount(::common::Amount* value);
  void unsafe_arena_set_allocated_gross_amount(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_gross_amount();

  private:
  const ::common::Amount& _internal_gross_amount() const;
  ::common::Amount* _internal_mutable_gross_amount();

  public:
  // .common.Amount exact_amount = 2;
  bool has_exact_amount() const;
  void clear_exact_amount() ;
  const ::common::Amount& exact_amount() const;
  PROTOBUF_NODISCARD ::common::Amount* release_exact_amount();
  ::common::Amount* mutable_exact_amount();
  void set_allocated_exact_amount(::common::Amount* value);
  void unsafe_arena_set_allocated_exact_amount(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_exact_amount();

  private:
  const ::common::Amount& _internal_exact_amount() const;
  ::common::Amount* _internal_mutable_exact_amount();

  public:
  // .common.Amount fees = 3;
  bool has_fees() const;
  void clear_fees() ;
  const ::common::Amount& fees() const;
  PROTOBUF_NODISCARD ::common::Amount* release_fees();
  ::common::Amount* mutable_fees();
  void set_allocated_fees(::common::Amount* value);
  void unsafe_arena_set_allocated_fees(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_fees();

  private:
  const ::common::Amount& _internal_fees() const;
  ::common::Amount* _internal_mutable_fees();

  public:
  // @@protoc_insertion_point(class_scope:common.FundsChangeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_FundsChangeRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FundsChangeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::common::Amount* gross_amount_;
    ::common::Amount* exact_amount_;
    ::common::Amount* fees_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class Commitment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.Commitment) */ {
 public:
  inline Commitment() : Commitment(nullptr) {}
  ~Commitment() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Commitment(
      ::google::protobuf::internal::ConstantInitialized);

  inline Commitment(const Commitment& from) : Commitment(nullptr, from) {}
  inline Commitment(Commitment&& from) noexcept
      : Commitment(nullptr, std::move(from)) {}
  inline Commitment& operator=(const Commitment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commitment& operator=(Commitment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commitment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Commitment* internal_default_instance() {
    return reinterpret_cast<const Commitment*>(
        &_Commitment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Commitment& a, Commitment& b) { a.Swap(&b); }
  inline void Swap(Commitment* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commitment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commitment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Commitment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Commitment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Commitment& from) { Commitment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Commitment* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.Commitment"; }

 protected:
  explicit Commitment(::google::protobuf::Arena* arena);
  Commitment(::google::protobuf::Arena* arena, const Commitment& from);
  Commitment(::google::protobuf::Arena* arena, Commitment&& from) noexcept
      : Commitment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSenderFieldNumber = 1,
    kRecipientFieldNumber = 2,
    kAmountFieldNumber = 3,
  };
  // string sender = 1;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string recipient = 2;
  void clear_recipient() ;
  const std::string& recipient() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_recipient();
  PROTOBUF_NODISCARD std::string* release_recipient();
  void set_allocated_recipient(std::string* value);

  private:
  const std::string& _internal_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient(
      const std::string& value);
  std::string* _internal_mutable_recipient();

  public:
  // .common.Amount amount = 3;
  bool has_amount() const;
  void clear_amount() ;
  const ::common::Amount& amount() const;
  PROTOBUF_NODISCARD ::common::Amount* release_amount();
  ::common::Amount* mutable_amount();
  void set_allocated_amount(::common::Amount* value);
  void unsafe_arena_set_allocated_amount(::common::Amount* value);
  ::common::Amount* unsafe_arena_release_amount();

  private:
  const ::common::Amount& _internal_amount() const;
  ::common::Amount* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:common.Commitment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      41, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Commitment_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Commitment& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::google::protobuf::internal::ArenaStringPtr recipient_;
    ::common::Amount* amount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class Packet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {}
  ~Packet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Packet(
      ::google::protobuf::internal::ConstantInitialized);

  inline Packet(const Packet& from) : Packet(nullptr, from) {}
  inline Packet(Packet&& from) noexcept
      : Packet(nullptr, std::move(from)) {}
  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Packet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
        &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Packet& a, Packet& b) { a.Swap(&b); }
  inline void Swap(Packet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Packet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Packet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Packet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Packet& from) { Packet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Packet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.Packet"; }

 protected:
  explicit Packet(::google::protobuf::Arena* arena);
  Packet(::google::protobuf::Arena* arena, const Packet& from);
  Packet(::google::protobuf::Arena* arena, Packet&& from) noexcept
      : Packet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kNonceFieldNumber = 6,
    kSenderFieldNumber = 4,
    kRecipientFieldNumber = 5,
    kTransactionHeaderFieldNumber = 7,
    kPacketTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // bytes nonce = 6;
  void clear_nonce() ;
  const std::string& nonce() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nonce(Arg_&& arg, Args_... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* value);

  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(
      const std::string& value);
  std::string* _internal_mutable_nonce();

  public:
  // .common.DynamicVerifier sender = 4;
  bool has_sender() const;
  void clear_sender() ;
  const ::common::DynamicVerifier& sender() const;
  PROTOBUF_NODISCARD ::common::DynamicVerifier* release_sender();
  ::common::DynamicVerifier* mutable_sender();
  void set_allocated_sender(::common::DynamicVerifier* value);
  void unsafe_arena_set_allocated_sender(::common::DynamicVerifier* value);
  ::common::DynamicVerifier* unsafe_arena_release_sender();

  private:
  const ::common::DynamicVerifier& _internal_sender() const;
  ::common::DynamicVerifier* _internal_mutable_sender();

  public:
  // .common.DynamicVerifier recipient = 5;
  bool has_recipient() const;
  void clear_recipient() ;
  const ::common::DynamicVerifier& recipient() const;
  PROTOBUF_NODISCARD ::common::DynamicVerifier* release_recipient();
  ::common::DynamicVerifier* mutable_recipient();
  void set_allocated_recipient(::common::DynamicVerifier* value);
  void unsafe_arena_set_allocated_recipient(::common::DynamicVerifier* value);
  ::common::DynamicVerifier* unsafe_arena_release_recipient();

  private:
  const ::common::DynamicVerifier& _internal_recipient() const;
  ::common::DynamicVerifier* _internal_mutable_recipient();

  public:
  // .common.TransactionHeader transaction_header = 7;
  bool has_transaction_header() const;
  void clear_transaction_header() ;
  const ::common::TransactionHeader& transaction_header() const;
  PROTOBUF_NODISCARD ::common::TransactionHeader* release_transaction_header();
  ::common::TransactionHeader* mutable_transaction_header();
  void set_allocated_transaction_header(::common::TransactionHeader* value);
  void unsafe_arena_set_allocated_transaction_header(::common::TransactionHeader* value);
  ::common::TransactionHeader* unsafe_arena_release_transaction_header();

  private:
  const ::common::TransactionHeader& _internal_transaction_header() const;
  ::common::TransactionHeader* _internal_mutable_transaction_header();

  public:
  // .common.PacketType packet_type = 1;
  void clear_packet_type() ;
  ::common::PacketType packet_type() const;
  void set_packet_type(::common::PacketType value);

  private:
  ::common::PacketType _internal_packet_type() const;
  void _internal_set_packet_type(::common::PacketType value);

  public:
  // @@protoc_insertion_point(class_scope:common.Packet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Packet_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Packet& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr nonce_;
    ::common::DynamicVerifier* sender_;
    ::common::DynamicVerifier* recipient_;
    ::common::TransactionHeader* transaction_header_;
    int packet_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class MintCondition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.MintCondition) */ {
 public:
  inline MintCondition() : MintCondition(nullptr) {}
  ~MintCondition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MintCondition(
      ::google::protobuf::internal::ConstantInitialized);

  inline MintCondition(const MintCondition& from) : MintCondition(nullptr, from) {}
  inline MintCondition(MintCondition&& from) noexcept
      : MintCondition(nullptr, std::move(from)) {}
  inline MintCondition& operator=(const MintCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MintCondition& operator=(MintCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MintCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MintCondition* internal_default_instance() {
    return reinterpret_cast<const MintCondition*>(
        &_MintCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(MintCondition& a, MintCondition& b) { a.Swap(&b); }
  inline void Swap(MintCondition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MintCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MintCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MintCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MintCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MintCondition& from) { MintCondition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MintCondition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.MintCondition"; }

 protected:
  explicit MintCondition(::google::protobuf::Arena* arena);
  MintCondition(::google::protobuf::Arena* arena, const MintCondition& from);
  MintCondition(::google::protobuf::Arena* arena, MintCondition&& from) noexcept
      : MintCondition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIssuerFieldNumber = 1,
    kDistributionFieldNumber = 2,
  };
  // string issuer = 1;
  void clear_issuer() ;
  const std::string& issuer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_issuer(Arg_&& arg, Args_... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* value);

  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(
      const std::string& value);
  std::string* _internal_mutable_issuer();

  public:
  // .common.Distribution distribution = 2;
  bool has_distribution() const;
  void clear_distribution() ;
  const ::common::Distribution& distribution() const;
  PROTOBUF_NODISCARD ::common::Distribution* release_distribution();
  ::common::Distribution* mutable_distribution();
  void set_allocated_distribution(::common::Distribution* value);
  void unsafe_arena_set_allocated_distribution(::common::Distribution* value);
  ::common::Distribution* unsafe_arena_release_distribution();

  private:
  const ::common::Distribution& _internal_distribution() const;
  ::common::Distribution* _internal_mutable_distribution();

  public:
  // @@protoc_insertion_point(class_scope:common.MintCondition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MintCondition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MintCondition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr issuer_;
    ::common::Distribution* distribution_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class Condition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Condition(
      ::google::protobuf::internal::ConstantInitialized);

  inline Condition(const Condition& from) : Condition(nullptr, from) {}
  inline Condition(Condition&& from) noexcept
      : Condition(nullptr, std::move(from)) {}
  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  enum ConditionCase {
    kTimeout = 1,
    kHash = 2,
    kMint = 3,
    kRedeem = 4,
    CONDITION_NOT_SET = 0,
  };
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
        &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(Condition& a, Condition& b) { a.Swap(&b); }
  inline void Swap(Condition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Condition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Condition& from) { Condition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Condition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.Condition"; }

 protected:
  explicit Condition(::google::protobuf::Arena* arena);
  Condition(::google::protobuf::Arena* arena, const Condition& from);
  Condition(::google::protobuf::Arena* arena, Condition&& from) noexcept
      : Condition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeoutFieldNumber = 1,
    kHashFieldNumber = 2,
    kMintFieldNumber = 3,
    kRedeemFieldNumber = 4,
  };
  // .common.TimeoutCondition timeout = 1;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;

  public:
  void clear_timeout() ;
  const ::common::TimeoutCondition& timeout() const;
  PROTOBUF_NODISCARD ::common::TimeoutCondition* release_timeout();
  ::common::TimeoutCondition* mutable_timeout();
  void set_allocated_timeout(::common::TimeoutCondition* value);
  void unsafe_arena_set_allocated_timeout(::common::TimeoutCondition* value);
  ::common::TimeoutCondition* unsafe_arena_release_timeout();

  private:
  const ::common::TimeoutCondition& _internal_timeout() const;
  ::common::TimeoutCondition* _internal_mutable_timeout();

  public:
  // .common.HashCondition hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;

  public:
  void clear_hash() ;
  const ::common::HashCondition& hash() const;
  PROTOBUF_NODISCARD ::common::HashCondition* release_hash();
  ::common::HashCondition* mutable_hash();
  void set_allocated_hash(::common::HashCondition* value);
  void unsafe_arena_set_allocated_hash(::common::HashCondition* value);
  ::common::HashCondition* unsafe_arena_release_hash();

  private:
  const ::common::HashCondition& _internal_hash() const;
  ::common::HashCondition* _internal_mutable_hash();

  public:
  // .common.MintCondition mint = 3;
  bool has_mint() const;
  private:
  bool _internal_has_mint() const;

  public:
  void clear_mint() ;
  const ::common::MintCondition& mint() const;
  PROTOBUF_NODISCARD ::common::MintCondition* release_mint();
  ::common::MintCondition* mutable_mint();
  void set_allocated_mint(::common::MintCondition* value);
  void unsafe_arena_set_allocated_mint(::common::MintCondition* value);
  ::common::MintCondition* unsafe_arena_release_mint();

  private:
  const ::common::MintCondition& _internal_mint() const;
  ::common::MintCondition* _internal_mutable_mint();

  public:
  // .common.RedeemCondition redeem = 4;
  bool has_redeem() const;
  private:
  bool _internal_has_redeem() const;

  public:
  void clear_redeem() ;
  const ::common::RedeemCondition& redeem() const;
  PROTOBUF_NODISCARD ::common::RedeemCondition* release_redeem();
  ::common::RedeemCondition* mutable_redeem();
  void set_allocated_redeem(::common::RedeemCondition* value);
  void unsafe_arena_set_allocated_redeem(::common::RedeemCondition* value);
  ::common::RedeemCondition* unsafe_arena_release_redeem();

  private:
  const ::common::RedeemCondition& _internal_redeem() const;
  ::common::RedeemCondition* _internal_mutable_redeem();

  public:
  void clear_condition();
  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:common.Condition)
 private:
  class _Internal;
  void set_has_timeout();
  void set_has_hash();
  void set_has_mint();
  void set_has_redeem();
  inline bool has_condition() const;
  inline void clear_has_condition();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Condition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Condition& from_msg);
    union ConditionUnion {
      constexpr ConditionUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::common::TimeoutCondition* timeout_;
      ::common::HashCondition* hash_;
      ::common::MintCondition* mint_;
      ::common::RedeemCondition* redeem_;
    } condition_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class AssociatedUetrConnection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.AssociatedUetrConnection) */ {
 public:
  inline AssociatedUetrConnection() : AssociatedUetrConnection(nullptr) {}
  ~AssociatedUetrConnection() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AssociatedUetrConnection(
      ::google::protobuf::internal::ConstantInitialized);

  inline AssociatedUetrConnection(const AssociatedUetrConnection& from) : AssociatedUetrConnection(nullptr, from) {}
  inline AssociatedUetrConnection(AssociatedUetrConnection&& from) noexcept
      : AssociatedUetrConnection(nullptr, std::move(from)) {}
  inline AssociatedUetrConnection& operator=(const AssociatedUetrConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssociatedUetrConnection& operator=(AssociatedUetrConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssociatedUetrConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssociatedUetrConnection* internal_default_instance() {
    return reinterpret_cast<const AssociatedUetrConnection*>(
        &_AssociatedUetrConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AssociatedUetrConnection& a, AssociatedUetrConnection& b) { a.Swap(&b); }
  inline void Swap(AssociatedUetrConnection* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssociatedUetrConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssociatedUetrConnection* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AssociatedUetrConnection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AssociatedUetrConnection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AssociatedUetrConnection& from) { AssociatedUetrConnection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AssociatedUetrConnection* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.AssociatedUetrConnection"; }

 protected:
  explicit AssociatedUetrConnection(::google::protobuf::Arena* arena);
  AssociatedUetrConnection(::google::protobuf::Arena* arena, const AssociatedUetrConnection& from);
  AssociatedUetrConnection(::google::protobuf::Arena* arena, AssociatedUetrConnection&& from) noexcept
      : AssociatedUetrConnection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUetrFieldNumber = 1,
    kPacketFieldNumber = 2,
  };
  // string uetr = 1;
  void clear_uetr() ;
  const std::string& uetr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uetr(Arg_&& arg, Args_... args);
  std::string* mutable_uetr();
  PROTOBUF_NODISCARD std::string* release_uetr();
  void set_allocated_uetr(std::string* value);

  private:
  const std::string& _internal_uetr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uetr(
      const std::string& value);
  std::string* _internal_mutable_uetr();

  public:
  // optional .common.Packet packet = 2;
  bool has_packet() const;
  void clear_packet() ;
  const ::common::Packet& packet() const;
  PROTOBUF_NODISCARD ::common::Packet* release_packet();
  ::common::Packet* mutable_packet();
  void set_allocated_packet(::common::Packet* value);
  void unsafe_arena_set_allocated_packet(::common::Packet* value);
  ::common::Packet* unsafe_arena_release_packet();

  private:
  const ::common::Packet& _internal_packet() const;
  ::common::Packet* _internal_mutable_packet();

  public:
  // @@protoc_insertion_point(class_scope:common.AssociatedUetrConnection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AssociatedUetrConnection_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AssociatedUetrConnection& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uetr_;
    ::common::Packet* packet_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};
// -------------------------------------------------------------------

class Contract final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:common.Contract) */ {
 public:
  inline Contract() : Contract(nullptr) {}
  ~Contract() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Contract(
      ::google::protobuf::internal::ConstantInitialized);

  inline Contract(const Contract& from) : Contract(nullptr, from) {}
  inline Contract(Contract&& from) noexcept
      : Contract(nullptr, std::move(from)) {}
  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contract& operator=(Contract&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
        &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Contract& a, Contract& b) { a.Swap(&b); }
  inline void Swap(Contract* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contract* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Contract>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Contract& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Contract& from) { Contract::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Contract* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "common.Contract"; }

 protected:
  explicit Contract(::google::protobuf::Arena* arena);
  Contract(::google::protobuf::Arena* arena, const Contract& from);
  Contract(::google::protobuf::Arena* arena, Contract&& from) noexcept
      : Contract(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommitmentsFieldNumber = 3,
    kConditionsFieldNumber = 4,
    kSignatoriesFieldNumber = 5,
    kUrnFieldNumber = 1,
    kIdFieldNumber = 2,
    kMemoFieldNumber = 6,
  };
  // repeated .common.Commitment commitments = 3;
  int commitments_size() const;
  private:
  int _internal_commitments_size() const;

  public:
  void clear_commitments() ;
  ::common::Commitment* mutable_commitments(int index);
  ::google::protobuf::RepeatedPtrField<::common::Commitment>* mutable_commitments();

  private:
  const ::google::protobuf::RepeatedPtrField<::common::Commitment>& _internal_commitments() const;
  ::google::protobuf::RepeatedPtrField<::common::Commitment>* _internal_mutable_commitments();
  public:
  const ::common::Commitment& commitments(int index) const;
  ::common::Commitment* add_commitments();
  const ::google::protobuf::RepeatedPtrField<::common::Commitment>& commitments() const;
  // repeated .common.Condition conditions = 4;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;

  public:
  void clear_conditions() ;
  ::common::Condition* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField<::common::Condition>* mutable_conditions();

  private:
  const ::google::protobuf::RepeatedPtrField<::common::Condition>& _internal_conditions() const;
  ::google::protobuf::RepeatedPtrField<::common::Condition>* _internal_mutable_conditions();
  public:
  const ::common::Condition& conditions(int index) const;
  ::common::Condition* add_conditions();
  const ::google::protobuf::RepeatedPtrField<::common::Condition>& conditions() const;
  // map<string, bytes> signatories = 5;
  int signatories_size() const;
  private:
  int _internal_signatories_size() const;

  public:
  void clear_signatories() ;
  const ::google::protobuf::Map<std::string, std::string>& signatories() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_signatories();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_signatories() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_signatories();

  public:
  // string urn = 1;
  void clear_urn() ;
  const std::string& urn() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_urn(Arg_&& arg, Args_... args);
  std::string* mutable_urn();
  PROTOBUF_NODISCARD std::string* release_urn();
  void set_allocated_urn(std::string* value);

  private:
  const std::string& _internal_urn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_urn(
      const std::string& value);
  std::string* _internal_mutable_urn();

  public:
  // string id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string memo = 6;
  void clear_memo() ;
  const std::string& memo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memo(Arg_&& arg, Args_... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* value);

  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(
      const std::string& value);
  std::string* _internal_mutable_memo();

  public:
  // @@protoc_insertion_point(class_scope:common.Contract)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Contract_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Contract& from_msg);
    ::google::protobuf::RepeatedPtrField< ::common::Commitment > commitments_;
    ::google::protobuf::RepeatedPtrField< ::common::Condition > conditions_;
    ::google::protobuf::internal::MapField<Contract_SignatoriesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES>
        signatories_;
    ::google::protobuf::internal::ArenaStringPtr urn_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr memo_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fv1_2fpacket_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Packet

// .common.PacketType packet_type = 1;
inline void Packet::clear_packet_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_type_ = 0;
}
inline ::common::PacketType Packet::packet_type() const {
  // @@protoc_insertion_point(field_get:common.Packet.packet_type)
  return _internal_packet_type();
}
inline void Packet::set_packet_type(::common::PacketType value) {
  _internal_set_packet_type(value);
  // @@protoc_insertion_point(field_set:common.Packet.packet_type)
}
inline ::common::PacketType Packet::_internal_packet_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::common::PacketType>(_impl_.packet_type_);
}
inline void Packet::_internal_set_packet_type(::common::PacketType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.packet_type_ = value;
}

// bytes data = 2;
inline void Packet::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Packet::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Packet.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Packet::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Packet.data)
}
inline std::string* Packet::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:common.Packet.data)
  return _s;
}
inline const std::string& Packet::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void Packet::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Packet::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Packet::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Packet.data)
  return _impl_.data_.Release();
}
inline void Packet::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Packet.data)
}

// .common.DynamicVerifier sender = 4;
inline bool Packet::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sender_ != nullptr);
  return value;
}
inline const ::common::DynamicVerifier& Packet::_internal_sender() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::DynamicVerifier* p = _impl_.sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::DynamicVerifier&>(::common::_DynamicVerifier_default_instance_);
}
inline const ::common::DynamicVerifier& Packet::sender() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Packet.sender)
  return _internal_sender();
}
inline void Packet::unsafe_arena_set_allocated_sender(::common::DynamicVerifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sender_);
  }
  _impl_.sender_ = reinterpret_cast<::common::DynamicVerifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Packet.sender)
}
inline ::common::DynamicVerifier* Packet::release_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::DynamicVerifier* released = _impl_.sender_;
  _impl_.sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::DynamicVerifier* Packet::unsafe_arena_release_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Packet.sender)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::DynamicVerifier* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
  return temp;
}
inline ::common::DynamicVerifier* Packet::_internal_mutable_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sender_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::DynamicVerifier>(GetArena());
    _impl_.sender_ = reinterpret_cast<::common::DynamicVerifier*>(p);
  }
  return _impl_.sender_;
}
inline ::common::DynamicVerifier* Packet::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::DynamicVerifier* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:common.Packet.sender)
  return _msg;
}
inline void Packet::set_allocated_sender(::common::DynamicVerifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sender_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sender_ = reinterpret_cast<::common::DynamicVerifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.Packet.sender)
}

// .common.DynamicVerifier recipient = 5;
inline bool Packet::has_recipient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recipient_ != nullptr);
  return value;
}
inline const ::common::DynamicVerifier& Packet::_internal_recipient() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::DynamicVerifier* p = _impl_.recipient_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::DynamicVerifier&>(::common::_DynamicVerifier_default_instance_);
}
inline const ::common::DynamicVerifier& Packet::recipient() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Packet.recipient)
  return _internal_recipient();
}
inline void Packet::unsafe_arena_set_allocated_recipient(::common::DynamicVerifier* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.recipient_);
  }
  _impl_.recipient_ = reinterpret_cast<::common::DynamicVerifier*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Packet.recipient)
}
inline ::common::DynamicVerifier* Packet::release_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::common::DynamicVerifier* released = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::DynamicVerifier* Packet::unsafe_arena_release_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Packet.recipient)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::common::DynamicVerifier* temp = _impl_.recipient_;
  _impl_.recipient_ = nullptr;
  return temp;
}
inline ::common::DynamicVerifier* Packet::_internal_mutable_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.recipient_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::DynamicVerifier>(GetArena());
    _impl_.recipient_ = reinterpret_cast<::common::DynamicVerifier*>(p);
  }
  return _impl_.recipient_;
}
inline ::common::DynamicVerifier* Packet::mutable_recipient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::common::DynamicVerifier* _msg = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:common.Packet.recipient)
  return _msg;
}
inline void Packet::set_allocated_recipient(::common::DynamicVerifier* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.recipient_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.recipient_ = reinterpret_cast<::common::DynamicVerifier*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.Packet.recipient)
}

// bytes nonce = 6;
inline void Packet::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& Packet::nonce() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Packet.nonce)
  return _internal_nonce();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Packet::set_nonce(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Packet.nonce)
}
inline std::string* Packet::mutable_nonce() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:common.Packet.nonce)
  return _s;
}
inline const std::string& Packet::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_.Get();
}
inline void Packet::_internal_set_nonce(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_.Set(value, GetArena());
}
inline std::string* Packet::_internal_mutable_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nonce_.Mutable( GetArena());
}
inline std::string* Packet::release_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Packet.nonce)
  return _impl_.nonce_.Release();
}
inline void Packet::set_allocated_nonce(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nonce_.IsDefault()) {
          _impl_.nonce_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Packet.nonce)
}

// .common.TransactionHeader transaction_header = 7;
inline bool Packet::has_transaction_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transaction_header_ != nullptr);
  return value;
}
inline void Packet::clear_transaction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_header_ != nullptr) _impl_.transaction_header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::common::TransactionHeader& Packet::_internal_transaction_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::TransactionHeader* p = _impl_.transaction_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::TransactionHeader&>(::common::_TransactionHeader_default_instance_);
}
inline const ::common::TransactionHeader& Packet::transaction_header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Packet.transaction_header)
  return _internal_transaction_header();
}
inline void Packet::unsafe_arena_set_allocated_transaction_header(::common::TransactionHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transaction_header_);
  }
  _impl_.transaction_header_ = reinterpret_cast<::common::TransactionHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Packet.transaction_header)
}
inline ::common::TransactionHeader* Packet::release_transaction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::common::TransactionHeader* released = _impl_.transaction_header_;
  _impl_.transaction_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::TransactionHeader* Packet::unsafe_arena_release_transaction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Packet.transaction_header)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::common::TransactionHeader* temp = _impl_.transaction_header_;
  _impl_.transaction_header_ = nullptr;
  return temp;
}
inline ::common::TransactionHeader* Packet::_internal_mutable_transaction_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.transaction_header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::TransactionHeader>(GetArena());
    _impl_.transaction_header_ = reinterpret_cast<::common::TransactionHeader*>(p);
  }
  return _impl_.transaction_header_;
}
inline ::common::TransactionHeader* Packet::mutable_transaction_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::common::TransactionHeader* _msg = _internal_mutable_transaction_header();
  // @@protoc_insertion_point(field_mutable:common.Packet.transaction_header)
  return _msg;
}
inline void Packet::set_allocated_transaction_header(::common::TransactionHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.transaction_header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transaction_header_ = reinterpret_cast<::common::TransactionHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.Packet.transaction_header)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TransactionHeader

// string uetr = 1;
inline void TransactionHeader::clear_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.ClearToEmpty();
}
inline const std::string& TransactionHeader::uetr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.TransactionHeader.uetr)
  return _internal_uetr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransactionHeader::set_uetr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.TransactionHeader.uetr)
}
inline std::string* TransactionHeader::mutable_uetr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uetr();
  // @@protoc_insertion_point(field_mutable:common.TransactionHeader.uetr)
  return _s;
}
inline const std::string& TransactionHeader::_internal_uetr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uetr_.Get();
}
inline void TransactionHeader::_internal_set_uetr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.Set(value, GetArena());
}
inline std::string* TransactionHeader::_internal_mutable_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uetr_.Mutable( GetArena());
}
inline std::string* TransactionHeader::release_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.TransactionHeader.uetr)
  return _impl_.uetr_.Release();
}
inline void TransactionHeader::set_allocated_uetr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uetr_.IsDefault()) {
          _impl_.uetr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.TransactionHeader.uetr)
}

// string urn = 2;
inline void TransactionHeader::clear_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.ClearToEmpty();
}
inline const std::string& TransactionHeader::urn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.TransactionHeader.urn)
  return _internal_urn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransactionHeader::set_urn(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.TransactionHeader.urn)
}
inline std::string* TransactionHeader::mutable_urn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_urn();
  // @@protoc_insertion_point(field_mutable:common.TransactionHeader.urn)
  return _s;
}
inline const std::string& TransactionHeader::_internal_urn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urn_.Get();
}
inline void TransactionHeader::_internal_set_urn(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.Set(value, GetArena());
}
inline std::string* TransactionHeader::_internal_mutable_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.urn_.Mutable( GetArena());
}
inline std::string* TransactionHeader::release_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.TransactionHeader.urn)
  return _impl_.urn_.Release();
}
inline void TransactionHeader::set_allocated_urn(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.urn_.IsDefault()) {
          _impl_.urn_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.TransactionHeader.urn)
}

// string memo = 3;
inline void TransactionHeader::clear_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& TransactionHeader::memo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.TransactionHeader.memo)
  return _internal_memo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransactionHeader::set_memo(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.TransactionHeader.memo)
}
inline std::string* TransactionHeader::mutable_memo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:common.TransactionHeader.memo)
  return _s;
}
inline const std::string& TransactionHeader::_internal_memo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memo_.Get();
}
inline void TransactionHeader::_internal_set_memo(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.Set(value, GetArena());
}
inline std::string* TransactionHeader::_internal_mutable_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.memo_.Mutable( GetArena());
}
inline std::string* TransactionHeader::release_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.TransactionHeader.memo)
  return _impl_.memo_.Release();
}
inline void TransactionHeader::set_allocated_memo(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memo_.IsDefault()) {
          _impl_.memo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.TransactionHeader.memo)
}

// uint64 timestamp = 4;
inline void TransactionHeader::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t TransactionHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:common.TransactionHeader.timestamp)
  return _internal_timestamp();
}
inline void TransactionHeader::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:common.TransactionHeader.timestamp)
}
inline ::uint64_t TransactionHeader::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void TransactionHeader::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// repeated string related_uetrs = 5;
inline int TransactionHeader::_internal_related_uetrs_size() const {
  return _internal_related_uetrs().size();
}
inline int TransactionHeader::related_uetrs_size() const {
  return _internal_related_uetrs_size();
}
inline void TransactionHeader::clear_related_uetrs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.related_uetrs_.Clear();
}
inline std::string* TransactionHeader::add_related_uetrs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_related_uetrs()->Add();
  // @@protoc_insertion_point(field_add_mutable:common.TransactionHeader.related_uetrs)
  return _s;
}
inline const std::string& TransactionHeader::related_uetrs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.TransactionHeader.related_uetrs)
  return _internal_related_uetrs().Get(index);
}
inline std::string* TransactionHeader::mutable_related_uetrs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:common.TransactionHeader.related_uetrs)
  return _internal_mutable_related_uetrs()->Mutable(index);
}
inline void TransactionHeader::set_related_uetrs(int index, const std::string& value) {
  _internal_mutable_related_uetrs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::set_related_uetrs(int index, std::string&& value) {
  _internal_mutable_related_uetrs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::set_related_uetrs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_related_uetrs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::set_related_uetrs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_related_uetrs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::set_related_uetrs(int index, absl::string_view value) {
  _internal_mutable_related_uetrs()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::add_related_uetrs(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_related_uetrs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::add_related_uetrs(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_related_uetrs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::add_related_uetrs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_related_uetrs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::add_related_uetrs(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_related_uetrs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.TransactionHeader.related_uetrs)
}
inline void TransactionHeader::add_related_uetrs(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_related_uetrs()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:common.TransactionHeader.related_uetrs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TransactionHeader::related_uetrs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:common.TransactionHeader.related_uetrs)
  return _internal_related_uetrs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TransactionHeader::mutable_related_uetrs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:common.TransactionHeader.related_uetrs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_related_uetrs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TransactionHeader::_internal_related_uetrs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.related_uetrs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TransactionHeader::_internal_mutable_related_uetrs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.related_uetrs_;
}

// map<string, string> metadata = 6;
inline int TransactionHeader::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int TransactionHeader::metadata_size() const {
  return _internal_metadata_size();
}
inline void TransactionHeader::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& TransactionHeader::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& TransactionHeader::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:common.TransactionHeader.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<std::string, std::string>* TransactionHeader::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* TransactionHeader::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:common.TransactionHeader.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// BatchedPromissory

// repeated bytes promissory_batch = 1;
inline int BatchedPromissory::_internal_promissory_batch_size() const {
  return _internal_promissory_batch().size();
}
inline int BatchedPromissory::promissory_batch_size() const {
  return _internal_promissory_batch_size();
}
inline void BatchedPromissory::clear_promissory_batch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.promissory_batch_.Clear();
}
inline std::string* BatchedPromissory::add_promissory_batch()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_promissory_batch()->Add();
  // @@protoc_insertion_point(field_add_mutable:common.BatchedPromissory.promissory_batch)
  return _s;
}
inline const std::string& BatchedPromissory::promissory_batch(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.BatchedPromissory.promissory_batch)
  return _internal_promissory_batch().Get(index);
}
inline std::string* BatchedPromissory::mutable_promissory_batch(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:common.BatchedPromissory.promissory_batch)
  return _internal_mutable_promissory_batch()->Mutable(index);
}
inline void BatchedPromissory::set_promissory_batch(int index, const std::string& value) {
  _internal_mutable_promissory_batch()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::set_promissory_batch(int index, std::string&& value) {
  _internal_mutable_promissory_batch()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::set_promissory_batch(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_promissory_batch()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::set_promissory_batch(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_promissory_batch()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::set_promissory_batch(int index, absl::string_view value) {
  _internal_mutable_promissory_batch()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::add_promissory_batch(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_promissory_batch()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::add_promissory_batch(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_promissory_batch()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::add_promissory_batch(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_promissory_batch()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::add_promissory_batch(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_promissory_batch()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.BatchedPromissory.promissory_batch)
}
inline void BatchedPromissory::add_promissory_batch(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_promissory_batch()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:common.BatchedPromissory.promissory_batch)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BatchedPromissory::promissory_batch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:common.BatchedPromissory.promissory_batch)
  return _internal_promissory_batch();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BatchedPromissory::mutable_promissory_batch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:common.BatchedPromissory.promissory_batch)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_promissory_batch();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BatchedPromissory::_internal_promissory_batch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.promissory_batch_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BatchedPromissory::_internal_mutable_promissory_batch() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.promissory_batch_;
}

// -------------------------------------------------------------------

// SimplePaymentRequest

// .common.Amount amount = 1;
inline bool SimplePaymentRequest::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::common::Amount& SimplePaymentRequest::_internal_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& SimplePaymentRequest::amount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.SimplePaymentRequest.amount)
  return _internal_amount();
}
inline void SimplePaymentRequest::unsafe_arena_set_allocated_amount(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.SimplePaymentRequest.amount)
}
inline ::common::Amount* SimplePaymentRequest::release_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* released = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* SimplePaymentRequest::unsafe_arena_release_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.SimplePaymentRequest.amount)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::common::Amount* SimplePaymentRequest::_internal_mutable_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amount_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.amount_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.amount_;
}
inline ::common::Amount* SimplePaymentRequest::mutable_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Amount* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:common.SimplePaymentRequest.amount)
  return _msg;
}
inline void SimplePaymentRequest::set_allocated_amount(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.amount_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.SimplePaymentRequest.amount)
}

// -------------------------------------------------------------------

// SimplePaymentAck

// -------------------------------------------------------------------

// SimplePaymentNack

// .common.SimplePaymentNack.RejectionReason rejection_reason = 1;
inline void SimplePaymentNack::clear_rejection_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = 0;
}
inline ::common::SimplePaymentNack_RejectionReason SimplePaymentNack::rejection_reason() const {
  // @@protoc_insertion_point(field_get:common.SimplePaymentNack.rejection_reason)
  return _internal_rejection_reason();
}
inline void SimplePaymentNack::set_rejection_reason(::common::SimplePaymentNack_RejectionReason value) {
  _internal_set_rejection_reason(value);
  // @@protoc_insertion_point(field_set:common.SimplePaymentNack.rejection_reason)
}
inline ::common::SimplePaymentNack_RejectionReason SimplePaymentNack::_internal_rejection_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::common::SimplePaymentNack_RejectionReason>(_impl_.rejection_reason_);
}
inline void SimplePaymentNack::_internal_set_rejection_reason(::common::SimplePaymentNack_RejectionReason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = value;
}

// string other = 2;
inline void SimplePaymentNack::clear_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.ClearToEmpty();
}
inline const std::string& SimplePaymentNack::other() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.SimplePaymentNack.other)
  return _internal_other();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimplePaymentNack::set_other(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.SimplePaymentNack.other)
}
inline std::string* SimplePaymentNack::mutable_other() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:common.SimplePaymentNack.other)
  return _s;
}
inline const std::string& SimplePaymentNack::_internal_other() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_.Get();
}
inline void SimplePaymentNack::_internal_set_other(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(value, GetArena());
}
inline std::string* SimplePaymentNack::_internal_mutable_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.other_.Mutable( GetArena());
}
inline std::string* SimplePaymentNack::release_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.SimplePaymentNack.other)
  return _impl_.other_.Release();
}
inline void SimplePaymentNack::set_allocated_other(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.other_.IsDefault()) {
          _impl_.other_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.SimplePaymentNack.other)
}

// -------------------------------------------------------------------

// SimplePaymentResponse

// .common.Amount received_amount = 1;
inline bool SimplePaymentResponse::has_received_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.received_amount_ != nullptr);
  return value;
}
inline const ::common::Amount& SimplePaymentResponse::_internal_received_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.received_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& SimplePaymentResponse::received_amount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.SimplePaymentResponse.received_amount)
  return _internal_received_amount();
}
inline void SimplePaymentResponse::unsafe_arena_set_allocated_received_amount(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.received_amount_);
  }
  _impl_.received_amount_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.SimplePaymentResponse.received_amount)
}
inline ::common::Amount* SimplePaymentResponse::release_received_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* released = _impl_.received_amount_;
  _impl_.received_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* SimplePaymentResponse::unsafe_arena_release_received_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.SimplePaymentResponse.received_amount)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* temp = _impl_.received_amount_;
  _impl_.received_amount_ = nullptr;
  return temp;
}
inline ::common::Amount* SimplePaymentResponse::_internal_mutable_received_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.received_amount_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.received_amount_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.received_amount_;
}
inline ::common::Amount* SimplePaymentResponse::mutable_received_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Amount* _msg = _internal_mutable_received_amount();
  // @@protoc_insertion_point(field_mutable:common.SimplePaymentResponse.received_amount)
  return _msg;
}
inline void SimplePaymentResponse::set_allocated_received_amount(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.received_amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.received_amount_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.SimplePaymentResponse.received_amount)
}

// repeated string received_promissories = 2;
inline int SimplePaymentResponse::_internal_received_promissories_size() const {
  return _internal_received_promissories().size();
}
inline int SimplePaymentResponse::received_promissories_size() const {
  return _internal_received_promissories_size();
}
inline void SimplePaymentResponse::clear_received_promissories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.received_promissories_.Clear();
}
inline std::string* SimplePaymentResponse::add_received_promissories()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_received_promissories()->Add();
  // @@protoc_insertion_point(field_add_mutable:common.SimplePaymentResponse.received_promissories)
  return _s;
}
inline const std::string& SimplePaymentResponse::received_promissories(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.SimplePaymentResponse.received_promissories)
  return _internal_received_promissories().Get(index);
}
inline std::string* SimplePaymentResponse::mutable_received_promissories(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:common.SimplePaymentResponse.received_promissories)
  return _internal_mutable_received_promissories()->Mutable(index);
}
inline void SimplePaymentResponse::set_received_promissories(int index, const std::string& value) {
  _internal_mutable_received_promissories()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::set_received_promissories(int index, std::string&& value) {
  _internal_mutable_received_promissories()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::set_received_promissories(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_received_promissories()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::set_received_promissories(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_received_promissories()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::set_received_promissories(int index, absl::string_view value) {
  _internal_mutable_received_promissories()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::add_received_promissories(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_received_promissories()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::add_received_promissories(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_received_promissories()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::add_received_promissories(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_received_promissories()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::add_received_promissories(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_received_promissories()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.SimplePaymentResponse.received_promissories)
}
inline void SimplePaymentResponse::add_received_promissories(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_received_promissories()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:common.SimplePaymentResponse.received_promissories)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SimplePaymentResponse::received_promissories() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:common.SimplePaymentResponse.received_promissories)
  return _internal_received_promissories();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SimplePaymentResponse::mutable_received_promissories() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:common.SimplePaymentResponse.received_promissories)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_received_promissories();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SimplePaymentResponse::_internal_received_promissories() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.received_promissories_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SimplePaymentResponse::_internal_mutable_received_promissories() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.received_promissories_;
}

// -------------------------------------------------------------------

// FundsChangeRequest

// .common.Amount gross_amount = 1;
inline bool FundsChangeRequest::has_gross_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gross_amount_ != nullptr);
  return value;
}
inline const ::common::Amount& FundsChangeRequest::_internal_gross_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.gross_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& FundsChangeRequest::gross_amount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.FundsChangeRequest.gross_amount)
  return _internal_gross_amount();
}
inline void FundsChangeRequest::unsafe_arena_set_allocated_gross_amount(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gross_amount_);
  }
  _impl_.gross_amount_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.FundsChangeRequest.gross_amount)
}
inline ::common::Amount* FundsChangeRequest::release_gross_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* released = _impl_.gross_amount_;
  _impl_.gross_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* FundsChangeRequest::unsafe_arena_release_gross_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.FundsChangeRequest.gross_amount)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* temp = _impl_.gross_amount_;
  _impl_.gross_amount_ = nullptr;
  return temp;
}
inline ::common::Amount* FundsChangeRequest::_internal_mutable_gross_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gross_amount_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.gross_amount_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.gross_amount_;
}
inline ::common::Amount* FundsChangeRequest::mutable_gross_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Amount* _msg = _internal_mutable_gross_amount();
  // @@protoc_insertion_point(field_mutable:common.FundsChangeRequest.gross_amount)
  return _msg;
}
inline void FundsChangeRequest::set_allocated_gross_amount(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gross_amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.gross_amount_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.FundsChangeRequest.gross_amount)
}

// .common.Amount exact_amount = 2;
inline bool FundsChangeRequest::has_exact_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exact_amount_ != nullptr);
  return value;
}
inline const ::common::Amount& FundsChangeRequest::_internal_exact_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.exact_amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& FundsChangeRequest::exact_amount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.FundsChangeRequest.exact_amount)
  return _internal_exact_amount();
}
inline void FundsChangeRequest::unsafe_arena_set_allocated_exact_amount(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exact_amount_);
  }
  _impl_.exact_amount_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.FundsChangeRequest.exact_amount)
}
inline ::common::Amount* FundsChangeRequest::release_exact_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::common::Amount* released = _impl_.exact_amount_;
  _impl_.exact_amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* FundsChangeRequest::unsafe_arena_release_exact_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.FundsChangeRequest.exact_amount)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::common::Amount* temp = _impl_.exact_amount_;
  _impl_.exact_amount_ = nullptr;
  return temp;
}
inline ::common::Amount* FundsChangeRequest::_internal_mutable_exact_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exact_amount_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.exact_amount_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.exact_amount_;
}
inline ::common::Amount* FundsChangeRequest::mutable_exact_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::common::Amount* _msg = _internal_mutable_exact_amount();
  // @@protoc_insertion_point(field_mutable:common.FundsChangeRequest.exact_amount)
  return _msg;
}
inline void FundsChangeRequest::set_allocated_exact_amount(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exact_amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.exact_amount_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.FundsChangeRequest.exact_amount)
}

// .common.Amount fees = 3;
inline bool FundsChangeRequest::has_fees() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fees_ != nullptr);
  return value;
}
inline const ::common::Amount& FundsChangeRequest::_internal_fees() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& FundsChangeRequest::fees() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.FundsChangeRequest.fees)
  return _internal_fees();
}
inline void FundsChangeRequest::unsafe_arena_set_allocated_fees(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fees_);
  }
  _impl_.fees_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.FundsChangeRequest.fees)
}
inline ::common::Amount* FundsChangeRequest::release_fees() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::common::Amount* released = _impl_.fees_;
  _impl_.fees_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* FundsChangeRequest::unsafe_arena_release_fees() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.FundsChangeRequest.fees)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::common::Amount* temp = _impl_.fees_;
  _impl_.fees_ = nullptr;
  return temp;
}
inline ::common::Amount* FundsChangeRequest::_internal_mutable_fees() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fees_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.fees_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.fees_;
}
inline ::common::Amount* FundsChangeRequest::mutable_fees() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::common::Amount* _msg = _internal_mutable_fees();
  // @@protoc_insertion_point(field_mutable:common.FundsChangeRequest.fees)
  return _msg;
}
inline void FundsChangeRequest::set_allocated_fees(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fees_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.fees_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.FundsChangeRequest.fees)
}

// -------------------------------------------------------------------

// FundsChangeAck

// -------------------------------------------------------------------

// FundsChangeNack

// .common.FundsChangeNack.RejectionReason rejection_reason = 1;
inline void FundsChangeNack::clear_rejection_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = 0;
}
inline ::common::FundsChangeNack_RejectionReason FundsChangeNack::rejection_reason() const {
  // @@protoc_insertion_point(field_get:common.FundsChangeNack.rejection_reason)
  return _internal_rejection_reason();
}
inline void FundsChangeNack::set_rejection_reason(::common::FundsChangeNack_RejectionReason value) {
  _internal_set_rejection_reason(value);
  // @@protoc_insertion_point(field_set:common.FundsChangeNack.rejection_reason)
}
inline ::common::FundsChangeNack_RejectionReason FundsChangeNack::_internal_rejection_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::common::FundsChangeNack_RejectionReason>(_impl_.rejection_reason_);
}
inline void FundsChangeNack::_internal_set_rejection_reason(::common::FundsChangeNack_RejectionReason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = value;
}

// string other = 2;
inline void FundsChangeNack::clear_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.ClearToEmpty();
}
inline const std::string& FundsChangeNack::other() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.FundsChangeNack.other)
  return _internal_other();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundsChangeNack::set_other(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.FundsChangeNack.other)
}
inline std::string* FundsChangeNack::mutable_other() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:common.FundsChangeNack.other)
  return _s;
}
inline const std::string& FundsChangeNack::_internal_other() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_.Get();
}
inline void FundsChangeNack::_internal_set_other(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(value, GetArena());
}
inline std::string* FundsChangeNack::_internal_mutable_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.other_.Mutable( GetArena());
}
inline std::string* FundsChangeNack::release_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.FundsChangeNack.other)
  return _impl_.other_.Release();
}
inline void FundsChangeNack::set_allocated_other(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.other_.IsDefault()) {
          _impl_.other_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.FundsChangeNack.other)
}

// -------------------------------------------------------------------

// CancelTransaction

// .common.CancelTransaction.RejectionReason rejection_reason = 1;
inline void CancelTransaction::clear_rejection_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = 0;
}
inline ::common::CancelTransaction_RejectionReason CancelTransaction::rejection_reason() const {
  // @@protoc_insertion_point(field_get:common.CancelTransaction.rejection_reason)
  return _internal_rejection_reason();
}
inline void CancelTransaction::set_rejection_reason(::common::CancelTransaction_RejectionReason value) {
  _internal_set_rejection_reason(value);
  // @@protoc_insertion_point(field_set:common.CancelTransaction.rejection_reason)
}
inline ::common::CancelTransaction_RejectionReason CancelTransaction::_internal_rejection_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::common::CancelTransaction_RejectionReason>(_impl_.rejection_reason_);
}
inline void CancelTransaction::_internal_set_rejection_reason(::common::CancelTransaction_RejectionReason value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rejection_reason_ = value;
}

// string other = 2;
inline void CancelTransaction::clear_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.ClearToEmpty();
}
inline const std::string& CancelTransaction::other() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.CancelTransaction.other)
  return _internal_other();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CancelTransaction::set_other(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.CancelTransaction.other)
}
inline std::string* CancelTransaction::mutable_other() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_other();
  // @@protoc_insertion_point(field_mutable:common.CancelTransaction.other)
  return _s;
}
inline const std::string& CancelTransaction::_internal_other() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_.Get();
}
inline void CancelTransaction::_internal_set_other(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.Set(value, GetArena());
}
inline std::string* CancelTransaction::_internal_mutable_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.other_.Mutable( GetArena());
}
inline std::string* CancelTransaction::release_other() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.CancelTransaction.other)
  return _impl_.other_.Release();
}
inline void CancelTransaction::set_allocated_other(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.other_.IsDefault()) {
          _impl_.other_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.CancelTransaction.other)
}

// -------------------------------------------------------------------

// Commitment

// string sender = 1;
inline void Commitment::clear_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& Commitment::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Commitment.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Commitment::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Commitment.sender)
}
inline std::string* Commitment::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:common.Commitment.sender)
  return _s;
}
inline const std::string& Commitment::_internal_sender() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sender_.Get();
}
inline void Commitment::_internal_set_sender(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* Commitment::_internal_mutable_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* Commitment::release_sender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Commitment.sender)
  return _impl_.sender_.Release();
}
inline void Commitment::set_allocated_sender(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Commitment.sender)
}

// string recipient = 2;
inline void Commitment::clear_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_.ClearToEmpty();
}
inline const std::string& Commitment::recipient() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Commitment.recipient)
  return _internal_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Commitment::set_recipient(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Commitment.recipient)
}
inline std::string* Commitment::mutable_recipient() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient();
  // @@protoc_insertion_point(field_mutable:common.Commitment.recipient)
  return _s;
}
inline const std::string& Commitment::_internal_recipient() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recipient_.Get();
}
inline void Commitment::_internal_set_recipient(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_.Set(value, GetArena());
}
inline std::string* Commitment::_internal_mutable_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recipient_.Mutable( GetArena());
}
inline std::string* Commitment::release_recipient() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Commitment.recipient)
  return _impl_.recipient_.Release();
}
inline void Commitment::set_allocated_recipient(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_.IsDefault()) {
          _impl_.recipient_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Commitment.recipient)
}

// .common.Amount amount = 3;
inline bool Commitment::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline const ::common::Amount& Commitment::_internal_amount() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Amount* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Amount&>(::common::_Amount_default_instance_);
}
inline const ::common::Amount& Commitment::amount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Commitment.amount)
  return _internal_amount();
}
inline void Commitment::unsafe_arena_set_allocated_amount(::common::Amount* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = reinterpret_cast<::common::Amount*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Commitment.amount)
}
inline ::common::Amount* Commitment::release_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* released = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Amount* Commitment::unsafe_arena_release_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Commitment.amount)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Amount* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::common::Amount* Commitment::_internal_mutable_amount() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amount_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Amount>(GetArena());
    _impl_.amount_ = reinterpret_cast<::common::Amount*>(p);
  }
  return _impl_.amount_;
}
inline ::common::Amount* Commitment::mutable_amount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Amount* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:common.Commitment.amount)
  return _msg;
}
inline void Commitment::set_allocated_amount(::common::Amount* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amount_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.amount_ = reinterpret_cast<::common::Amount*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.Commitment.amount)
}

// -------------------------------------------------------------------

// TimeoutCondition

// uint64 timeout = 1;
inline void TimeoutCondition::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = ::uint64_t{0u};
}
inline ::uint64_t TimeoutCondition::timeout() const {
  // @@protoc_insertion_point(field_get:common.TimeoutCondition.timeout)
  return _internal_timeout();
}
inline void TimeoutCondition::set_timeout(::uint64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:common.TimeoutCondition.timeout)
}
inline ::uint64_t TimeoutCondition::_internal_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timeout_;
}
inline void TimeoutCondition::_internal_set_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timeout_ = value;
}

// -------------------------------------------------------------------

// HashCondition

// string presenter = 1;
inline void HashCondition::clear_presenter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.presenter_.ClearToEmpty();
}
inline const std::string& HashCondition::presenter() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.HashCondition.presenter)
  return _internal_presenter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashCondition::set_presenter(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.presenter_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.HashCondition.presenter)
}
inline std::string* HashCondition::mutable_presenter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_presenter();
  // @@protoc_insertion_point(field_mutable:common.HashCondition.presenter)
  return _s;
}
inline const std::string& HashCondition::_internal_presenter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.presenter_.Get();
}
inline void HashCondition::_internal_set_presenter(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.presenter_.Set(value, GetArena());
}
inline std::string* HashCondition::_internal_mutable_presenter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.presenter_.Mutable( GetArena());
}
inline std::string* HashCondition::release_presenter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.HashCondition.presenter)
  return _impl_.presenter_.Release();
}
inline void HashCondition::set_allocated_presenter(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.presenter_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.presenter_.IsDefault()) {
          _impl_.presenter_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.HashCondition.presenter)
}

// bytes hash = 2;
inline void HashCondition::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& HashCondition::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.HashCondition.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashCondition::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.HashCondition.hash)
}
inline std::string* HashCondition::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:common.HashCondition.hash)
  return _s;
}
inline const std::string& HashCondition::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void HashCondition::_internal_set_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.Set(value, GetArena());
}
inline std::string* HashCondition::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_.Mutable( GetArena());
}
inline std::string* HashCondition::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.HashCondition.hash)
  return _impl_.hash_.Release();
}
inline void HashCondition::set_allocated_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.HashCondition.hash)
}

// bytes algorithm_oid = 3;
inline void HashCondition::clear_algorithm_oid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_oid_.ClearToEmpty();
}
inline const std::string& HashCondition::algorithm_oid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.HashCondition.algorithm_oid)
  return _internal_algorithm_oid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HashCondition::set_algorithm_oid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_oid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.HashCondition.algorithm_oid)
}
inline std::string* HashCondition::mutable_algorithm_oid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_algorithm_oid();
  // @@protoc_insertion_point(field_mutable:common.HashCondition.algorithm_oid)
  return _s;
}
inline const std::string& HashCondition::_internal_algorithm_oid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.algorithm_oid_.Get();
}
inline void HashCondition::_internal_set_algorithm_oid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_oid_.Set(value, GetArena());
}
inline std::string* HashCondition::_internal_mutable_algorithm_oid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.algorithm_oid_.Mutable( GetArena());
}
inline std::string* HashCondition::release_algorithm_oid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.HashCondition.algorithm_oid)
  return _impl_.algorithm_oid_.Release();
}
inline void HashCondition::set_allocated_algorithm_oid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.algorithm_oid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.algorithm_oid_.IsDefault()) {
          _impl_.algorithm_oid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.HashCondition.algorithm_oid)
}

// -------------------------------------------------------------------

// MintCondition

// string issuer = 1;
inline void MintCondition::clear_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.ClearToEmpty();
}
inline const std::string& MintCondition::issuer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.MintCondition.issuer)
  return _internal_issuer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MintCondition::set_issuer(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.MintCondition.issuer)
}
inline std::string* MintCondition::mutable_issuer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:common.MintCondition.issuer)
  return _s;
}
inline const std::string& MintCondition::_internal_issuer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issuer_.Get();
}
inline void MintCondition::_internal_set_issuer(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.Set(value, GetArena());
}
inline std::string* MintCondition::_internal_mutable_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.issuer_.Mutable( GetArena());
}
inline std::string* MintCondition::release_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.MintCondition.issuer)
  return _impl_.issuer_.Release();
}
inline void MintCondition::set_allocated_issuer(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.issuer_.IsDefault()) {
          _impl_.issuer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.MintCondition.issuer)
}

// .common.Distribution distribution = 2;
inline bool MintCondition::has_distribution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distribution_ != nullptr);
  return value;
}
inline const ::common::Distribution& MintCondition::_internal_distribution() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Distribution* p = _impl_.distribution_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Distribution&>(::common::_Distribution_default_instance_);
}
inline const ::common::Distribution& MintCondition::distribution() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.MintCondition.distribution)
  return _internal_distribution();
}
inline void MintCondition::unsafe_arena_set_allocated_distribution(::common::Distribution* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distribution_);
  }
  _impl_.distribution_ = reinterpret_cast<::common::Distribution*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MintCondition.distribution)
}
inline ::common::Distribution* MintCondition::release_distribution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Distribution* released = _impl_.distribution_;
  _impl_.distribution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Distribution* MintCondition::unsafe_arena_release_distribution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.MintCondition.distribution)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Distribution* temp = _impl_.distribution_;
  _impl_.distribution_ = nullptr;
  return temp;
}
inline ::common::Distribution* MintCondition::_internal_mutable_distribution() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.distribution_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Distribution>(GetArena());
    _impl_.distribution_ = reinterpret_cast<::common::Distribution*>(p);
  }
  return _impl_.distribution_;
}
inline ::common::Distribution* MintCondition::mutable_distribution() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Distribution* _msg = _internal_mutable_distribution();
  // @@protoc_insertion_point(field_mutable:common.MintCondition.distribution)
  return _msg;
}
inline void MintCondition::set_allocated_distribution(::common::Distribution* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distribution_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.distribution_ = reinterpret_cast<::common::Distribution*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.MintCondition.distribution)
}

// -------------------------------------------------------------------

// RedeemCondition

// string issuer = 1;
inline void RedeemCondition::clear_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.ClearToEmpty();
}
inline const std::string& RedeemCondition::issuer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.RedeemCondition.issuer)
  return _internal_issuer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RedeemCondition::set_issuer(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.RedeemCondition.issuer)
}
inline std::string* RedeemCondition::mutable_issuer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:common.RedeemCondition.issuer)
  return _s;
}
inline const std::string& RedeemCondition::_internal_issuer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.issuer_.Get();
}
inline void RedeemCondition::_internal_set_issuer(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.Set(value, GetArena());
}
inline std::string* RedeemCondition::_internal_mutable_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.issuer_.Mutable( GetArena());
}
inline std::string* RedeemCondition::release_issuer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.RedeemCondition.issuer)
  return _impl_.issuer_.Release();
}
inline void RedeemCondition::set_allocated_issuer(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.issuer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.issuer_.IsDefault()) {
          _impl_.issuer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.RedeemCondition.issuer)
}

// -------------------------------------------------------------------

// Condition

// .common.TimeoutCondition timeout = 1;
inline bool Condition::has_timeout() const {
  return condition_case() == kTimeout;
}
inline bool Condition::_internal_has_timeout() const {
  return condition_case() == kTimeout;
}
inline void Condition::set_has_timeout() {
  _impl_._oneof_case_[0] = kTimeout;
}
inline void Condition::clear_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_case() == kTimeout) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_.timeout_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_.timeout_);
    }
    clear_has_condition();
  }
}
inline ::common::TimeoutCondition* Condition::release_timeout() {
  // @@protoc_insertion_point(field_release:common.Condition.timeout)
  if (condition_case() == kTimeout) {
    clear_has_condition();
    auto* temp = _impl_.condition_.timeout_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_.timeout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::TimeoutCondition& Condition::_internal_timeout() const {
  return condition_case() == kTimeout ? *_impl_.condition_.timeout_ : reinterpret_cast<::common::TimeoutCondition&>(::common::_TimeoutCondition_default_instance_);
}
inline const ::common::TimeoutCondition& Condition::timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Condition.timeout)
  return _internal_timeout();
}
inline ::common::TimeoutCondition* Condition::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.Condition.timeout)
  if (condition_case() == kTimeout) {
    clear_has_condition();
    auto* temp = _impl_.condition_.timeout_;
    _impl_.condition_.timeout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_timeout(::common::TimeoutCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition();
  if (value) {
    set_has_timeout();
    _impl_.condition_.timeout_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Condition.timeout)
}
inline ::common::TimeoutCondition* Condition::_internal_mutable_timeout() {
  if (condition_case() != kTimeout) {
    clear_condition();
    set_has_timeout();
    _impl_.condition_.timeout_ =
        ::google::protobuf::Message::DefaultConstruct<::common::TimeoutCondition>(GetArena());
  }
  return _impl_.condition_.timeout_;
}
inline ::common::TimeoutCondition* Condition::mutable_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::common::TimeoutCondition* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:common.Condition.timeout)
  return _msg;
}

// .common.HashCondition hash = 2;
inline bool Condition::has_hash() const {
  return condition_case() == kHash;
}
inline bool Condition::_internal_has_hash() const {
  return condition_case() == kHash;
}
inline void Condition::set_has_hash() {
  _impl_._oneof_case_[0] = kHash;
}
inline void Condition::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_case() == kHash) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_.hash_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_.hash_);
    }
    clear_has_condition();
  }
}
inline ::common::HashCondition* Condition::release_hash() {
  // @@protoc_insertion_point(field_release:common.Condition.hash)
  if (condition_case() == kHash) {
    clear_has_condition();
    auto* temp = _impl_.condition_.hash_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_.hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::HashCondition& Condition::_internal_hash() const {
  return condition_case() == kHash ? *_impl_.condition_.hash_ : reinterpret_cast<::common::HashCondition&>(::common::_HashCondition_default_instance_);
}
inline const ::common::HashCondition& Condition::hash() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Condition.hash)
  return _internal_hash();
}
inline ::common::HashCondition* Condition::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.Condition.hash)
  if (condition_case() == kHash) {
    clear_has_condition();
    auto* temp = _impl_.condition_.hash_;
    _impl_.condition_.hash_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_hash(::common::HashCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition();
  if (value) {
    set_has_hash();
    _impl_.condition_.hash_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Condition.hash)
}
inline ::common::HashCondition* Condition::_internal_mutable_hash() {
  if (condition_case() != kHash) {
    clear_condition();
    set_has_hash();
    _impl_.condition_.hash_ =
        ::google::protobuf::Message::DefaultConstruct<::common::HashCondition>(GetArena());
  }
  return _impl_.condition_.hash_;
}
inline ::common::HashCondition* Condition::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::common::HashCondition* _msg = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:common.Condition.hash)
  return _msg;
}

// .common.MintCondition mint = 3;
inline bool Condition::has_mint() const {
  return condition_case() == kMint;
}
inline bool Condition::_internal_has_mint() const {
  return condition_case() == kMint;
}
inline void Condition::set_has_mint() {
  _impl_._oneof_case_[0] = kMint;
}
inline void Condition::clear_mint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_case() == kMint) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_.mint_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_.mint_);
    }
    clear_has_condition();
  }
}
inline ::common::MintCondition* Condition::release_mint() {
  // @@protoc_insertion_point(field_release:common.Condition.mint)
  if (condition_case() == kMint) {
    clear_has_condition();
    auto* temp = _impl_.condition_.mint_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_.mint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::MintCondition& Condition::_internal_mint() const {
  return condition_case() == kMint ? *_impl_.condition_.mint_ : reinterpret_cast<::common::MintCondition&>(::common::_MintCondition_default_instance_);
}
inline const ::common::MintCondition& Condition::mint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Condition.mint)
  return _internal_mint();
}
inline ::common::MintCondition* Condition::unsafe_arena_release_mint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.Condition.mint)
  if (condition_case() == kMint) {
    clear_has_condition();
    auto* temp = _impl_.condition_.mint_;
    _impl_.condition_.mint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_mint(::common::MintCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition();
  if (value) {
    set_has_mint();
    _impl_.condition_.mint_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Condition.mint)
}
inline ::common::MintCondition* Condition::_internal_mutable_mint() {
  if (condition_case() != kMint) {
    clear_condition();
    set_has_mint();
    _impl_.condition_.mint_ =
        ::google::protobuf::Message::DefaultConstruct<::common::MintCondition>(GetArena());
  }
  return _impl_.condition_.mint_;
}
inline ::common::MintCondition* Condition::mutable_mint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::common::MintCondition* _msg = _internal_mutable_mint();
  // @@protoc_insertion_point(field_mutable:common.Condition.mint)
  return _msg;
}

// .common.RedeemCondition redeem = 4;
inline bool Condition::has_redeem() const {
  return condition_case() == kRedeem;
}
inline bool Condition::_internal_has_redeem() const {
  return condition_case() == kRedeem;
}
inline void Condition::set_has_redeem() {
  _impl_._oneof_case_[0] = kRedeem;
}
inline void Condition::clear_redeem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (condition_case() == kRedeem) {
    if (GetArena() == nullptr) {
      delete _impl_.condition_.redeem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.condition_.redeem_);
    }
    clear_has_condition();
  }
}
inline ::common::RedeemCondition* Condition::release_redeem() {
  // @@protoc_insertion_point(field_release:common.Condition.redeem)
  if (condition_case() == kRedeem) {
    clear_has_condition();
    auto* temp = _impl_.condition_.redeem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.condition_.redeem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::RedeemCondition& Condition::_internal_redeem() const {
  return condition_case() == kRedeem ? *_impl_.condition_.redeem_ : reinterpret_cast<::common::RedeemCondition&>(::common::_RedeemCondition_default_instance_);
}
inline const ::common::RedeemCondition& Condition::redeem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Condition.redeem)
  return _internal_redeem();
}
inline ::common::RedeemCondition* Condition::unsafe_arena_release_redeem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.Condition.redeem)
  if (condition_case() == kRedeem) {
    clear_has_condition();
    auto* temp = _impl_.condition_.redeem_;
    _impl_.condition_.redeem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_redeem(::common::RedeemCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_condition();
  if (value) {
    set_has_redeem();
    _impl_.condition_.redeem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.Condition.redeem)
}
inline ::common::RedeemCondition* Condition::_internal_mutable_redeem() {
  if (condition_case() != kRedeem) {
    clear_condition();
    set_has_redeem();
    _impl_.condition_.redeem_ =
        ::google::protobuf::Message::DefaultConstruct<::common::RedeemCondition>(GetArena());
  }
  return _impl_.condition_.redeem_;
}
inline ::common::RedeemCondition* Condition::mutable_redeem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::common::RedeemCondition* _msg = _internal_mutable_redeem();
  // @@protoc_insertion_point(field_mutable:common.Condition.redeem)
  return _msg;
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _impl_._oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Contract

// string urn = 1;
inline void Contract::clear_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.ClearToEmpty();
}
inline const std::string& Contract::urn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Contract.urn)
  return _internal_urn();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contract::set_urn(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Contract.urn)
}
inline std::string* Contract::mutable_urn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_urn();
  // @@protoc_insertion_point(field_mutable:common.Contract.urn)
  return _s;
}
inline const std::string& Contract::_internal_urn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urn_.Get();
}
inline void Contract::_internal_set_urn(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.Set(value, GetArena());
}
inline std::string* Contract::_internal_mutable_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.urn_.Mutable( GetArena());
}
inline std::string* Contract::release_urn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Contract.urn)
  return _impl_.urn_.Release();
}
inline void Contract::set_allocated_urn(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urn_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.urn_.IsDefault()) {
          _impl_.urn_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Contract.urn)
}

// string id = 2;
inline void Contract::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Contract::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Contract.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contract::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Contract.id)
}
inline std::string* Contract::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:common.Contract.id)
  return _s;
}
inline const std::string& Contract::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Contract::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Contract::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Contract::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Contract.id)
  return _impl_.id_.Release();
}
inline void Contract::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Contract.id)
}

// repeated .common.Commitment commitments = 3;
inline int Contract::_internal_commitments_size() const {
  return _internal_commitments().size();
}
inline int Contract::commitments_size() const {
  return _internal_commitments_size();
}
inline void Contract::clear_commitments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.commitments_.Clear();
}
inline ::common::Commitment* Contract::mutable_commitments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:common.Contract.commitments)
  return _internal_mutable_commitments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::common::Commitment>* Contract::mutable_commitments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:common.Contract.commitments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_commitments();
}
inline const ::common::Commitment& Contract::commitments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Contract.commitments)
  return _internal_commitments().Get(index);
}
inline ::common::Commitment* Contract::add_commitments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::common::Commitment* _add = _internal_mutable_commitments()->Add();
  // @@protoc_insertion_point(field_add:common.Contract.commitments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::common::Commitment>& Contract::commitments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:common.Contract.commitments)
  return _internal_commitments();
}
inline const ::google::protobuf::RepeatedPtrField<::common::Commitment>&
Contract::_internal_commitments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.commitments_;
}
inline ::google::protobuf::RepeatedPtrField<::common::Commitment>*
Contract::_internal_mutable_commitments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.commitments_;
}

// repeated .common.Condition conditions = 4;
inline int Contract::_internal_conditions_size() const {
  return _internal_conditions().size();
}
inline int Contract::conditions_size() const {
  return _internal_conditions_size();
}
inline void Contract::clear_conditions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.conditions_.Clear();
}
inline ::common::Condition* Contract::mutable_conditions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:common.Contract.conditions)
  return _internal_mutable_conditions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::common::Condition>* Contract::mutable_conditions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:common.Contract.conditions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_conditions();
}
inline const ::common::Condition& Contract::conditions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Contract.conditions)
  return _internal_conditions().Get(index);
}
inline ::common::Condition* Contract::add_conditions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::common::Condition* _add = _internal_mutable_conditions()->Add();
  // @@protoc_insertion_point(field_add:common.Contract.conditions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::common::Condition>& Contract::conditions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:common.Contract.conditions)
  return _internal_conditions();
}
inline const ::google::protobuf::RepeatedPtrField<::common::Condition>&
Contract::_internal_conditions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.conditions_;
}
inline ::google::protobuf::RepeatedPtrField<::common::Condition>*
Contract::_internal_mutable_conditions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.conditions_;
}

// map<string, bytes> signatories = 5;
inline int Contract::_internal_signatories_size() const {
  return _internal_signatories().size();
}
inline int Contract::signatories_size() const {
  return _internal_signatories_size();
}
inline void Contract::clear_signatories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatories_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Contract::_internal_signatories() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signatories_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Contract::signatories() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:common.Contract.signatories)
  return _internal_signatories();
}
inline ::google::protobuf::Map<std::string, std::string>* Contract::_internal_mutable_signatories() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signatories_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Contract::mutable_signatories() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:common.Contract.signatories)
  return _internal_mutable_signatories();
}

// string memo = 6;
inline void Contract::clear_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& Contract::memo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.Contract.memo)
  return _internal_memo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contract::set_memo(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.Contract.memo)
}
inline std::string* Contract::mutable_memo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:common.Contract.memo)
  return _s;
}
inline const std::string& Contract::_internal_memo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.memo_.Get();
}
inline void Contract::_internal_set_memo(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.Set(value, GetArena());
}
inline std::string* Contract::_internal_mutable_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.memo_.Mutable( GetArena());
}
inline std::string* Contract::release_memo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.Contract.memo)
  return _impl_.memo_.Release();
}
inline void Contract::set_allocated_memo(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.memo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memo_.IsDefault()) {
          _impl_.memo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.Contract.memo)
}

// -------------------------------------------------------------------

// AssociatedUetrConnection

// string uetr = 1;
inline void AssociatedUetrConnection::clear_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.ClearToEmpty();
}
inline const std::string& AssociatedUetrConnection::uetr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.AssociatedUetrConnection.uetr)
  return _internal_uetr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AssociatedUetrConnection::set_uetr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:common.AssociatedUetrConnection.uetr)
}
inline std::string* AssociatedUetrConnection::mutable_uetr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uetr();
  // @@protoc_insertion_point(field_mutable:common.AssociatedUetrConnection.uetr)
  return _s;
}
inline const std::string& AssociatedUetrConnection::_internal_uetr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uetr_.Get();
}
inline void AssociatedUetrConnection::_internal_set_uetr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.Set(value, GetArena());
}
inline std::string* AssociatedUetrConnection::_internal_mutable_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uetr_.Mutable( GetArena());
}
inline std::string* AssociatedUetrConnection::release_uetr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.AssociatedUetrConnection.uetr)
  return _impl_.uetr_.Release();
}
inline void AssociatedUetrConnection::set_allocated_uetr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uetr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uetr_.IsDefault()) {
          _impl_.uetr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.AssociatedUetrConnection.uetr)
}

// optional .common.Packet packet = 2;
inline bool AssociatedUetrConnection::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_ != nullptr);
  return value;
}
inline void AssociatedUetrConnection::clear_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_ != nullptr) _impl_.packet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::common::Packet& AssociatedUetrConnection::_internal_packet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common::Packet* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::Packet&>(::common::_Packet_default_instance_);
}
inline const ::common::Packet& AssociatedUetrConnection::packet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:common.AssociatedUetrConnection.packet)
  return _internal_packet();
}
inline void AssociatedUetrConnection::unsafe_arena_set_allocated_packet(::common::Packet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = reinterpret_cast<::common::Packet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.AssociatedUetrConnection.packet)
}
inline ::common::Packet* AssociatedUetrConnection::release_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Packet* released = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::common::Packet* AssociatedUetrConnection::unsafe_arena_release_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:common.AssociatedUetrConnection.packet)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::common::Packet* AssociatedUetrConnection::_internal_mutable_packet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.packet_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common::Packet>(GetArena());
    _impl_.packet_ = reinterpret_cast<::common::Packet*>(p);
  }
  return _impl_.packet_;
}
inline ::common::Packet* AssociatedUetrConnection::mutable_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common::Packet* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:common.AssociatedUetrConnection.packet)
  return _msg;
}
inline void AssociatedUetrConnection::set_allocated_packet(::common::Packet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.packet_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.packet_ = reinterpret_cast<::common::Packet*>(value);
  // @@protoc_insertion_point(field_set_allocated:common.AssociatedUetrConnection.packet)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace common


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::common::SimplePaymentNack_RejectionReason> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::SimplePaymentNack_RejectionReason>() {
  return ::common::SimplePaymentNack_RejectionReason_descriptor();
}
template <>
struct is_proto_enum<::common::FundsChangeNack_RejectionReason> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::FundsChangeNack_RejectionReason>() {
  return ::common::FundsChangeNack_RejectionReason_descriptor();
}
template <>
struct is_proto_enum<::common::CancelTransaction_RejectionReason> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::CancelTransaction_RejectionReason>() {
  return ::common::CancelTransaction_RejectionReason_descriptor();
}
template <>
struct is_proto_enum<::common::PacketType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::PacketType>() {
  return ::common::PacketType_descriptor();
}
template <>
struct is_proto_enum<::common::HashAlgorithm> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::HashAlgorithm>() {
  return ::common::HashAlgorithm_descriptor();
}
template <>
struct is_proto_enum<::common::ContractType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::common::ContractType>() {
  return ::common::ContractType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fpacket_2eproto_2epb_2eh
