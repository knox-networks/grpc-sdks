/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.1
 * source: common/v1/packet.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./common";
import * as pb_1 from "google-protobuf";
export namespace common {
    export enum PacketType {
        Unknown = 0,
        Unsupported = 1,
        Authenticate = 2,
        ConnectionAuthenticated = 7,
        ReturnToSender = 3,
        TerminateStream = 4,
        KeepAlive = 5,
        Acknowledgement = 6,
        AddAssociatedConnection = 9,
        DropAssociatedConnection = 10,
        AssociatedConnectionAdded = 11,
        AssociatedConnectionDropped = 12,
        Report = 50,
        Promissory = 100,
        AuthorizePromissory = 101,
        AuthorizeAndForwardPromissory = 102,
        ArchivePromissory = 103,
        PromissoryReceipt = 104,
        AuthorizationStatus = 108,
        RetrieveAssets = 109,
        PromissoryBatch = 110,
        LockPromissoryBatch = 111,
        LockPromissoryBatchAck = 112,
        RetrieveAssetsBatch = 113,
        AuthorizeAndForwardPromissoryBatch = 116,
        ValidationBlockBatch = 117,
        AuthorizedBlockBatch = 118,
        MintPromissory = 119,
        FreshPromissoryBatch = 120,
        MintedPromissoryBatch = 121,
        RedeemValidationBlockBatch = 122,
        IdentityRequest = 200,
        IdentityResponse = 201,
        IdentityProof = 202,
        AuthorizationFailed = 300,
        EmissaryConnectionIdentity = 400,
        ContractProposal = 500,
        ContractProposalAck = 501,
        ContractProposalNack = 502,
        ContractSignature = 503,
        ContractComplete = 504,
        RecoveryData = 600,
        RemittanceRequest = 700,
        RemittanceResponse = 701,
        TxnContract = 1303,
        TxnContractAck = 1304,
        TxnAssetsAuthorized = 1305,
        TxnSecretRequest = 1308,
        TxnSecretPresent = 1309,
        TxnAssetsReturned = 1310,
        TxnRecover = 1311
    }
    export enum HashAlgorithm {
        SHA256 = 0,
        SHA512 = 1,
        SHA3_256 = 2,
        SHA3_512 = 3,
        KECCAK256 = 4,
        KECCAK512 = 5
    }
    export enum ContractType {
        CONTRACT_TYPE_UNSPECIFIED = 0,
        CONTRACT_TYPE_PAYMENT = 1,
        CONTRACT_TYPE_SWAP = 2,
        CONTRACT_TYPE_RELAY = 3,
        CONTRACT_TYPE_CUSTOM = 4,
        CONTRACT_TYPE_MINT = 5,
        CONTRACT_TYPE_REDEEM = 6
    }
    export class Packet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            packet_type?: PacketType;
            data?: Uint8Array;
            sender?: dependency_1.common.DynamicVerifier;
            recipient?: dependency_1.common.DynamicVerifier;
            nonce?: Uint8Array;
            transaction_header?: TransactionHeader;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet_type" in data && data.packet_type != undefined) {
                    this.packet_type = data.packet_type;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("recipient" in data && data.recipient != undefined) {
                    this.recipient = data.recipient;
                }
                if ("nonce" in data && data.nonce != undefined) {
                    this.nonce = data.nonce;
                }
                if ("transaction_header" in data && data.transaction_header != undefined) {
                    this.transaction_header = data.transaction_header;
                }
            }
        }
        get packet_type() {
            return pb_1.Message.getFieldWithDefault(this, 1, PacketType.Unknown) as PacketType;
        }
        set packet_type(value: PacketType) {
            pb_1.Message.setField(this, 1, value);
        }
        get data() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set data(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get sender() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.DynamicVerifier, 4) as dependency_1.common.DynamicVerifier;
        }
        set sender(value: dependency_1.common.DynamicVerifier) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_sender() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get recipient() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.DynamicVerifier, 5) as dependency_1.common.DynamicVerifier;
        }
        set recipient(value: dependency_1.common.DynamicVerifier) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_recipient() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get nonce() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set nonce(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get transaction_header() {
            return pb_1.Message.getWrapperField(this, TransactionHeader, 7) as TransactionHeader;
        }
        set transaction_header(value: TransactionHeader) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get has_transaction_header() {
            return pb_1.Message.getField(this, 7) != null;
        }
        static fromObject(data: {
            packet_type?: PacketType;
            data?: Uint8Array;
            sender?: ReturnType<typeof dependency_1.common.DynamicVerifier.prototype.toObject>;
            recipient?: ReturnType<typeof dependency_1.common.DynamicVerifier.prototype.toObject>;
            nonce?: Uint8Array;
            transaction_header?: ReturnType<typeof TransactionHeader.prototype.toObject>;
        }): Packet {
            const message = new Packet({});
            if (data.packet_type != null) {
                message.packet_type = data.packet_type;
            }
            if (data.data != null) {
                message.data = data.data;
            }
            if (data.sender != null) {
                message.sender = dependency_1.common.DynamicVerifier.fromObject(data.sender);
            }
            if (data.recipient != null) {
                message.recipient = dependency_1.common.DynamicVerifier.fromObject(data.recipient);
            }
            if (data.nonce != null) {
                message.nonce = data.nonce;
            }
            if (data.transaction_header != null) {
                message.transaction_header = TransactionHeader.fromObject(data.transaction_header);
            }
            return message;
        }
        toObject() {
            const data: {
                packet_type?: PacketType;
                data?: Uint8Array;
                sender?: ReturnType<typeof dependency_1.common.DynamicVerifier.prototype.toObject>;
                recipient?: ReturnType<typeof dependency_1.common.DynamicVerifier.prototype.toObject>;
                nonce?: Uint8Array;
                transaction_header?: ReturnType<typeof TransactionHeader.prototype.toObject>;
            } = {};
            if (this.packet_type != null) {
                data.packet_type = this.packet_type;
            }
            if (this.data != null) {
                data.data = this.data;
            }
            if (this.sender != null) {
                data.sender = this.sender.toObject();
            }
            if (this.recipient != null) {
                data.recipient = this.recipient.toObject();
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            if (this.transaction_header != null) {
                data.transaction_header = this.transaction_header.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet_type != PacketType.Unknown)
                writer.writeEnum(1, this.packet_type);
            if (this.data.length)
                writer.writeBytes(2, this.data);
            if (this.has_sender)
                writer.writeMessage(4, this.sender, () => this.sender.serialize(writer));
            if (this.has_recipient)
                writer.writeMessage(5, this.recipient, () => this.recipient.serialize(writer));
            if (this.nonce.length)
                writer.writeBytes(6, this.nonce);
            if (this.has_transaction_header)
                writer.writeMessage(7, this.transaction_header, () => this.transaction_header.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Packet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Packet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.packet_type = reader.readEnum();
                        break;
                    case 2:
                        message.data = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.sender, () => message.sender = dependency_1.common.DynamicVerifier.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.recipient, () => message.recipient = dependency_1.common.DynamicVerifier.deserialize(reader));
                        break;
                    case 6:
                        message.nonce = reader.readBytes();
                        break;
                    case 7:
                        reader.readMessage(message.transaction_header, () => message.transaction_header = TransactionHeader.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Packet {
            return Packet.deserialize(bytes);
        }
    }
    export class TransactionHeader extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            uetr?: string;
            urn?: string;
            memo?: string;
            timestamp?: number;
            related_uetrs?: string[];
            metadata?: Map<string, string>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("uetr" in data && data.uetr != undefined) {
                    this.uetr = data.uetr;
                }
                if ("urn" in data && data.urn != undefined) {
                    this.urn = data.urn;
                }
                if ("memo" in data && data.memo != undefined) {
                    this.memo = data.memo;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("related_uetrs" in data && data.related_uetrs != undefined) {
                    this.related_uetrs = data.related_uetrs;
                }
                if ("metadata" in data && data.metadata != undefined) {
                    this.metadata = data.metadata;
                }
            }
            if (!this.metadata)
                this.metadata = new Map();
        }
        get uetr() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set uetr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get urn() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set urn(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get memo() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set memo(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set timestamp(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get related_uetrs() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set related_uetrs(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get metadata() {
            return pb_1.Message.getField(this, 6) as any as Map<string, string>;
        }
        set metadata(value: Map<string, string>) {
            pb_1.Message.setField(this, 6, value as any);
        }
        static fromObject(data: {
            uetr?: string;
            urn?: string;
            memo?: string;
            timestamp?: number;
            related_uetrs?: string[];
            metadata?: {
                [key: string]: string;
            };
        }): TransactionHeader {
            const message = new TransactionHeader({});
            if (data.uetr != null) {
                message.uetr = data.uetr;
            }
            if (data.urn != null) {
                message.urn = data.urn;
            }
            if (data.memo != null) {
                message.memo = data.memo;
            }
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.related_uetrs != null) {
                message.related_uetrs = data.related_uetrs;
            }
            if (typeof data.metadata == "object") {
                message.metadata = new Map(Object.entries(data.metadata));
            }
            return message;
        }
        toObject() {
            const data: {
                uetr?: string;
                urn?: string;
                memo?: string;
                timestamp?: number;
                related_uetrs?: string[];
                metadata?: {
                    [key: string]: string;
                };
            } = {};
            if (this.uetr != null) {
                data.uetr = this.uetr;
            }
            if (this.urn != null) {
                data.urn = this.urn;
            }
            if (this.memo != null) {
                data.memo = this.memo;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.related_uetrs != null) {
                data.related_uetrs = this.related_uetrs;
            }
            if (this.metadata != null) {
                data.metadata = (Object.fromEntries)(this.metadata);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.uetr.length)
                writer.writeString(1, this.uetr);
            if (this.urn.length)
                writer.writeString(2, this.urn);
            if (this.memo.length)
                writer.writeString(3, this.memo);
            if (this.timestamp != 0)
                writer.writeUint64(4, this.timestamp);
            if (this.related_uetrs.length)
                writer.writeRepeatedString(5, this.related_uetrs);
            for (const [key, value] of this.metadata) {
                writer.writeMessage(6, this.metadata, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionHeader {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionHeader();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.uetr = reader.readString();
                        break;
                    case 2:
                        message.urn = reader.readString();
                        break;
                    case 3:
                        message.memo = reader.readString();
                        break;
                    case 4:
                        message.timestamp = reader.readUint64();
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    case 6:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.metadata as any, reader, reader.readString, reader.readString));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TransactionHeader {
            return TransactionHeader.deserialize(bytes);
        }
    }
    export class BatchedPromissory extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            promissory_batch?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("promissory_batch" in data && data.promissory_batch != undefined) {
                    this.promissory_batch = data.promissory_batch;
                }
            }
        }
        get promissory_batch() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
        }
        set promissory_batch(value: Uint8Array[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            promissory_batch?: Uint8Array[];
        }): BatchedPromissory {
            const message = new BatchedPromissory({});
            if (data.promissory_batch != null) {
                message.promissory_batch = data.promissory_batch;
            }
            return message;
        }
        toObject() {
            const data: {
                promissory_batch?: Uint8Array[];
            } = {};
            if (this.promissory_batch != null) {
                data.promissory_batch = this.promissory_batch;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.promissory_batch.length)
                writer.writeRepeatedBytes(1, this.promissory_batch);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BatchedPromissory {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BatchedPromissory();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BatchedPromissory {
            return BatchedPromissory.deserialize(bytes);
        }
    }
    export class SimplePaymentRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            amount?: dependency_1.common.Amount;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 1) as dependency_1.common.Amount;
        }
        set amount(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
        }): SimplePaymentRequest {
            const message = new SimplePaymentRequest({});
            if (data.amount != null) {
                message.amount = dependency_1.common.Amount.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_amount)
                writer.writeMessage(1, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimplePaymentRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SimplePaymentRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => message.amount = dependency_1.common.Amount.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SimplePaymentRequest {
            return SimplePaymentRequest.deserialize(bytes);
        }
    }
    export class SimplePaymentAck extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): SimplePaymentAck {
            const message = new SimplePaymentAck({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimplePaymentAck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SimplePaymentAck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SimplePaymentAck {
            return SimplePaymentAck.deserialize(bytes);
        }
    }
    export class SimplePaymentNack extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rejection_reason?: SimplePaymentNack.RejectionReason;
            other?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rejection_reason" in data && data.rejection_reason != undefined) {
                    this.rejection_reason = data.rejection_reason;
                }
                if ("other" in data && data.other != undefined) {
                    this.other = data.other;
                }
            }
        }
        get rejection_reason() {
            return pb_1.Message.getFieldWithDefault(this, 1, SimplePaymentNack.RejectionReason.REASON_UNKNOWN) as SimplePaymentNack.RejectionReason;
        }
        set rejection_reason(value: SimplePaymentNack.RejectionReason) {
            pb_1.Message.setField(this, 1, value);
        }
        get other() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set other(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            rejection_reason?: SimplePaymentNack.RejectionReason;
            other?: string;
        }): SimplePaymentNack {
            const message = new SimplePaymentNack({});
            if (data.rejection_reason != null) {
                message.rejection_reason = data.rejection_reason;
            }
            if (data.other != null) {
                message.other = data.other;
            }
            return message;
        }
        toObject() {
            const data: {
                rejection_reason?: SimplePaymentNack.RejectionReason;
                other?: string;
            } = {};
            if (this.rejection_reason != null) {
                data.rejection_reason = this.rejection_reason;
            }
            if (this.other != null) {
                data.other = this.other;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.rejection_reason != SimplePaymentNack.RejectionReason.REASON_UNKNOWN)
                writer.writeEnum(1, this.rejection_reason);
            if (this.other.length)
                writer.writeString(2, this.other);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimplePaymentNack {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SimplePaymentNack();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.rejection_reason = reader.readEnum();
                        break;
                    case 2:
                        message.other = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SimplePaymentNack {
            return SimplePaymentNack.deserialize(bytes);
        }
    }
    export namespace SimplePaymentNack {
        export enum RejectionReason {
            REASON_UNKNOWN = 0,
            REASON_OTHER = 1,
            REASON_AMOUNT_EMPTY = 2,
            REASON_CHANGE_REQUEST_AMOUNT_MISMATCH = 3
        }
    }
    export class SimplePaymentResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            received_amount?: dependency_1.common.Amount;
            received_promissories?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("received_amount" in data && data.received_amount != undefined) {
                    this.received_amount = data.received_amount;
                }
                if ("received_promissories" in data && data.received_promissories != undefined) {
                    this.received_promissories = data.received_promissories;
                }
            }
        }
        get received_amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 1) as dependency_1.common.Amount;
        }
        set received_amount(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_received_amount() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get received_promissories() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set received_promissories(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            received_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            received_promissories?: string[];
        }): SimplePaymentResponse {
            const message = new SimplePaymentResponse({});
            if (data.received_amount != null) {
                message.received_amount = dependency_1.common.Amount.fromObject(data.received_amount);
            }
            if (data.received_promissories != null) {
                message.received_promissories = data.received_promissories;
            }
            return message;
        }
        toObject() {
            const data: {
                received_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
                received_promissories?: string[];
            } = {};
            if (this.received_amount != null) {
                data.received_amount = this.received_amount.toObject();
            }
            if (this.received_promissories != null) {
                data.received_promissories = this.received_promissories;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_received_amount)
                writer.writeMessage(1, this.received_amount, () => this.received_amount.serialize(writer));
            if (this.received_promissories.length)
                writer.writeRepeatedString(2, this.received_promissories);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SimplePaymentResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SimplePaymentResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.received_amount, () => message.received_amount = dependency_1.common.Amount.deserialize(reader));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SimplePaymentResponse {
            return SimplePaymentResponse.deserialize(bytes);
        }
    }
    export class FundsChangeRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            gross_amount?: dependency_1.common.Amount;
            exact_amount?: dependency_1.common.Amount;
            fees?: dependency_1.common.Amount;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("gross_amount" in data && data.gross_amount != undefined) {
                    this.gross_amount = data.gross_amount;
                }
                if ("exact_amount" in data && data.exact_amount != undefined) {
                    this.exact_amount = data.exact_amount;
                }
                if ("fees" in data && data.fees != undefined) {
                    this.fees = data.fees;
                }
            }
        }
        get gross_amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 1) as dependency_1.common.Amount;
        }
        set gross_amount(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_gross_amount() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get exact_amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 2) as dependency_1.common.Amount;
        }
        set exact_amount(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_exact_amount() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get fees() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 3) as dependency_1.common.Amount;
        }
        set fees(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_fees() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            gross_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            exact_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            fees?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
        }): FundsChangeRequest {
            const message = new FundsChangeRequest({});
            if (data.gross_amount != null) {
                message.gross_amount = dependency_1.common.Amount.fromObject(data.gross_amount);
            }
            if (data.exact_amount != null) {
                message.exact_amount = dependency_1.common.Amount.fromObject(data.exact_amount);
            }
            if (data.fees != null) {
                message.fees = dependency_1.common.Amount.fromObject(data.fees);
            }
            return message;
        }
        toObject() {
            const data: {
                gross_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
                exact_amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
                fees?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            } = {};
            if (this.gross_amount != null) {
                data.gross_amount = this.gross_amount.toObject();
            }
            if (this.exact_amount != null) {
                data.exact_amount = this.exact_amount.toObject();
            }
            if (this.fees != null) {
                data.fees = this.fees.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_gross_amount)
                writer.writeMessage(1, this.gross_amount, () => this.gross_amount.serialize(writer));
            if (this.has_exact_amount)
                writer.writeMessage(2, this.exact_amount, () => this.exact_amount.serialize(writer));
            if (this.has_fees)
                writer.writeMessage(3, this.fees, () => this.fees.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FundsChangeRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FundsChangeRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.gross_amount, () => message.gross_amount = dependency_1.common.Amount.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.exact_amount, () => message.exact_amount = dependency_1.common.Amount.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.fees, () => message.fees = dependency_1.common.Amount.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FundsChangeRequest {
            return FundsChangeRequest.deserialize(bytes);
        }
    }
    export class FundsChangeAck extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): FundsChangeAck {
            const message = new FundsChangeAck({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FundsChangeAck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FundsChangeAck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FundsChangeAck {
            return FundsChangeAck.deserialize(bytes);
        }
    }
    export class FundsChangeNack extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rejection_reason?: FundsChangeNack.RejectionReason;
            other?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rejection_reason" in data && data.rejection_reason != undefined) {
                    this.rejection_reason = data.rejection_reason;
                }
                if ("other" in data && data.other != undefined) {
                    this.other = data.other;
                }
            }
        }
        get rejection_reason() {
            return pb_1.Message.getFieldWithDefault(this, 1, FundsChangeNack.RejectionReason.REASON_UNKNOWN) as FundsChangeNack.RejectionReason;
        }
        set rejection_reason(value: FundsChangeNack.RejectionReason) {
            pb_1.Message.setField(this, 1, value);
        }
        get other() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set other(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            rejection_reason?: FundsChangeNack.RejectionReason;
            other?: string;
        }): FundsChangeNack {
            const message = new FundsChangeNack({});
            if (data.rejection_reason != null) {
                message.rejection_reason = data.rejection_reason;
            }
            if (data.other != null) {
                message.other = data.other;
            }
            return message;
        }
        toObject() {
            const data: {
                rejection_reason?: FundsChangeNack.RejectionReason;
                other?: string;
            } = {};
            if (this.rejection_reason != null) {
                data.rejection_reason = this.rejection_reason;
            }
            if (this.other != null) {
                data.other = this.other;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.rejection_reason != FundsChangeNack.RejectionReason.REASON_UNKNOWN)
                writer.writeEnum(1, this.rejection_reason);
            if (this.other.length)
                writer.writeString(2, this.other);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FundsChangeNack {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FundsChangeNack();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.rejection_reason = reader.readEnum();
                        break;
                    case 2:
                        message.other = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FundsChangeNack {
            return FundsChangeNack.deserialize(bytes);
        }
    }
    export namespace FundsChangeNack {
        export enum RejectionReason {
            REASON_UNKNOWN = 0,
            REASON_OTHER = 1,
            REASON_AMOUNT_EMPTY = 2,
            REASON_AMOUNTS_MISMATCH = 3
        }
    }
    export class CancelTransaction extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rejection_reason?: CancelTransaction.RejectionReason;
            other?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rejection_reason" in data && data.rejection_reason != undefined) {
                    this.rejection_reason = data.rejection_reason;
                }
                if ("other" in data && data.other != undefined) {
                    this.other = data.other;
                }
            }
        }
        get rejection_reason() {
            return pb_1.Message.getFieldWithDefault(this, 1, CancelTransaction.RejectionReason.REASON_UNKNOWN) as CancelTransaction.RejectionReason;
        }
        set rejection_reason(value: CancelTransaction.RejectionReason) {
            pb_1.Message.setField(this, 1, value);
        }
        get other() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set other(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            rejection_reason?: CancelTransaction.RejectionReason;
            other?: string;
        }): CancelTransaction {
            const message = new CancelTransaction({});
            if (data.rejection_reason != null) {
                message.rejection_reason = data.rejection_reason;
            }
            if (data.other != null) {
                message.other = data.other;
            }
            return message;
        }
        toObject() {
            const data: {
                rejection_reason?: CancelTransaction.RejectionReason;
                other?: string;
            } = {};
            if (this.rejection_reason != null) {
                data.rejection_reason = this.rejection_reason;
            }
            if (this.other != null) {
                data.other = this.other;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.rejection_reason != CancelTransaction.RejectionReason.REASON_UNKNOWN)
                writer.writeEnum(1, this.rejection_reason);
            if (this.other.length)
                writer.writeString(2, this.other);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CancelTransaction {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CancelTransaction();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.rejection_reason = reader.readEnum();
                        break;
                    case 2:
                        message.other = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CancelTransaction {
            return CancelTransaction.deserialize(bytes);
        }
    }
    export namespace CancelTransaction {
        export enum RejectionReason {
            REASON_UNKNOWN = 0,
            REASON_OTHER = 1,
            REASON_MISMATCHED_TRANSACTIONS = 2
        }
    }
    export class Commitment extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sender?: string;
            recipient?: string;
            amount?: dependency_1.common.Amount;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("recipient" in data && data.recipient != undefined) {
                    this.recipient = data.recipient;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get sender() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get recipient() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set recipient(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Amount, 3) as dependency_1.common.Amount;
        }
        set amount(value: dependency_1.common.Amount) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_amount() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            sender?: string;
            recipient?: string;
            amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
        }): Commitment {
            const message = new Commitment({});
            if (data.sender != null) {
                message.sender = data.sender;
            }
            if (data.recipient != null) {
                message.recipient = data.recipient;
            }
            if (data.amount != null) {
                message.amount = dependency_1.common.Amount.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                sender?: string;
                recipient?: string;
                amount?: ReturnType<typeof dependency_1.common.Amount.prototype.toObject>;
            } = {};
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.recipient != null) {
                data.recipient = this.recipient;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sender.length)
                writer.writeString(1, this.sender);
            if (this.recipient.length)
                writer.writeString(2, this.recipient);
            if (this.has_amount)
                writer.writeMessage(3, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Commitment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Commitment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sender = reader.readString();
                        break;
                    case 2:
                        message.recipient = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => message.amount = dependency_1.common.Amount.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Commitment {
            return Commitment.deserialize(bytes);
        }
    }
    export class TimeoutCondition extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            timeout?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("timeout" in data && data.timeout != undefined) {
                    this.timeout = data.timeout;
                }
            }
        }
        get timeout() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set timeout(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            timeout?: number;
        }): TimeoutCondition {
            const message = new TimeoutCondition({});
            if (data.timeout != null) {
                message.timeout = data.timeout;
            }
            return message;
        }
        toObject() {
            const data: {
                timeout?: number;
            } = {};
            if (this.timeout != null) {
                data.timeout = this.timeout;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.timeout != 0)
                writer.writeUint64(1, this.timeout);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TimeoutCondition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TimeoutCondition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.timeout = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TimeoutCondition {
            return TimeoutCondition.deserialize(bytes);
        }
    }
    export class HashCondition extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            presenter?: string;
            hash?: Uint8Array;
            algorithm_oid?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("presenter" in data && data.presenter != undefined) {
                    this.presenter = data.presenter;
                }
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("algorithm_oid" in data && data.algorithm_oid != undefined) {
                    this.algorithm_oid = data.algorithm_oid;
                }
            }
        }
        get presenter() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set presenter(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get hash() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set hash(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get algorithm_oid() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set algorithm_oid(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            presenter?: string;
            hash?: Uint8Array;
            algorithm_oid?: Uint8Array;
        }): HashCondition {
            const message = new HashCondition({});
            if (data.presenter != null) {
                message.presenter = data.presenter;
            }
            if (data.hash != null) {
                message.hash = data.hash;
            }
            if (data.algorithm_oid != null) {
                message.algorithm_oid = data.algorithm_oid;
            }
            return message;
        }
        toObject() {
            const data: {
                presenter?: string;
                hash?: Uint8Array;
                algorithm_oid?: Uint8Array;
            } = {};
            if (this.presenter != null) {
                data.presenter = this.presenter;
            }
            if (this.hash != null) {
                data.hash = this.hash;
            }
            if (this.algorithm_oid != null) {
                data.algorithm_oid = this.algorithm_oid;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.presenter.length)
                writer.writeString(1, this.presenter);
            if (this.hash.length)
                writer.writeBytes(2, this.hash);
            if (this.algorithm_oid.length)
                writer.writeBytes(3, this.algorithm_oid);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HashCondition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HashCondition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.presenter = reader.readString();
                        break;
                    case 2:
                        message.hash = reader.readBytes();
                        break;
                    case 3:
                        message.algorithm_oid = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): HashCondition {
            return HashCondition.deserialize(bytes);
        }
    }
    export class MintCondition extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            issuer?: string;
            distribution?: dependency_1.common.Distribution;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("issuer" in data && data.issuer != undefined) {
                    this.issuer = data.issuer;
                }
                if ("distribution" in data && data.distribution != undefined) {
                    this.distribution = data.distribution;
                }
            }
        }
        get issuer() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set issuer(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get distribution() {
            return pb_1.Message.getWrapperField(this, dependency_1.common.Distribution, 2) as dependency_1.common.Distribution;
        }
        set distribution(value: dependency_1.common.Distribution) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_distribution() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            issuer?: string;
            distribution?: ReturnType<typeof dependency_1.common.Distribution.prototype.toObject>;
        }): MintCondition {
            const message = new MintCondition({});
            if (data.issuer != null) {
                message.issuer = data.issuer;
            }
            if (data.distribution != null) {
                message.distribution = dependency_1.common.Distribution.fromObject(data.distribution);
            }
            return message;
        }
        toObject() {
            const data: {
                issuer?: string;
                distribution?: ReturnType<typeof dependency_1.common.Distribution.prototype.toObject>;
            } = {};
            if (this.issuer != null) {
                data.issuer = this.issuer;
            }
            if (this.distribution != null) {
                data.distribution = this.distribution.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.issuer.length)
                writer.writeString(1, this.issuer);
            if (this.has_distribution)
                writer.writeMessage(2, this.distribution, () => this.distribution.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MintCondition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MintCondition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.issuer = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.distribution, () => message.distribution = dependency_1.common.Distribution.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MintCondition {
            return MintCondition.deserialize(bytes);
        }
    }
    export class RedeemCondition extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            issuer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("issuer" in data && data.issuer != undefined) {
                    this.issuer = data.issuer;
                }
            }
        }
        get issuer() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set issuer(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            issuer?: string;
        }): RedeemCondition {
            const message = new RedeemCondition({});
            if (data.issuer != null) {
                message.issuer = data.issuer;
            }
            return message;
        }
        toObject() {
            const data: {
                issuer?: string;
            } = {};
            if (this.issuer != null) {
                data.issuer = this.issuer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.issuer.length)
                writer.writeString(1, this.issuer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RedeemCondition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RedeemCondition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.issuer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): RedeemCondition {
            return RedeemCondition.deserialize(bytes);
        }
    }
    export class Condition extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4]];
        constructor(data?: any[] | ({} & (({
            timeout?: TimeoutCondition;
            hash?: never;
            mint?: never;
            redeem?: never;
        } | {
            timeout?: never;
            hash?: HashCondition;
            mint?: never;
            redeem?: never;
        } | {
            timeout?: never;
            hash?: never;
            mint?: MintCondition;
            redeem?: never;
        } | {
            timeout?: never;
            hash?: never;
            mint?: never;
            redeem?: RedeemCondition;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("timeout" in data && data.timeout != undefined) {
                    this.timeout = data.timeout;
                }
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("mint" in data && data.mint != undefined) {
                    this.mint = data.mint;
                }
                if ("redeem" in data && data.redeem != undefined) {
                    this.redeem = data.redeem;
                }
            }
        }
        get timeout() {
            return pb_1.Message.getWrapperField(this, TimeoutCondition, 1) as TimeoutCondition;
        }
        set timeout(value: TimeoutCondition) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_timeout() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get hash() {
            return pb_1.Message.getWrapperField(this, HashCondition, 2) as HashCondition;
        }
        set hash(value: HashCondition) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_hash() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get mint() {
            return pb_1.Message.getWrapperField(this, MintCondition, 3) as MintCondition;
        }
        set mint(value: MintCondition) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_mint() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get redeem() {
            return pb_1.Message.getWrapperField(this, RedeemCondition, 4) as RedeemCondition;
        }
        set redeem(value: RedeemCondition) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_redeem() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get condition() {
            const cases: {
                [index: number]: "none" | "timeout" | "hash" | "mint" | "redeem";
            } = {
                0: "none",
                1: "timeout",
                2: "hash",
                3: "mint",
                4: "redeem"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
        }
        static fromObject(data: {
            timeout?: ReturnType<typeof TimeoutCondition.prototype.toObject>;
            hash?: ReturnType<typeof HashCondition.prototype.toObject>;
            mint?: ReturnType<typeof MintCondition.prototype.toObject>;
            redeem?: ReturnType<typeof RedeemCondition.prototype.toObject>;
        }): Condition {
            const message = new Condition({});
            if (data.timeout != null) {
                message.timeout = TimeoutCondition.fromObject(data.timeout);
            }
            if (data.hash != null) {
                message.hash = HashCondition.fromObject(data.hash);
            }
            if (data.mint != null) {
                message.mint = MintCondition.fromObject(data.mint);
            }
            if (data.redeem != null) {
                message.redeem = RedeemCondition.fromObject(data.redeem);
            }
            return message;
        }
        toObject() {
            const data: {
                timeout?: ReturnType<typeof TimeoutCondition.prototype.toObject>;
                hash?: ReturnType<typeof HashCondition.prototype.toObject>;
                mint?: ReturnType<typeof MintCondition.prototype.toObject>;
                redeem?: ReturnType<typeof RedeemCondition.prototype.toObject>;
            } = {};
            if (this.timeout != null) {
                data.timeout = this.timeout.toObject();
            }
            if (this.hash != null) {
                data.hash = this.hash.toObject();
            }
            if (this.mint != null) {
                data.mint = this.mint.toObject();
            }
            if (this.redeem != null) {
                data.redeem = this.redeem.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_timeout)
                writer.writeMessage(1, this.timeout, () => this.timeout.serialize(writer));
            if (this.has_hash)
                writer.writeMessage(2, this.hash, () => this.hash.serialize(writer));
            if (this.has_mint)
                writer.writeMessage(3, this.mint, () => this.mint.serialize(writer));
            if (this.has_redeem)
                writer.writeMessage(4, this.redeem, () => this.redeem.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Condition {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Condition();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.timeout, () => message.timeout = TimeoutCondition.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.hash, () => message.hash = HashCondition.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.mint, () => message.mint = MintCondition.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.redeem, () => message.redeem = RedeemCondition.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Condition {
            return Condition.deserialize(bytes);
        }
    }
    export class Contract extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            urn?: string;
            id?: string;
            commitments?: Commitment[];
            conditions?: Condition[];
            signatories?: Map<string, Uint8Array>;
            memo?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("urn" in data && data.urn != undefined) {
                    this.urn = data.urn;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("commitments" in data && data.commitments != undefined) {
                    this.commitments = data.commitments;
                }
                if ("conditions" in data && data.conditions != undefined) {
                    this.conditions = data.conditions;
                }
                if ("signatories" in data && data.signatories != undefined) {
                    this.signatories = data.signatories;
                }
                if ("memo" in data && data.memo != undefined) {
                    this.memo = data.memo;
                }
            }
            if (!this.signatories)
                this.signatories = new Map();
        }
        get urn() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set urn(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get commitments() {
            return pb_1.Message.getRepeatedWrapperField(this, Commitment, 3) as Commitment[];
        }
        set commitments(value: Commitment[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get conditions() {
            return pb_1.Message.getRepeatedWrapperField(this, Condition, 4) as Condition[];
        }
        set conditions(value: Condition[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get signatories() {
            return pb_1.Message.getField(this, 5) as any as Map<string, Uint8Array>;
        }
        set signatories(value: Map<string, Uint8Array>) {
            pb_1.Message.setField(this, 5, value as any);
        }
        get memo() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set memo(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            urn?: string;
            id?: string;
            commitments?: ReturnType<typeof Commitment.prototype.toObject>[];
            conditions?: ReturnType<typeof Condition.prototype.toObject>[];
            signatories?: {
                [key: string]: Uint8Array;
            };
            memo?: string;
        }): Contract {
            const message = new Contract({});
            if (data.urn != null) {
                message.urn = data.urn;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.commitments != null) {
                message.commitments = data.commitments.map(item => Commitment.fromObject(item));
            }
            if (data.conditions != null) {
                message.conditions = data.conditions.map(item => Condition.fromObject(item));
            }
            if (typeof data.signatories == "object") {
                message.signatories = new Map(Object.entries(data.signatories));
            }
            if (data.memo != null) {
                message.memo = data.memo;
            }
            return message;
        }
        toObject() {
            const data: {
                urn?: string;
                id?: string;
                commitments?: ReturnType<typeof Commitment.prototype.toObject>[];
                conditions?: ReturnType<typeof Condition.prototype.toObject>[];
                signatories?: {
                    [key: string]: Uint8Array;
                };
                memo?: string;
            } = {};
            if (this.urn != null) {
                data.urn = this.urn;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.commitments != null) {
                data.commitments = this.commitments.map((item: Commitment) => item.toObject());
            }
            if (this.conditions != null) {
                data.conditions = this.conditions.map((item: Condition) => item.toObject());
            }
            if (this.signatories != null) {
                data.signatories = (Object.fromEntries)(this.signatories);
            }
            if (this.memo != null) {
                data.memo = this.memo;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.urn.length)
                writer.writeString(1, this.urn);
            if (this.id.length)
                writer.writeString(2, this.id);
            if (this.commitments.length)
                writer.writeRepeatedMessage(3, this.commitments, (item: Commitment) => item.serialize(writer));
            if (this.conditions.length)
                writer.writeRepeatedMessage(4, this.conditions, (item: Condition) => item.serialize(writer));
            for (const [key, value] of this.signatories) {
                writer.writeMessage(5, this.signatories, () => {
                    writer.writeString(1, key);
                    writer.writeBytes(2, value);
                });
            }
            if (this.memo.length)
                writer.writeString(6, this.memo);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Contract {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Contract();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.urn = reader.readString();
                        break;
                    case 2:
                        message.id = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.commitments, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Commitment.deserialize(reader), Commitment));
                        break;
                    case 4:
                        reader.readMessage(message.conditions, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Condition.deserialize(reader), Condition));
                        break;
                    case 5:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.signatories as any, reader, reader.readString, reader.readBytes));
                        break;
                    case 6:
                        message.memo = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Contract {
            return Contract.deserialize(bytes);
        }
    }
    export class AssociatedUetrConnection extends pb_1.Message {
        #one_of_decls: number[][] = [[2]];
        constructor(data?: any[] | ({
            uetr?: string;
        } & (({
            packet?: Packet;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("uetr" in data && data.uetr != undefined) {
                    this.uetr = data.uetr;
                }
                if ("packet" in data && data.packet != undefined) {
                    this.packet = data.packet;
                }
            }
        }
        get uetr() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set uetr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get packet() {
            return pb_1.Message.getWrapperField(this, Packet, 2) as Packet;
        }
        set packet(value: Packet) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_packet() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _packet() {
            const cases: {
                [index: number]: "none" | "packet";
            } = {
                0: "none",
                2: "packet"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            uetr?: string;
            packet?: ReturnType<typeof Packet.prototype.toObject>;
        }): AssociatedUetrConnection {
            const message = new AssociatedUetrConnection({});
            if (data.uetr != null) {
                message.uetr = data.uetr;
            }
            if (data.packet != null) {
                message.packet = Packet.fromObject(data.packet);
            }
            return message;
        }
        toObject() {
            const data: {
                uetr?: string;
                packet?: ReturnType<typeof Packet.prototype.toObject>;
            } = {};
            if (this.uetr != null) {
                data.uetr = this.uetr;
            }
            if (this.packet != null) {
                data.packet = this.packet.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.uetr.length)
                writer.writeString(1, this.uetr);
            if (this.has_packet)
                writer.writeMessage(2, this.packet, () => this.packet.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AssociatedUetrConnection {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AssociatedUetrConnection();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.uetr = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.packet, () => message.packet = Packet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AssociatedUetrConnection {
            return AssociatedUetrConnection.deserialize(bytes);
        }
    }
}
