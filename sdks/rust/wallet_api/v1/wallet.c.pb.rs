extern crate protobuf_cpp as __pb;
extern crate std as __std;
#[allow(non_camel_case_types)]
pub struct CreateOwnerRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateOwnerRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateOwnerRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateOwnerRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateOwnerRequestMut`.
unsafe impl Sync for CreateOwnerRequest {}

// SAFETY:
// - `CreateOwnerRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateOwnerRequest {}

impl ::__pb::Proxied for CreateOwnerRequest {
  type View<'msg> = CreateOwnerRequestView<'msg>;
  type Mut<'msg> = CreateOwnerRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateOwnerRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateOwnerRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateOwnerRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_serialize(self.raw_msg()) }
  }

  // owner_name: optional string
  pub fn owner_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateOwnerRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateOwnerRequestView<'_> {}

// SAFETY:
// - `CreateOwnerRequestView` is `Send` because while its alive a `CreateOwnerRequestMut` cannot.
// - `CreateOwnerRequestView` does not use thread-local data.
unsafe impl Send for CreateOwnerRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateOwnerRequestView<'msg> {
  type Proxied = CreateOwnerRequest;

  fn as_view(&self) -> ::__pb::View<'msg, CreateOwnerRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateOwnerRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateOwnerRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateOwnerRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateOwnerRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateOwnerRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateOwnerRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateOwnerRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateOwnerRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateOwnerRequest> for CreateOwnerRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateOwnerRequest>)
    where CreateOwnerRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateOwnerRequest> for CreateOwnerRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateOwnerRequest>)
    where CreateOwnerRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateOwnerRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateOwnerRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateOwnerRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateOwnerRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateOwnerRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateOwnerRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // owner_name: optional string
  pub fn owner_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_name_mut().set(val);
  }
  fn owner_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerRequest::__OWNER_NAME_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateOwnerRequestMut` does not perform any shared mutation.
// - `CreateOwnerRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateOwnerRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateOwnerRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateOwnerRequest> {
    CreateOwnerRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateOwnerRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateOwnerRequestMut<'msg> {
  type Proxied = CreateOwnerRequest;
  fn as_view(&self) -> ::__pb::View<'_, CreateOwnerRequest> {
    CreateOwnerRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateOwnerRequest> where 'msg: 'shorter {
    CreateOwnerRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateOwnerRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateOwnerRequestView {
    CreateOwnerRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateOwnerRequestMut {
    CreateOwnerRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // owner_name: optional string
  pub fn owner_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_name_mut().set(val);
  }
  const __OWNER_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_get_owner_name,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_set_owner_name,
    );
  fn owner_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerRequest::__OWNER_NAME_VTABLE,
        )
      )
    }
  }

}  // impl CreateOwnerRequest

impl ::__std::ops::Drop for CreateOwnerRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_get_owner_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerRequest_set_owner_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateOwnerRequest


impl CreateOwnerRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateOwnerRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateOwnerRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct CreateOwnerResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateOwnerResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateOwnerResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateOwnerResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateOwnerResponseMut`.
unsafe impl Sync for CreateOwnerResponse {}

// SAFETY:
// - `CreateOwnerResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateOwnerResponse {}

impl ::__pb::Proxied for CreateOwnerResponse {
  type View<'msg> = CreateOwnerResponseView<'msg>;
  type Mut<'msg> = CreateOwnerResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateOwnerResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateOwnerResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateOwnerResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_serialize(self.raw_msg()) }
  }

  // owner_id: optional string
  pub fn owner_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // owner_name: optional string
  pub fn owner_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateOwnerResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateOwnerResponseView<'_> {}

// SAFETY:
// - `CreateOwnerResponseView` is `Send` because while its alive a `CreateOwnerResponseMut` cannot.
// - `CreateOwnerResponseView` does not use thread-local data.
unsafe impl Send for CreateOwnerResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateOwnerResponseView<'msg> {
  type Proxied = CreateOwnerResponse;

  fn as_view(&self) -> ::__pb::View<'msg, CreateOwnerResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateOwnerResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateOwnerResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateOwnerResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateOwnerResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateOwnerResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateOwnerResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateOwnerResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateOwnerResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateOwnerResponse> for CreateOwnerResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateOwnerResponse>)
    where CreateOwnerResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateOwnerResponse> for CreateOwnerResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateOwnerResponse>)
    where CreateOwnerResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateOwnerResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateOwnerResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateOwnerResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateOwnerResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateOwnerResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateOwnerResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateOwnerResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateOwnerResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // owner_id: optional string
  pub fn owner_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_id_mut().set(val);
  }
  fn owner_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__OWNER_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__API_KEY_VTABLE,
        )
      )
    }
  }

  // owner_name: optional string
  pub fn owner_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_name_mut().set(val);
  }
  fn owner_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__OWNER_NAME_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateOwnerResponseMut` does not perform any shared mutation.
// - `CreateOwnerResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateOwnerResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateOwnerResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateOwnerResponse> {
    CreateOwnerResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateOwnerResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateOwnerResponseMut<'msg> {
  type Proxied = CreateOwnerResponse;
  fn as_view(&self) -> ::__pb::View<'_, CreateOwnerResponse> {
    CreateOwnerResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateOwnerResponse> where 'msg: 'shorter {
    CreateOwnerResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateOwnerResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateOwnerResponseView {
    CreateOwnerResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateOwnerResponseMut {
    CreateOwnerResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // owner_id: optional string
  pub fn owner_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_id_mut().set(val);
  }
  const __OWNER_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_id,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_owner_id,
    );
  fn owner_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__OWNER_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_api_key,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__API_KEY_VTABLE,
        )
      )
    }
  }

  // owner_name: optional string
  pub fn owner_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_owner_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.owner_name_mut().set(val);
  }
  const __OWNER_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_name,
      __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_owner_name,
    );
  fn owner_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateOwnerResponse::__OWNER_NAME_VTABLE,
        )
      )
    }
  }

}  // impl CreateOwnerResponse

impl ::__std::ops::Drop for CreateOwnerResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_owner_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_get_owner_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateOwnerResponse_set_owner_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateOwnerResponse


impl CreateOwnerResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateOwnerResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateOwnerResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct CreateWalletRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateWalletRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateWalletRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateWalletRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateWalletRequestMut`.
unsafe impl Sync for CreateWalletRequest {}

// SAFETY:
// - `CreateWalletRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateWalletRequest {}

impl ::__pb::Proxied for CreateWalletRequest {
  type View<'msg> = CreateWalletRequestView<'msg>;
  type Mut<'msg> = CreateWalletRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateWalletRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateWalletRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateWalletRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_serialize(self.raw_msg()) }
  }

  // wallet_name: optional string
  pub fn wallet_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateWalletRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateWalletRequestView<'_> {}

// SAFETY:
// - `CreateWalletRequestView` is `Send` because while its alive a `CreateWalletRequestMut` cannot.
// - `CreateWalletRequestView` does not use thread-local data.
unsafe impl Send for CreateWalletRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateWalletRequestView<'msg> {
  type Proxied = CreateWalletRequest;

  fn as_view(&self) -> ::__pb::View<'msg, CreateWalletRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateWalletRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateWalletRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateWalletRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateWalletRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateWalletRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateWalletRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateWalletRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateWalletRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateWalletRequest> for CreateWalletRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateWalletRequest>)
    where CreateWalletRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateWalletRequest> for CreateWalletRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateWalletRequest>)
    where CreateWalletRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateWalletRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateWalletRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateWalletRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateWalletRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletRequest::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateWalletRequestMut` does not perform any shared mutation.
// - `CreateWalletRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateWalletRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateWalletRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateWalletRequest> {
    CreateWalletRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateWalletRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateWalletRequestMut<'msg> {
  type Proxied = CreateWalletRequest;
  fn as_view(&self) -> ::__pb::View<'_, CreateWalletRequest> {
    CreateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateWalletRequest> where 'msg: 'shorter {
    CreateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateWalletRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateWalletRequestView {
    CreateWalletRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateWalletRequestMut {
    CreateWalletRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  const __WALLET_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_wallet_name,
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_set_wallet_name,
    );
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletRequest::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl CreateWalletRequest

impl ::__std::ops::Drop for CreateWalletRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_wallet_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_set_wallet_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateWalletRequest


impl CreateWalletRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateWalletRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateWalletRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct CreateWalletResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateWalletResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateWalletResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateWalletResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateWalletResponseMut`.
unsafe impl Sync for CreateWalletResponse {}

// SAFETY:
// - `CreateWalletResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateWalletResponse {}

impl ::__pb::Proxied for CreateWalletResponse {
  type View<'msg> = CreateWalletResponseView<'msg>;
  type Mut<'msg> = CreateWalletResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateWalletResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateWalletResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateWalletResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_name: optional string
  pub fn wallet_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // public_key: optional string
  pub fn public_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // did: optional string
  pub fn did(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateWalletResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateWalletResponseView<'_> {}

// SAFETY:
// - `CreateWalletResponseView` is `Send` because while its alive a `CreateWalletResponseMut` cannot.
// - `CreateWalletResponseView` does not use thread-local data.
unsafe impl Send for CreateWalletResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateWalletResponseView<'msg> {
  type Proxied = CreateWalletResponse;

  fn as_view(&self) -> ::__pb::View<'msg, CreateWalletResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateWalletResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateWalletResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateWalletResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateWalletResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateWalletResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateWalletResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateWalletResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateWalletResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateWalletResponse> for CreateWalletResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateWalletResponse>)
    where CreateWalletResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateWalletResponse> for CreateWalletResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateWalletResponse>)
    where CreateWalletResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateWalletResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateWalletResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateWalletResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateWalletResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateWalletResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateWalletResponseMut` does not perform any shared mutation.
// - `CreateWalletResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateWalletResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateWalletResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateWalletResponse> {
    CreateWalletResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateWalletResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateWalletResponseMut<'msg> {
  type Proxied = CreateWalletResponse;
  fn as_view(&self) -> ::__pb::View<'_, CreateWalletResponse> {
    CreateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateWalletResponse> where 'msg: 'shorter {
    CreateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateWalletResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateWalletResponseView {
    CreateWalletResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateWalletResponseMut {
    CreateWalletResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  const __WALLET_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_name,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_wallet_name,
    );
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  const __PUBLIC_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_public_key,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_public_key,
    );
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_did,
      __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_did,
    );
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

}  // impl CreateWalletResponse

impl ::__std::ops::Drop for CreateWalletResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_wallet_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_wallet_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_public_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_public_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateWalletResponse_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateWalletResponse


impl CreateWalletResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateWalletResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateWalletResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletsRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletsRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletsRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletsRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletsRequestMut`.
unsafe impl Sync for ListWalletsRequest {}

// SAFETY:
// - `ListWalletsRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletsRequest {}

impl ::__pb::Proxied for ListWalletsRequest {
  type View<'msg> = ListWalletsRequestView<'msg>;
  type Mut<'msg> = ListWalletsRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletsRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletsRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletsRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_serialize(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page(self.raw_msg()) }
  }

  // page_size: optional int32
  pub fn page_size(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page_size(self.raw_msg()) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // filters: optional message common.Filter
  pub fn filters(self) -> crate::FilterView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_opt(self) ->
  ::__pb::Optional<crate::FilterView<'msg>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn has_filters(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(self) -> crate::SortByView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_opt(self) ->
  ::__pb::Optional<crate::SortByView<'msg>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn has_sort_by(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListWalletsRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletsRequestView<'_> {}

// SAFETY:
// - `ListWalletsRequestView` is `Send` because while its alive a `ListWalletsRequestMut` cannot.
// - `ListWalletsRequestView` does not use thread-local data.
unsafe impl Send for ListWalletsRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletsRequestView<'msg> {
  type Proxied = ListWalletsRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletsRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletsRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletsRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletsRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletsRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletsRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletsRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletsRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletsRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletsRequest> for ListWalletsRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletsRequest>)
    where ListWalletsRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletsRequest> for ListWalletsRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletsRequest>)
    where ListWalletsRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletsRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletsRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletsRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletsRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page_size(self.raw_msg(), val) }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListWalletsRequestMut` does not perform any shared mutation.
// - `ListWalletsRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletsRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletsRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletsRequest> {
    ListWalletsRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletsRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletsRequestMut<'msg> {
  type Proxied = ListWalletsRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletsRequest> {
    ListWalletsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletsRequest> where 'msg: 'shorter {
    ListWalletsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletsRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletsRequestView {
    ListWalletsRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletsRequestMut {
    ListWalletsRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page_size(self.raw_msg(), val) }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_sort_by(self.raw_msg()) }
  }

}  // impl ListWalletsRequest

impl ::__std::ops::Drop for ListWalletsRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_page_size(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_page_size(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_filters(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_filters(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_filters(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_filters(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_get_mut_sort_by(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_clear_sort_by(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsRequest_has_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> bool;


}  // extern "C" for ListWalletsRequest


impl ListWalletsRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletsRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletsRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletsResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletsResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletsResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletsResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletsResponseMut`.
unsafe impl Sync for ListWalletsResponse {}

// SAFETY:
// - `ListWalletsResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletsResponse {}

impl ::__pb::Proxied for ListWalletsResponse {
  type View<'msg> = ListWalletsResponseView<'msg>;
  type Mut<'msg> = ListWalletsResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletsResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletsResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletsResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_serialize(self.raw_msg()) }
  }

  // wallets: repeated message wallet_api.v1.ListWalletsResponse.Wallet
  pub fn wallets(self) -> ::__pb::RepeatedView<'msg, crate::list_wallets_response::Wallet> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_wallets(self.raw_msg()),
      )
    }
  }

  // total_owned_wallets: optional uint32
  pub fn total_owned_wallets(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_total_owned_wallets(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListWalletsResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletsResponseView<'_> {}

// SAFETY:
// - `ListWalletsResponseView` is `Send` because while its alive a `ListWalletsResponseMut` cannot.
// - `ListWalletsResponseView` does not use thread-local data.
unsafe impl Send for ListWalletsResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletsResponseView<'msg> {
  type Proxied = ListWalletsResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletsResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletsResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletsResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletsResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletsResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletsResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletsResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletsResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletsResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletsResponse> for ListWalletsResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletsResponse>)
    where ListWalletsResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletsResponse> for ListWalletsResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletsResponse>)
    where ListWalletsResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletsResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletsResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletsResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletsResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallets: repeated message wallet_api.v1.ListWalletsResponse.Wallet
  pub fn wallets(&self) -> ::__pb::RepeatedView<'_, crate::list_wallets_response::Wallet> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_wallets(self.raw_msg()),
      )
    }
  }
  pub fn wallets_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_wallets_response::Wallet> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_mut_wallets(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_wallets: optional uint32
  pub fn total_owned_wallets(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_total_owned_wallets(self.raw_msg()) }
  }
  pub fn set_total_owned_wallets(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_set_total_owned_wallets(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `ListWalletsResponseMut` does not perform any shared mutation.
// - `ListWalletsResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletsResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletsResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletsResponse> {
    ListWalletsResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletsResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletsResponseMut<'msg> {
  type Proxied = ListWalletsResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletsResponse> {
    ListWalletsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletsResponse> where 'msg: 'shorter {
    ListWalletsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletsResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletsResponseView {
    ListWalletsResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletsResponseMut {
    ListWalletsResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallets: repeated message wallet_api.v1.ListWalletsResponse.Wallet
  pub fn wallets(&self) -> ::__pb::RepeatedView<'_, crate::list_wallets_response::Wallet> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_wallets(self.raw_msg()),
      )
    }
  }
  pub fn wallets_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_wallets_response::Wallet> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_mut_wallets(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_wallets: optional uint32
  pub fn total_owned_wallets(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_total_owned_wallets(self.raw_msg()) }
  }
  pub fn set_total_owned_wallets(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_set_total_owned_wallets(self.raw_msg(), val) }
  }

}  // impl ListWalletsResponse

impl ::__std::ops::Drop for ListWalletsResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_clear_wallets(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_mut_wallets(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_wallets(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_get_total_owned_wallets(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_set_total_owned_wallets(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for ListWalletsResponse

pub mod list_wallets_response {
  #[allow(non_camel_case_types)]
  pub struct Wallet {
    inner: ::__pb::__runtime::MessageInner
  }

  impl std::fmt::Debug for Wallet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  impl std::default::Default for Wallet {
    fn default() -> Self {
      Self::new()
    }
  }

  // SAFETY:
  // - `Wallet` is `Sync` because it does not implement interior mutability.
  //    Neither does `WalletMut`.
  unsafe impl Sync for Wallet {}

  // SAFETY:
  // - `Wallet` is `Send` because it uniquely owns its arena and does
  //   not use thread-local data.
  unsafe impl Send for Wallet {}

  impl ::__pb::Proxied for Wallet {
    type View<'msg> = WalletView<'msg>;
    type Mut<'msg> = WalletMut<'msg>;
  }

  #[derive(Copy, Clone)]
  #[allow(dead_code)]
  pub struct WalletView<'msg> {
    msg: ::__pb::__runtime::RawMessage,
    _phantom: ::__std::marker::PhantomData<&'msg ()>,
  }

  impl std::fmt::Debug for WalletView<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> WalletView<'msg> {
    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { msg, _phantom: ::__std::marker::PhantomData }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_serialize(self.raw_msg()) }
    }

    // wallet_name: optional string
    pub fn wallet_name(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_name(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // wallet_id: optional string
    pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // public_key: optional string
    pub fn public_key(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_public_key(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // did: optional string
    pub fn did(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

  }

  // SAFETY:
  // - `WalletView` is `Sync` because it does not support mutation.
  unsafe impl Sync for WalletView<'_> {}

  // SAFETY:
  // - `WalletView` is `Send` because while its alive a `WalletMut` cannot.
  // - `WalletView` does not use thread-local data.
  unsafe impl Send for WalletView<'_> {}

  impl<'msg> ::__pb::ViewProxy<'msg> for WalletView<'msg> {
    type Proxied = Wallet;

    fn as_view(&self) -> ::__pb::View<'msg, Wallet> {
      *self
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Wallet> where 'msg: 'shorter {
      self
    }
  }

  impl ::__pb::__internal::ProxiedWithRawVTable for Wallet {
    type VTable = ::__pb::__runtime::MessageVTable;

    fn make_view(_private: ::__pb::__internal::Private,
                mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::View<'_, Self> {
      let msg = unsafe {
        (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
      };
      WalletView::new(::__pb::__internal::Private, msg)
    }

    fn make_mut(_private: ::__pb::__internal::Private,
                inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::Mut<'_, Self> {
      let raw_submsg = unsafe {
        (inner.vtable().mut_getter)(inner.msg_ref().msg())
      };
      WalletMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
    }
  }

  impl ::__pb::__internal::ProxiedWithRawOptionalVTable for Wallet {
    type OptionalVTable = ::__pb::__runtime::MessageVTable;

    fn upcast_vtable(_private: ::__pb::__internal::Private,
                     optional_vtable: &'static Self::OptionalVTable)
                    -> &'static Self::VTable {
      &optional_vtable
    }
  }

  impl ::__pb::ProxiedWithPresence for Wallet {
    type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, Wallet>;
    type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, Wallet>;

    fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
       -> Self::AbsentMutData<'_> {
       // SAFETY: The raw ptr msg_ref is valid
      unsafe {
        (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         present_mutator.msg_ref(),
         present_mutator.optional_vtable())
      }
    }

    fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
       -> Self::PresentMutData<'_> {
     unsafe {
       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         absent_mutator.msg_ref(),
         absent_mutator.optional_vtable())
     }
    }
  }

  impl<'msg> ::__pb::SettableValue<Wallet> for WalletView<'msg> {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Wallet>)
      where Wallet: 'dst {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_copy_from(mutator.inner.msg(), self.msg) };
    }
  }

  impl ::__pb::SettableValue<Wallet> for Wallet {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Wallet>)
      where Wallet: 'dst {
      self.as_view().set_on(::__pb::__internal::Private, mutator);
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Wallet {
    fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_len(f.as_raw(::__pb::__internal::Private)) }
    }

    unsafe fn repeated_set_unchecked(
      mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
      i: usize,
      v: ::__pb::View<Self>,
    ) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `i < len(f)` is promised by caller.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_copy_from(
          __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
          v.raw_msg(),
        );
      }
    }

    unsafe fn repeated_get_unchecked(
      f: ::__pb::View<::__pb::Repeated<Self>>,
      i: usize,
    ) -> ::__pb::View<Self> {
      // SAFETY:
      // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
      // - `i < len(f)` is promised by caller.
      let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
      ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
    }
    fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
    }

    fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_add(f.as_raw(::__pb::__internal::Private));
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_copy_from(new_elem, v.raw_msg());
      }
    }

    fn repeated_copy_from(
      src: ::__pb::View<::__pb::Repeated<Self>>,
      mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      // SAFETY:
      // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
      // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
      }
    }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Wallet {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
          let key = key.as_bytes().into();
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(WalletView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletsResponse_Wallet_iter_get,
                  |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                  |raw_msg| WalletView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }

  #[allow(dead_code)]
  #[allow(non_camel_case_types)]
  pub struct WalletMut<'msg> {
    inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
  }

  impl std::fmt::Debug for WalletMut<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> WalletMut<'msg> {
    #[doc(hidden)]
    pub fn from_parent(
               _private: ::__pb::__internal::Private,
               parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
               msg: ::__pb::__runtime::RawMessage)
      -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
                 ::__pb::__internal::Private, parent, msg)
      }
    }

    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
      Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
    }

    #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
    pub fn or_default(self) -> Self { self }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg()
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
      self.inner
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      ::__pb::ViewProxy::as_view(self).serialize()
    }


    // wallet_name: optional string
    pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_name(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_name_mut().set(val);
    }
    fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__WALLET_NAME_VTABLE,
          )
        )
      }
    }

    // wallet_id: optional string
    pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_id_mut().set(val);
    }
    fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__WALLET_ID_VTABLE,
          )
        )
      }
    }

    // public_key: optional string
    pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_public_key(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.public_key_mut().set(val);
    }
    fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__PUBLIC_KEY_VTABLE,
          )
        )
      }
    }

    // did: optional string
    pub fn did(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.did_mut().set(val);
    }
    fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__DID_VTABLE,
          )
        )
      }
    }

  }

  // SAFETY:
  // - `WalletMut` does not perform any shared mutation.
  // - `WalletMut` is not `Send`, and so even in the presence of mutator
  //   splitting, synchronous access of an arena is impossible.
  unsafe impl Sync for WalletMut<'_> {}

  impl<'msg> ::__pb::MutProxy<'msg> for WalletMut<'msg> {
    fn as_mut(&mut self) -> ::__pb::Mut<'_, Wallet> {
      WalletMut { inner: self.inner }
    }
    fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, Wallet> where 'msg : 'shorter { self }
  }

  impl<'msg> ::__pb::ViewProxy<'msg> for WalletMut<'msg> {
    type Proxied = Wallet;
    fn as_view(&self) -> ::__pb::View<'_, Wallet> {
      WalletView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Wallet> where 'msg: 'shorter {
      WalletView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
  }

  #[allow(dead_code)]
  impl Wallet {
    pub fn new() -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_new() } } }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
      ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
    }


    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      self.as_view().serialize()
    }
    #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
    pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      self.clear_and_parse(data)
    }
    pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      let success = unsafe {
        // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
        let data = ::__pb::__runtime::SerializedData::from_raw_parts(
          ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
          data.len(),
        );

        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_parse(self.raw_msg(), data)
      };
      success.then_some(()).ok_or(::__pb::ParseError)
    }
    pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
      let mut msg = Self::new();
      msg.clear_and_parse(data).map(|_| msg)
    }

    pub fn as_view(&self) -> WalletView {
      WalletView::new(::__pb::__internal::Private, self.inner.msg)
    }

    pub fn as_mut(&mut self) -> WalletMut {
      WalletMut::new(::__pb::__internal::Private, &mut self.inner)
    }

    // wallet_name: optional string
    pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_name(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_name_mut().set(val);
    }
    const __WALLET_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_name,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_wallet_name,
      );
    fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__WALLET_NAME_VTABLE,
          )
        )
      }
    }

    // wallet_id: optional string
    pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_id_mut().set(val);
    }
    const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_id,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_wallet_id,
      );
    fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__WALLET_ID_VTABLE,
          )
        )
      }
    }

    // public_key: optional string
    pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_public_key(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.public_key_mut().set(val);
    }
    const __PUBLIC_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_public_key,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_public_key,
      );
    fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__PUBLIC_KEY_VTABLE,
          )
        )
      }
    }

    // did: optional string
    pub fn did(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.did_mut().set(val);
    }
    const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_did,
        __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_did,
      );
    fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Wallet::__DID_VTABLE,
          )
        )
      }
    }

  }  // impl Wallet

  impl ::__std::ops::Drop for Wallet {
    fn drop(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_delete(self.raw_msg()); }
    }
  }

  extern "C" {
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_new() -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_delete(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_wallet_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_public_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_public_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListWalletsResponse_Wallet_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


  }  // extern "C" for Wallet


  impl Wallet {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg } }
    }
    pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      let s = std::mem::ManuallyDrop::new(self);
      s.raw_msg()
    }
  }

  impl<'a> WalletMut<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
        msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
      }
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.raw_msg()
    }
  }

  impl<'a> WalletView<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a ::__pb::__runtime::RawMessage) -> Self {
      Self::new(::__pb::__internal::Private, *msg)
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }
  }

}  // mod list_wallets_response

impl ListWalletsResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletsResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletsResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletBalancesRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletBalancesRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletBalancesRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletBalancesRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletBalancesRequestMut`.
unsafe impl Sync for ListWalletBalancesRequest {}

// SAFETY:
// - `ListWalletBalancesRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletBalancesRequest {}

impl ::__pb::Proxied for ListWalletBalancesRequest {
  type View<'msg> = ListWalletBalancesRequestView<'msg>;
  type Mut<'msg> = ListWalletBalancesRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletBalancesRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletBalancesRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalancesRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(self) -> crate::SortByView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_opt(self) ->
  ::__pb::Optional<crate::SortByView<'msg>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn has_sort_by(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_has_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListWalletBalancesRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletBalancesRequestView<'_> {}

// SAFETY:
// - `ListWalletBalancesRequestView` is `Send` because while its alive a `ListWalletBalancesRequestMut` cannot.
// - `ListWalletBalancesRequestView` does not use thread-local data.
unsafe impl Send for ListWalletBalancesRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalancesRequestView<'msg> {
  type Proxied = ListWalletBalancesRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletBalancesRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalancesRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletBalancesRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletBalancesRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletBalancesRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletBalancesRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletBalancesRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletBalancesRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletBalancesRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletBalancesRequest> for ListWalletBalancesRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalancesRequest>)
    where ListWalletBalancesRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletBalancesRequest> for ListWalletBalancesRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalancesRequest>)
    where ListWalletBalancesRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletBalancesRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletBalancesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletBalancesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletBalancesRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletBalancesRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalancesRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalancesRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalancesRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_clear_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListWalletBalancesRequestMut` does not perform any shared mutation.
// - `ListWalletBalancesRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletBalancesRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletBalancesRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletBalancesRequest> {
    ListWalletBalancesRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletBalancesRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalancesRequestMut<'msg> {
  type Proxied = ListWalletBalancesRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletBalancesRequest> {
    ListWalletBalancesRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalancesRequest> where 'msg: 'shorter {
    ListWalletBalancesRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletBalancesRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletBalancesRequestView {
    ListWalletBalancesRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletBalancesRequestMut {
    ListWalletBalancesRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalancesRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalancesRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_clear_sort_by(self.raw_msg()) }
  }

}  // impl ListWalletBalancesRequest

impl ::__std::ops::Drop for ListWalletBalancesRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_get_mut_sort_by(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_clear_sort_by(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesRequest_has_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> bool;


}  // extern "C" for ListWalletBalancesRequest


impl ListWalletBalancesRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletBalancesRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletBalancesRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct WalletBalance {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for WalletBalance {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for WalletBalance {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `WalletBalance` is `Sync` because it does not implement interior mutability.
//    Neither does `WalletBalanceMut`.
unsafe impl Sync for WalletBalance {}

// SAFETY:
// - `WalletBalance` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for WalletBalance {}

impl ::__pb::Proxied for WalletBalance {
  type View<'msg> = WalletBalanceView<'msg>;
  type Mut<'msg> = WalletBalanceMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct WalletBalanceView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for WalletBalanceView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> WalletBalanceView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_serialize(self.raw_msg()) }
  }

  // amount: optional message common.Amount
  pub fn amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn has_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_has_amount(self.raw_msg()) }
  }

  // file_count: optional int64
  pub fn file_count(self) -> i64 {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_file_count(self.raw_msg()) }
  }

}

// SAFETY:
// - `WalletBalanceView` is `Sync` because it does not support mutation.
unsafe impl Sync for WalletBalanceView<'_> {}

// SAFETY:
// - `WalletBalanceView` is `Send` because while its alive a `WalletBalanceMut` cannot.
// - `WalletBalanceView` does not use thread-local data.
unsafe impl Send for WalletBalanceView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for WalletBalanceView<'msg> {
  type Proxied = WalletBalance;

  fn as_view(&self) -> ::__pb::View<'msg, WalletBalance> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, WalletBalance> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for WalletBalance {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    WalletBalanceView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    WalletBalanceMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for WalletBalance {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for WalletBalance {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, WalletBalance>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, WalletBalance>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<WalletBalance> for WalletBalanceView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, WalletBalance>)
    where WalletBalance: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<WalletBalance> for WalletBalance {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, WalletBalance>)
    where WalletBalance: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for WalletBalance {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_WalletBalance_copy_from(
        __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_WalletBalance_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for WalletBalance {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(WalletBalanceView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_WalletBalance_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| WalletBalanceView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct WalletBalanceMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for WalletBalanceMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> WalletBalanceMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_clear_amount(self.raw_msg()) }
  }

  // file_count: optional int64
  pub fn file_count(&self) -> i64 {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_file_count(self.raw_msg()) }
  }
  pub fn set_file_count(&mut self, val: i64) {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_set_file_count(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `WalletBalanceMut` does not perform any shared mutation.
// - `WalletBalanceMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for WalletBalanceMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for WalletBalanceMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, WalletBalance> {
    WalletBalanceMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, WalletBalance> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for WalletBalanceMut<'msg> {
  type Proxied = WalletBalance;
  fn as_view(&self) -> ::__pb::View<'_, WalletBalance> {
    WalletBalanceView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, WalletBalance> where 'msg: 'shorter {
    WalletBalanceView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl WalletBalance {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_WalletBalance_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> WalletBalanceView {
    WalletBalanceView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> WalletBalanceMut {
    WalletBalanceMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_WalletBalance_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_clear_amount(self.raw_msg()) }
  }

  // file_count: optional int64
  pub fn file_count(&self) -> i64 {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_get_file_count(self.raw_msg()) }
  }
  pub fn set_file_count(&mut self, val: i64) {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_set_file_count(self.raw_msg(), val) }
  }

}  // impl WalletBalance

impl ::__std::ops::Drop for WalletBalance {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_WalletBalance_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_get_file_count(raw_msg: ::__pb::__runtime::RawMessage) -> i64;
  fn __rust_proto_thunk__wallet_api_v1_WalletBalance_set_file_count(raw_msg: ::__pb::__runtime::RawMessage, val: i64);


}  // extern "C" for WalletBalance


impl WalletBalance {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> WalletBalanceMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> WalletBalanceView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletBalancesResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletBalancesResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletBalancesResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletBalancesResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletBalancesResponseMut`.
unsafe impl Sync for ListWalletBalancesResponse {}

// SAFETY:
// - `ListWalletBalancesResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletBalancesResponse {}

impl ::__pb::Proxied for ListWalletBalancesResponse {
  type View<'msg> = ListWalletBalancesResponseView<'msg>;
  type Mut<'msg> = ListWalletBalancesResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletBalancesResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletBalancesResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalancesResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_serialize(self.raw_msg()) }
  }

  // balances: repeated message wallet_api.v1.WalletBalance
  pub fn balances(self) -> ::__pb::RepeatedView<'msg, crate::WalletBalance> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_balances(self.raw_msg()),
      )
    }
  }

}

// SAFETY:
// - `ListWalletBalancesResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletBalancesResponseView<'_> {}

// SAFETY:
// - `ListWalletBalancesResponseView` is `Send` because while its alive a `ListWalletBalancesResponseMut` cannot.
// - `ListWalletBalancesResponseView` does not use thread-local data.
unsafe impl Send for ListWalletBalancesResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalancesResponseView<'msg> {
  type Proxied = ListWalletBalancesResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletBalancesResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalancesResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletBalancesResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletBalancesResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletBalancesResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletBalancesResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletBalancesResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletBalancesResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletBalancesResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletBalancesResponse> for ListWalletBalancesResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalancesResponse>)
    where ListWalletBalancesResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletBalancesResponse> for ListWalletBalancesResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalancesResponse>)
    where ListWalletBalancesResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletBalancesResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletBalancesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalancesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalancesResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletBalancesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletBalancesResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletBalancesResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalancesResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // balances: repeated message wallet_api.v1.WalletBalance
  pub fn balances(&self) -> ::__pb::RepeatedView<'_, crate::WalletBalance> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_balances(self.raw_msg()),
      )
    }
  }
  pub fn balances_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::WalletBalance> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_mut_balances(self.raw_msg()),
        ),
      )
    }
  }

}

// SAFETY:
// - `ListWalletBalancesResponseMut` does not perform any shared mutation.
// - `ListWalletBalancesResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletBalancesResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletBalancesResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletBalancesResponse> {
    ListWalletBalancesResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletBalancesResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalancesResponseMut<'msg> {
  type Proxied = ListWalletBalancesResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletBalancesResponse> {
    ListWalletBalancesResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalancesResponse> where 'msg: 'shorter {
    ListWalletBalancesResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletBalancesResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletBalancesResponseView {
    ListWalletBalancesResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletBalancesResponseMut {
    ListWalletBalancesResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // balances: repeated message wallet_api.v1.WalletBalance
  pub fn balances(&self) -> ::__pb::RepeatedView<'_, crate::WalletBalance> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_balances(self.raw_msg()),
      )
    }
  }
  pub fn balances_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::WalletBalance> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_mut_balances(self.raw_msg()),
        ),
      )
    }
  }

}  // impl ListWalletBalancesResponse

impl ::__std::ops::Drop for ListWalletBalancesResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_clear_balances(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_mut_balances(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalancesResponse_get_balances(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;


}  // extern "C" for ListWalletBalancesResponse


impl ListWalletBalancesResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletBalancesResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletBalancesResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListAssetFilesRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListAssetFilesRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListAssetFilesRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListAssetFilesRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListAssetFilesRequestMut`.
unsafe impl Sync for ListAssetFilesRequest {}

// SAFETY:
// - `ListAssetFilesRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListAssetFilesRequest {}

impl ::__pb::Proxied for ListAssetFilesRequest {
  type View<'msg> = ListAssetFilesRequestView<'msg>;
  type Mut<'msg> = ListAssetFilesRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListAssetFilesRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListAssetFilesRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListAssetFilesRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_serialize(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page(self.raw_msg()) }
  }

  // page_size: optional int32
  pub fn page_size(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page_size(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // filters: optional message common.Filter
  pub fn filters(self) -> crate::FilterView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_opt(self) ->
  ::__pb::Optional<crate::FilterView<'msg>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn has_filters(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(self) -> crate::SortByView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_opt(self) ->
  ::__pb::Optional<crate::SortByView<'msg>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn has_sort_by(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListAssetFilesRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListAssetFilesRequestView<'_> {}

// SAFETY:
// - `ListAssetFilesRequestView` is `Send` because while its alive a `ListAssetFilesRequestMut` cannot.
// - `ListAssetFilesRequestView` does not use thread-local data.
unsafe impl Send for ListAssetFilesRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListAssetFilesRequestView<'msg> {
  type Proxied = ListAssetFilesRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListAssetFilesRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListAssetFilesRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListAssetFilesRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListAssetFilesRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListAssetFilesRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListAssetFilesRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListAssetFilesRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListAssetFilesRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListAssetFilesRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListAssetFilesRequest> for ListAssetFilesRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListAssetFilesRequest>)
    where ListAssetFilesRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListAssetFilesRequest> for ListAssetFilesRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListAssetFilesRequest>)
    where ListAssetFilesRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListAssetFilesRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListAssetFilesRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListAssetFilesRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListAssetFilesRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListAssetFilesRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListAssetFilesRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page_size(self.raw_msg(), val) }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListAssetFilesRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListAssetFilesRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListAssetFilesRequestMut` does not perform any shared mutation.
// - `ListAssetFilesRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListAssetFilesRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListAssetFilesRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListAssetFilesRequest> {
    ListAssetFilesRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListAssetFilesRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListAssetFilesRequestMut<'msg> {
  type Proxied = ListAssetFilesRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListAssetFilesRequest> {
    ListAssetFilesRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListAssetFilesRequest> where 'msg: 'shorter {
    ListAssetFilesRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListAssetFilesRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListAssetFilesRequestView {
    ListAssetFilesRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListAssetFilesRequestMut {
    ListAssetFilesRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page_size(self.raw_msg(), val) }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListAssetFilesRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListAssetFilesRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_sort_by(self.raw_msg()) }
  }

}  // impl ListAssetFilesRequest

impl ::__std::ops::Drop for ListAssetFilesRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_page_size(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_page_size(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_filters(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_filters(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_filters(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_filters(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_get_mut_sort_by(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_clear_sort_by(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesRequest_has_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> bool;


}  // extern "C" for ListAssetFilesRequest


impl ListAssetFilesRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListAssetFilesRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListAssetFilesRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListAssetFilesResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListAssetFilesResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListAssetFilesResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListAssetFilesResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListAssetFilesResponseMut`.
unsafe impl Sync for ListAssetFilesResponse {}

// SAFETY:
// - `ListAssetFilesResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListAssetFilesResponse {}

impl ::__pb::Proxied for ListAssetFilesResponse {
  type View<'msg> = ListAssetFilesResponseView<'msg>;
  type Mut<'msg> = ListAssetFilesResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListAssetFilesResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListAssetFilesResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListAssetFilesResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_serialize(self.raw_msg()) }
  }

  // funds: repeated message wallet_api.v1.ListAssetFilesResponse.Fund
  pub fn funds(self) -> ::__pb::RepeatedView<'msg, crate::list_asset_files_response::Fund> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_funds(self.raw_msg()),
      )
    }
  }

  // total_owned_funds: optional uint32
  pub fn total_owned_funds(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_total_owned_funds(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListAssetFilesResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListAssetFilesResponseView<'_> {}

// SAFETY:
// - `ListAssetFilesResponseView` is `Send` because while its alive a `ListAssetFilesResponseMut` cannot.
// - `ListAssetFilesResponseView` does not use thread-local data.
unsafe impl Send for ListAssetFilesResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListAssetFilesResponseView<'msg> {
  type Proxied = ListAssetFilesResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListAssetFilesResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListAssetFilesResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListAssetFilesResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListAssetFilesResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListAssetFilesResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListAssetFilesResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListAssetFilesResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListAssetFilesResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListAssetFilesResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListAssetFilesResponse> for ListAssetFilesResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListAssetFilesResponse>)
    where ListAssetFilesResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListAssetFilesResponse> for ListAssetFilesResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListAssetFilesResponse>)
    where ListAssetFilesResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListAssetFilesResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListAssetFilesResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListAssetFilesResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListAssetFilesResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListAssetFilesResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListAssetFilesResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListAssetFilesResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // funds: repeated message wallet_api.v1.ListAssetFilesResponse.Fund
  pub fn funds(&self) -> ::__pb::RepeatedView<'_, crate::list_asset_files_response::Fund> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_funds(self.raw_msg()),
      )
    }
  }
  pub fn funds_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_asset_files_response::Fund> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_mut_funds(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_funds: optional uint32
  pub fn total_owned_funds(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_total_owned_funds(self.raw_msg()) }
  }
  pub fn set_total_owned_funds(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_set_total_owned_funds(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `ListAssetFilesResponseMut` does not perform any shared mutation.
// - `ListAssetFilesResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListAssetFilesResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListAssetFilesResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListAssetFilesResponse> {
    ListAssetFilesResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListAssetFilesResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListAssetFilesResponseMut<'msg> {
  type Proxied = ListAssetFilesResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListAssetFilesResponse> {
    ListAssetFilesResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListAssetFilesResponse> where 'msg: 'shorter {
    ListAssetFilesResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListAssetFilesResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListAssetFilesResponseView {
    ListAssetFilesResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListAssetFilesResponseMut {
    ListAssetFilesResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // funds: repeated message wallet_api.v1.ListAssetFilesResponse.Fund
  pub fn funds(&self) -> ::__pb::RepeatedView<'_, crate::list_asset_files_response::Fund> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_funds(self.raw_msg()),
      )
    }
  }
  pub fn funds_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_asset_files_response::Fund> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_mut_funds(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_funds: optional uint32
  pub fn total_owned_funds(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_total_owned_funds(self.raw_msg()) }
  }
  pub fn set_total_owned_funds(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_set_total_owned_funds(self.raw_msg(), val) }
  }

}  // impl ListAssetFilesResponse

impl ::__std::ops::Drop for ListAssetFilesResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_clear_funds(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_mut_funds(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_funds(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_get_total_owned_funds(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_set_total_owned_funds(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for ListAssetFilesResponse

pub mod list_asset_files_response {
  #[allow(non_camel_case_types)]
  pub struct Notary {
    inner: ::__pb::__runtime::MessageInner
  }

  impl std::fmt::Debug for Notary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  impl std::default::Default for Notary {
    fn default() -> Self {
      Self::new()
    }
  }

  // SAFETY:
  // - `Notary` is `Sync` because it does not implement interior mutability.
  //    Neither does `NotaryMut`.
  unsafe impl Sync for Notary {}

  // SAFETY:
  // - `Notary` is `Send` because it uniquely owns its arena and does
  //   not use thread-local data.
  unsafe impl Send for Notary {}

  impl ::__pb::Proxied for Notary {
    type View<'msg> = NotaryView<'msg>;
    type Mut<'msg> = NotaryMut<'msg>;
  }

  #[derive(Copy, Clone)]
  #[allow(dead_code)]
  pub struct NotaryView<'msg> {
    msg: ::__pb::__runtime::RawMessage,
    _phantom: ::__std::marker::PhantomData<&'msg ()>,
  }

  impl std::fmt::Debug for NotaryView<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> NotaryView<'msg> {
    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { msg, _phantom: ::__std::marker::PhantomData }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_serialize(self.raw_msg()) }
    }

    // did: optional string
    pub fn did(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // signature: optional bytes
    pub fn signature(self) -> &'msg [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_signature(self.raw_msg()).as_ref() };
      view
    }

  }

  // SAFETY:
  // - `NotaryView` is `Sync` because it does not support mutation.
  unsafe impl Sync for NotaryView<'_> {}

  // SAFETY:
  // - `NotaryView` is `Send` because while its alive a `NotaryMut` cannot.
  // - `NotaryView` does not use thread-local data.
  unsafe impl Send for NotaryView<'_> {}

  impl<'msg> ::__pb::ViewProxy<'msg> for NotaryView<'msg> {
    type Proxied = Notary;

    fn as_view(&self) -> ::__pb::View<'msg, Notary> {
      *self
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Notary> where 'msg: 'shorter {
      self
    }
  }

  impl ::__pb::__internal::ProxiedWithRawVTable for Notary {
    type VTable = ::__pb::__runtime::MessageVTable;

    fn make_view(_private: ::__pb::__internal::Private,
                mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::View<'_, Self> {
      let msg = unsafe {
        (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
      };
      NotaryView::new(::__pb::__internal::Private, msg)
    }

    fn make_mut(_private: ::__pb::__internal::Private,
                inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::Mut<'_, Self> {
      let raw_submsg = unsafe {
        (inner.vtable().mut_getter)(inner.msg_ref().msg())
      };
      NotaryMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
    }
  }

  impl ::__pb::__internal::ProxiedWithRawOptionalVTable for Notary {
    type OptionalVTable = ::__pb::__runtime::MessageVTable;

    fn upcast_vtable(_private: ::__pb::__internal::Private,
                     optional_vtable: &'static Self::OptionalVTable)
                    -> &'static Self::VTable {
      &optional_vtable
    }
  }

  impl ::__pb::ProxiedWithPresence for Notary {
    type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, Notary>;
    type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, Notary>;

    fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
       -> Self::AbsentMutData<'_> {
       // SAFETY: The raw ptr msg_ref is valid
      unsafe {
        (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         present_mutator.msg_ref(),
         present_mutator.optional_vtable())
      }
    }

    fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
       -> Self::PresentMutData<'_> {
     unsafe {
       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         absent_mutator.msg_ref(),
         absent_mutator.optional_vtable())
     }
    }
  }

  impl<'msg> ::__pb::SettableValue<Notary> for NotaryView<'msg> {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Notary>)
      where Notary: 'dst {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_copy_from(mutator.inner.msg(), self.msg) };
    }
  }

  impl ::__pb::SettableValue<Notary> for Notary {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Notary>)
      where Notary: 'dst {
      self.as_view().set_on(::__pb::__internal::Private, mutator);
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Notary {
    fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_len(f.as_raw(::__pb::__internal::Private)) }
    }

    unsafe fn repeated_set_unchecked(
      mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
      i: usize,
      v: ::__pb::View<Self>,
    ) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `i < len(f)` is promised by caller.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_copy_from(
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
          v.raw_msg(),
        );
      }
    }

    unsafe fn repeated_get_unchecked(
      f: ::__pb::View<::__pb::Repeated<Self>>,
      i: usize,
    ) -> ::__pb::View<Self> {
      // SAFETY:
      // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
      // - `i < len(f)` is promised by caller.
      let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
      ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
    }
    fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
    }

    fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        let new_elem = __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_add(f.as_raw(::__pb::__internal::Private));
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_copy_from(new_elem, v.raw_msg());
      }
    }

    fn repeated_copy_from(
      src: ::__pb::View<::__pb::Repeated<Self>>,
      mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      // SAFETY:
      // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
      // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
      }
    }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Notary {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
          let key = key.as_bytes().into();
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(NotaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Notary_iter_get,
                  |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                  |raw_msg| NotaryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }

  #[allow(dead_code)]
  #[allow(non_camel_case_types)]
  pub struct NotaryMut<'msg> {
    inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
  }

  impl std::fmt::Debug for NotaryMut<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> NotaryMut<'msg> {
    #[doc(hidden)]
    pub fn from_parent(
               _private: ::__pb::__internal::Private,
               parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
               msg: ::__pb::__runtime::RawMessage)
      -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
                 ::__pb::__internal::Private, parent, msg)
      }
    }

    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
      Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
    }

    #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
    pub fn or_default(self) -> Self { self }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg()
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
      self.inner
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      ::__pb::ViewProxy::as_view(self).serialize()
    }


    // did: optional string
    pub fn did(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.did_mut().set(val);
    }
    fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Notary::__DID_VTABLE,
          )
        )
      }
    }

    // signature: optional bytes
    pub fn signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.signature_mut().set(val);
    }
    fn signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Notary::__SIGNATURE_VTABLE,
          )
        )
      }
    }

  }

  // SAFETY:
  // - `NotaryMut` does not perform any shared mutation.
  // - `NotaryMut` is not `Send`, and so even in the presence of mutator
  //   splitting, synchronous access of an arena is impossible.
  unsafe impl Sync for NotaryMut<'_> {}

  impl<'msg> ::__pb::MutProxy<'msg> for NotaryMut<'msg> {
    fn as_mut(&mut self) -> ::__pb::Mut<'_, Notary> {
      NotaryMut { inner: self.inner }
    }
    fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, Notary> where 'msg : 'shorter { self }
  }

  impl<'msg> ::__pb::ViewProxy<'msg> for NotaryMut<'msg> {
    type Proxied = Notary;
    fn as_view(&self) -> ::__pb::View<'_, Notary> {
      NotaryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Notary> where 'msg: 'shorter {
      NotaryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
  }

  #[allow(dead_code)]
  impl Notary {
    pub fn new() -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_new() } } }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
      ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
    }


    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      self.as_view().serialize()
    }
    #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
    pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      self.clear_and_parse(data)
    }
    pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      let success = unsafe {
        // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
        let data = ::__pb::__runtime::SerializedData::from_raw_parts(
          ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
          data.len(),
        );

        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_parse(self.raw_msg(), data)
      };
      success.then_some(()).ok_or(::__pb::ParseError)
    }
    pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
      let mut msg = Self::new();
      msg.clear_and_parse(data).map(|_| msg)
    }

    pub fn as_view(&self) -> NotaryView {
      NotaryView::new(::__pb::__internal::Private, self.inner.msg)
    }

    pub fn as_mut(&mut self) -> NotaryMut {
      NotaryMut::new(::__pb::__internal::Private, &mut self.inner)
    }

    // did: optional string
    pub fn did(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_did(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.did_mut().set(val);
    }
    const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_did,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_set_did,
      );
    fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Notary::__DID_VTABLE,
          )
        )
      }
    }

    // signature: optional bytes
    pub fn signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.signature_mut().set(val);
    }
    const __SIGNATURE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_signature,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_set_signature,
      );
    fn signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Notary::__SIGNATURE_VTABLE,
          )
        )
      }
    }

  }  // impl Notary

  impl ::__std::ops::Drop for Notary {
    fn drop(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_delete(self.raw_msg()); }
    }
  }

  extern "C" {
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_new() -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_delete(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_get_signature(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Notary_set_signature(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


  }  // extern "C" for Notary


  impl Notary {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg } }
    }
    pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      let s = std::mem::ManuallyDrop::new(self);
      s.raw_msg()
    }
  }

  impl<'a> NotaryMut<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
        msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
      }
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.raw_msg()
    }
  }

  impl<'a> NotaryView<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a ::__pb::__runtime::RawMessage) -> Self {
      Self::new(::__pb::__internal::Private, *msg)
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }
  }
  #[allow(non_camel_case_types)]
  pub struct Promissory {
    inner: ::__pb::__runtime::MessageInner
  }

  impl std::fmt::Debug for Promissory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  impl std::default::Default for Promissory {
    fn default() -> Self {
      Self::new()
    }
  }

  // SAFETY:
  // - `Promissory` is `Sync` because it does not implement interior mutability.
  //    Neither does `PromissoryMut`.
  unsafe impl Sync for Promissory {}

  // SAFETY:
  // - `Promissory` is `Send` because it uniquely owns its arena and does
  //   not use thread-local data.
  unsafe impl Send for Promissory {}

  impl ::__pb::Proxied for Promissory {
    type View<'msg> = PromissoryView<'msg>;
    type Mut<'msg> = PromissoryMut<'msg>;
  }

  #[derive(Copy, Clone)]
  #[allow(dead_code)]
  pub struct PromissoryView<'msg> {
    msg: ::__pb::__runtime::RawMessage,
    _phantom: ::__std::marker::PhantomData<&'msg ()>,
  }

  impl std::fmt::Debug for PromissoryView<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> PromissoryView<'msg> {
    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { msg, _phantom: ::__std::marker::PhantomData }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_serialize(self.raw_msg()) }
    }

    // version: optional string
    pub fn version(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_version(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // id: optional string
    pub fn id(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // currency: optional string
    pub fn currency(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_currency(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // amount: optional int64
    pub fn amount(self) -> i64 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_amount(self.raw_msg()) }
    }

    // decimals: optional uint32
    pub fn decimals(self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_decimals(self.raw_msg()) }
    }

    // authority: optional string
    pub fn authority(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authority(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // issuer: optional string
    pub fn issuer(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuer(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // issuance_date: optional string
    pub fn issuance_date(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuance_date(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // block_depth: optional uint32
    pub fn block_depth(self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_block_depth(self.raw_msg()) }
    }

    // authorization_signature: optional bytes
    pub fn authorization_signature(self) -> &'msg [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authorization_signature(self.raw_msg()).as_ref() };
      view
    }

    // transfer_signature: optional bytes
    pub fn transfer_signature(self) -> &'msg [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_transfer_signature(self.raw_msg()).as_ref() };
      view
    }

    // notaries: repeated message wallet_api.v1.ListAssetFilesResponse.Notary
    pub fn notaries(self) -> ::__pb::RepeatedView<'msg, crate::list_asset_files_response::Notary> {
      unsafe {
        ::__pb::RepeatedView::from_raw(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_notaries(self.raw_msg()),
        )
      }
    }

  }

  // SAFETY:
  // - `PromissoryView` is `Sync` because it does not support mutation.
  unsafe impl Sync for PromissoryView<'_> {}

  // SAFETY:
  // - `PromissoryView` is `Send` because while its alive a `PromissoryMut` cannot.
  // - `PromissoryView` does not use thread-local data.
  unsafe impl Send for PromissoryView<'_> {}

  impl<'msg> ::__pb::ViewProxy<'msg> for PromissoryView<'msg> {
    type Proxied = Promissory;

    fn as_view(&self) -> ::__pb::View<'msg, Promissory> {
      *self
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Promissory> where 'msg: 'shorter {
      self
    }
  }

  impl ::__pb::__internal::ProxiedWithRawVTable for Promissory {
    type VTable = ::__pb::__runtime::MessageVTable;

    fn make_view(_private: ::__pb::__internal::Private,
                mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::View<'_, Self> {
      let msg = unsafe {
        (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
      };
      PromissoryView::new(::__pb::__internal::Private, msg)
    }

    fn make_mut(_private: ::__pb::__internal::Private,
                inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::Mut<'_, Self> {
      let raw_submsg = unsafe {
        (inner.vtable().mut_getter)(inner.msg_ref().msg())
      };
      PromissoryMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
    }
  }

  impl ::__pb::__internal::ProxiedWithRawOptionalVTable for Promissory {
    type OptionalVTable = ::__pb::__runtime::MessageVTable;

    fn upcast_vtable(_private: ::__pb::__internal::Private,
                     optional_vtable: &'static Self::OptionalVTable)
                    -> &'static Self::VTable {
      &optional_vtable
    }
  }

  impl ::__pb::ProxiedWithPresence for Promissory {
    type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, Promissory>;
    type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, Promissory>;

    fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
       -> Self::AbsentMutData<'_> {
       // SAFETY: The raw ptr msg_ref is valid
      unsafe {
        (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         present_mutator.msg_ref(),
         present_mutator.optional_vtable())
      }
    }

    fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
       -> Self::PresentMutData<'_> {
     unsafe {
       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         absent_mutator.msg_ref(),
         absent_mutator.optional_vtable())
     }
    }
  }

  impl<'msg> ::__pb::SettableValue<Promissory> for PromissoryView<'msg> {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Promissory>)
      where Promissory: 'dst {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_copy_from(mutator.inner.msg(), self.msg) };
    }
  }

  impl ::__pb::SettableValue<Promissory> for Promissory {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Promissory>)
      where Promissory: 'dst {
      self.as_view().set_on(::__pb::__internal::Private, mutator);
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Promissory {
    fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_len(f.as_raw(::__pb::__internal::Private)) }
    }

    unsafe fn repeated_set_unchecked(
      mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
      i: usize,
      v: ::__pb::View<Self>,
    ) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `i < len(f)` is promised by caller.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_copy_from(
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
          v.raw_msg(),
        );
      }
    }

    unsafe fn repeated_get_unchecked(
      f: ::__pb::View<::__pb::Repeated<Self>>,
      i: usize,
    ) -> ::__pb::View<Self> {
      // SAFETY:
      // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
      // - `i < len(f)` is promised by caller.
      let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
      ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
    }
    fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
    }

    fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        let new_elem = __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_add(f.as_raw(::__pb::__internal::Private));
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_copy_from(new_elem, v.raw_msg());
      }
    }

    fn repeated_copy_from(
      src: ::__pb::View<::__pb::Repeated<Self>>,
      mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      // SAFETY:
      // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
      // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
      }
    }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Promissory {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
          let key = key.as_bytes().into();
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(PromissoryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Promissory_iter_get,
                  |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                  |raw_msg| PromissoryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }

  #[allow(dead_code)]
  #[allow(non_camel_case_types)]
  pub struct PromissoryMut<'msg> {
    inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
  }

  impl std::fmt::Debug for PromissoryMut<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> PromissoryMut<'msg> {
    #[doc(hidden)]
    pub fn from_parent(
               _private: ::__pb::__internal::Private,
               parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
               msg: ::__pb::__runtime::RawMessage)
      -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
                 ::__pb::__internal::Private, parent, msg)
      }
    }

    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
      Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
    }

    #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
    pub fn or_default(self) -> Self { self }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg()
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
      self.inner
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      ::__pb::ViewProxy::as_view(self).serialize()
    }


    // version: optional string
    pub fn version(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_version(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_version(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.version_mut().set(val);
    }
    fn version_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__VERSION_VTABLE,
          )
        )
      }
    }

    // id: optional string
    pub fn id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.id_mut().set(val);
    }
    fn id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ID_VTABLE,
          )
        )
      }
    }

    // currency: optional string
    pub fn currency(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_currency(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_currency(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.currency_mut().set(val);
    }
    fn currency_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__CURRENCY_VTABLE,
          )
        )
      }
    }

    // amount: optional int64
    pub fn amount(&self) -> i64 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_amount(self.raw_msg()) }
    }
    pub fn set_amount(&mut self, val: i64) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_amount(self.raw_msg(), val) }
    }

    // decimals: optional uint32
    pub fn decimals(&self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_decimals(self.raw_msg()) }
    }
    pub fn set_decimals(&mut self, val: u32) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_decimals(self.raw_msg(), val) }
    }

    // authority: optional string
    pub fn authority(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authority(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_authority(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.authority_mut().set(val);
    }
    fn authority_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__AUTHORITY_VTABLE,
          )
        )
      }
    }

    // issuer: optional string
    pub fn issuer(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuer(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_issuer(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.issuer_mut().set(val);
    }
    fn issuer_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ISSUER_VTABLE,
          )
        )
      }
    }

    // issuance_date: optional string
    pub fn issuance_date(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuance_date(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_issuance_date(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.issuance_date_mut().set(val);
    }
    fn issuance_date_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ISSUANCE_DATE_VTABLE,
          )
        )
      }
    }

    // block_depth: optional uint32
    pub fn block_depth(&self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_block_depth(self.raw_msg()) }
    }
    pub fn set_block_depth(&mut self, val: u32) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_block_depth(self.raw_msg(), val) }
    }

    // authorization_signature: optional bytes
    pub fn authorization_signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authorization_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_authorization_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.authorization_signature_mut().set(val);
    }
    fn authorization_signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__AUTHORIZATION_SIGNATURE_VTABLE,
          )
        )
      }
    }

    // transfer_signature: optional bytes
    pub fn transfer_signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_transfer_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_transfer_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.transfer_signature_mut().set(val);
    }
    fn transfer_signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__TRANSFER_SIGNATURE_VTABLE,
          )
        )
      }
    }

    // notaries: repeated message wallet_api.v1.ListAssetFilesResponse.Notary
    pub fn notaries(&self) -> ::__pb::RepeatedView<'_, crate::list_asset_files_response::Notary> {
      unsafe {
        ::__pb::RepeatedView::from_raw(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_notaries(self.raw_msg()),
        )
      }
    }
    pub fn notaries_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_asset_files_response::Notary> {
      unsafe {
        ::__pb::RepeatedMut::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__runtime::InnerRepeatedMut::new(
            ::__pb::__internal::Private,
            __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_mut_notaries(self.raw_msg()),
          ),
        )
      }
    }

  }

  // SAFETY:
  // - `PromissoryMut` does not perform any shared mutation.
  // - `PromissoryMut` is not `Send`, and so even in the presence of mutator
  //   splitting, synchronous access of an arena is impossible.
  unsafe impl Sync for PromissoryMut<'_> {}

  impl<'msg> ::__pb::MutProxy<'msg> for PromissoryMut<'msg> {
    fn as_mut(&mut self) -> ::__pb::Mut<'_, Promissory> {
      PromissoryMut { inner: self.inner }
    }
    fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, Promissory> where 'msg : 'shorter { self }
  }

  impl<'msg> ::__pb::ViewProxy<'msg> for PromissoryMut<'msg> {
    type Proxied = Promissory;
    fn as_view(&self) -> ::__pb::View<'_, Promissory> {
      PromissoryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Promissory> where 'msg: 'shorter {
      PromissoryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
  }

  #[allow(dead_code)]
  impl Promissory {
    pub fn new() -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_new() } } }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
      ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
    }


    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      self.as_view().serialize()
    }
    #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
    pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      self.clear_and_parse(data)
    }
    pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      let success = unsafe {
        // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
        let data = ::__pb::__runtime::SerializedData::from_raw_parts(
          ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
          data.len(),
        );

        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_parse(self.raw_msg(), data)
      };
      success.then_some(()).ok_or(::__pb::ParseError)
    }
    pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
      let mut msg = Self::new();
      msg.clear_and_parse(data).map(|_| msg)
    }

    pub fn as_view(&self) -> PromissoryView {
      PromissoryView::new(::__pb::__internal::Private, self.inner.msg)
    }

    pub fn as_mut(&mut self) -> PromissoryMut {
      PromissoryMut::new(::__pb::__internal::Private, &mut self.inner)
    }

    // version: optional string
    pub fn version(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_version(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_version(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.version_mut().set(val);
    }
    const __VERSION_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_version,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_version,
      );
    fn version_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__VERSION_VTABLE,
          )
        )
      }
    }

    // id: optional string
    pub fn id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.id_mut().set(val);
    }
    const __ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_id,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_id,
      );
    fn id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ID_VTABLE,
          )
        )
      }
    }

    // currency: optional string
    pub fn currency(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_currency(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_currency(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.currency_mut().set(val);
    }
    const __CURRENCY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_currency,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_currency,
      );
    fn currency_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__CURRENCY_VTABLE,
          )
        )
      }
    }

    // amount: optional int64
    pub fn amount(&self) -> i64 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_amount(self.raw_msg()) }
    }
    pub fn set_amount(&mut self, val: i64) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_amount(self.raw_msg(), val) }
    }

    // decimals: optional uint32
    pub fn decimals(&self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_decimals(self.raw_msg()) }
    }
    pub fn set_decimals(&mut self, val: u32) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_decimals(self.raw_msg(), val) }
    }

    // authority: optional string
    pub fn authority(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authority(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_authority(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.authority_mut().set(val);
    }
    const __AUTHORITY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authority,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_authority,
      );
    fn authority_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__AUTHORITY_VTABLE,
          )
        )
      }
    }

    // issuer: optional string
    pub fn issuer(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuer(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_issuer(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.issuer_mut().set(val);
    }
    const __ISSUER_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuer,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_issuer,
      );
    fn issuer_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ISSUER_VTABLE,
          )
        )
      }
    }

    // issuance_date: optional string
    pub fn issuance_date(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuance_date(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_issuance_date(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.issuance_date_mut().set(val);
    }
    const __ISSUANCE_DATE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuance_date,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_issuance_date,
      );
    fn issuance_date_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__ISSUANCE_DATE_VTABLE,
          )
        )
      }
    }

    // block_depth: optional uint32
    pub fn block_depth(&self) -> u32 {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_block_depth(self.raw_msg()) }
    }
    pub fn set_block_depth(&mut self, val: u32) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_block_depth(self.raw_msg(), val) }
    }

    // authorization_signature: optional bytes
    pub fn authorization_signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authorization_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_authorization_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.authorization_signature_mut().set(val);
    }
    const __AUTHORIZATION_SIGNATURE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authorization_signature,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_authorization_signature,
      );
    fn authorization_signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__AUTHORIZATION_SIGNATURE_VTABLE,
          )
        )
      }
    }

    // transfer_signature: optional bytes
    pub fn transfer_signature(&self) -> &'_ [u8] {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_transfer_signature(self.raw_msg()).as_ref() };
      view
    }
    pub fn set_transfer_signature(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
      self.transfer_signature_mut().set(val);
    }
    const __TRANSFER_SIGNATURE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_transfer_signature,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_transfer_signature,
      );
    fn transfer_signature_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
      unsafe {
        <::__pb::Mut<[u8]>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Promissory::__TRANSFER_SIGNATURE_VTABLE,
          )
        )
      }
    }

    // notaries: repeated message wallet_api.v1.ListAssetFilesResponse.Notary
    pub fn notaries(&self) -> ::__pb::RepeatedView<'_, crate::list_asset_files_response::Notary> {
      unsafe {
        ::__pb::RepeatedView::from_raw(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_notaries(self.raw_msg()),
        )
      }
    }
    pub fn notaries_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::list_asset_files_response::Notary> {
      unsafe {
        ::__pb::RepeatedMut::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__runtime::InnerRepeatedMut::new(
            ::__pb::__internal::Private,
            __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_mut_notaries(self.raw_msg()),
          ),
        )
      }
    }

  }  // impl Promissory

  impl ::__std::ops::Drop for Promissory {
    fn drop(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_delete(self.raw_msg()); }
    }
  }

  extern "C" {
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_new() -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_delete(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_version(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_version(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_currency(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_currency(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> i64;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_amount(raw_msg: ::__pb::__runtime::RawMessage, val: i64);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_decimals(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_decimals(raw_msg: ::__pb::__runtime::RawMessage, val: u32);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authority(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_authority(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuer(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_issuer(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_issuance_date(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_issuance_date(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_block_depth(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_block_depth(raw_msg: ::__pb::__runtime::RawMessage, val: u32);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_authorization_signature(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_authorization_signature(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_transfer_signature(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_set_transfer_signature(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_clear_notaries(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_mut_notaries(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Promissory_get_notaries(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;


  }  // extern "C" for Promissory


  impl Promissory {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg } }
    }
    pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      let s = std::mem::ManuallyDrop::new(self);
      s.raw_msg()
    }
  }

  impl<'a> PromissoryMut<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
        msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
      }
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.raw_msg()
    }
  }

  impl<'a> PromissoryView<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a ::__pb::__runtime::RawMessage) -> Self {
      Self::new(::__pb::__internal::Private, *msg)
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }
  }
  #[allow(non_camel_case_types)]
  pub struct Fund {
    inner: ::__pb::__runtime::MessageInner
  }

  impl std::fmt::Debug for Fund {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  impl std::default::Default for Fund {
    fn default() -> Self {
      Self::new()
    }
  }

  // SAFETY:
  // - `Fund` is `Sync` because it does not implement interior mutability.
  //    Neither does `FundMut`.
  unsafe impl Sync for Fund {}

  // SAFETY:
  // - `Fund` is `Send` because it uniquely owns its arena and does
  //   not use thread-local data.
  unsafe impl Send for Fund {}

  impl ::__pb::Proxied for Fund {
    type View<'msg> = FundView<'msg>;
    type Mut<'msg> = FundMut<'msg>;
  }

  #[derive(Copy, Clone)]
  #[allow(dead_code)]
  pub struct FundView<'msg> {
    msg: ::__pb::__runtime::RawMessage,
    _phantom: ::__std::marker::PhantomData<&'msg ()>,
  }

  impl std::fmt::Debug for FundView<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> FundView<'msg> {
    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { msg, _phantom: ::__std::marker::PhantomData }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_serialize(self.raw_msg()) }
    }

    // wallet_id: optional string
    pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // promissory: optional message wallet_api.v1.ListAssetFilesResponse.Promissory
    pub fn promissory(self) -> crate::list_asset_files_response::PromissoryView<'msg> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory(self.raw_msg()) };
      crate::list_asset_files_response::PromissoryView::new(::__pb::__internal::Private, submsg)
    }
    pub fn promissory_opt(self) ->
    ::__pb::Optional<crate::list_asset_files_response::PromissoryView<'msg>> {
      let view = self.promissory();
      ::__pb::Optional::new(view, self.has_promissory())
    }
    pub fn has_promissory(self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_has_promissory(self.raw_msg()) }
    }

    // reserved: optional bool
    pub fn reserved(self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_reserved(self.raw_msg()) }
    }

  }

  // SAFETY:
  // - `FundView` is `Sync` because it does not support mutation.
  unsafe impl Sync for FundView<'_> {}

  // SAFETY:
  // - `FundView` is `Send` because while its alive a `FundMut` cannot.
  // - `FundView` does not use thread-local data.
  unsafe impl Send for FundView<'_> {}

  impl<'msg> ::__pb::ViewProxy<'msg> for FundView<'msg> {
    type Proxied = Fund;

    fn as_view(&self) -> ::__pb::View<'msg, Fund> {
      *self
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Fund> where 'msg: 'shorter {
      self
    }
  }

  impl ::__pb::__internal::ProxiedWithRawVTable for Fund {
    type VTable = ::__pb::__runtime::MessageVTable;

    fn make_view(_private: ::__pb::__internal::Private,
                mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::View<'_, Self> {
      let msg = unsafe {
        (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
      };
      FundView::new(::__pb::__internal::Private, msg)
    }

    fn make_mut(_private: ::__pb::__internal::Private,
                inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::Mut<'_, Self> {
      let raw_submsg = unsafe {
        (inner.vtable().mut_getter)(inner.msg_ref().msg())
      };
      FundMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
    }
  }

  impl ::__pb::__internal::ProxiedWithRawOptionalVTable for Fund {
    type OptionalVTable = ::__pb::__runtime::MessageVTable;

    fn upcast_vtable(_private: ::__pb::__internal::Private,
                     optional_vtable: &'static Self::OptionalVTable)
                    -> &'static Self::VTable {
      &optional_vtable
    }
  }

  impl ::__pb::ProxiedWithPresence for Fund {
    type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, Fund>;
    type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, Fund>;

    fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
       -> Self::AbsentMutData<'_> {
       // SAFETY: The raw ptr msg_ref is valid
      unsafe {
        (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         present_mutator.msg_ref(),
         present_mutator.optional_vtable())
      }
    }

    fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
       -> Self::PresentMutData<'_> {
     unsafe {
       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         absent_mutator.msg_ref(),
         absent_mutator.optional_vtable())
     }
    }
  }

  impl<'msg> ::__pb::SettableValue<Fund> for FundView<'msg> {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Fund>)
      where Fund: 'dst {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_copy_from(mutator.inner.msg(), self.msg) };
    }
  }

  impl ::__pb::SettableValue<Fund> for Fund {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, Fund>)
      where Fund: 'dst {
      self.as_view().set_on(::__pb::__internal::Private, mutator);
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Fund {
    fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_len(f.as_raw(::__pb::__internal::Private)) }
    }

    unsafe fn repeated_set_unchecked(
      mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
      i: usize,
      v: ::__pb::View<Self>,
    ) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `i < len(f)` is promised by caller.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_copy_from(
          __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
          v.raw_msg(),
        );
      }
    }

    unsafe fn repeated_get_unchecked(
      f: ::__pb::View<::__pb::Repeated<Self>>,
      i: usize,
    ) -> ::__pb::View<Self> {
      // SAFETY:
      // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
      // - `i < len(f)` is promised by caller.
      let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
      ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
    }
    fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
    }

    fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        let new_elem = __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_add(f.as_raw(::__pb::__internal::Private));
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_copy_from(new_elem, v.raw_msg());
      }
    }

    fn repeated_copy_from(
      src: ::__pb::View<::__pb::Repeated<Self>>,
      mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      // SAFETY:
      // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
      // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
      }
    }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Fund {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
          let key = key.as_bytes().into();
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(FundView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListAssetFilesResponse_Fund_iter_get,
                  |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                  |raw_msg| FundView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }

  #[allow(dead_code)]
  #[allow(non_camel_case_types)]
  pub struct FundMut<'msg> {
    inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
  }

  impl std::fmt::Debug for FundMut<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> FundMut<'msg> {
    #[doc(hidden)]
    pub fn from_parent(
               _private: ::__pb::__internal::Private,
               parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
               msg: ::__pb::__runtime::RawMessage)
      -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
                 ::__pb::__internal::Private, parent, msg)
      }
    }

    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
      Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
    }

    #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
    pub fn or_default(self) -> Self { self }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg()
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
      self.inner
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      ::__pb::ViewProxy::as_view(self).serialize()
    }


    // wallet_id: optional string
    pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_id_mut().set(val);
    }
    fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Fund::__WALLET_ID_VTABLE,
          )
        )
      }
    }

    // promissory: optional message wallet_api.v1.ListAssetFilesResponse.Promissory
    pub fn promissory(&self) -> crate::list_asset_files_response::PromissoryView<'_> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory(self.raw_msg()) };
      crate::list_asset_files_response::PromissoryView::new(::__pb::__internal::Private, submsg)
    }
    pub fn promissory_mut(&mut self) -> crate::list_asset_files_response::PromissoryMut<'_> {
      self.promissory_entry().or_default()
    }
    fn promissory_entry(&mut self)
        -> ::__pb::FieldEntry<'_, crate::list_asset_files_response::Promissory> {
      static VTABLE: ::__pb::__runtime::MessageVTable =
        ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_mut_promissory,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_clear_promissory);
      unsafe {
        let has = self.has_promissory();
        ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          &VTABLE,
          has)
      }
    }
    pub fn promissory_opt(&self) ->
    ::__pb::Optional<crate::list_asset_files_response::PromissoryView<'_>> {
      let view = self.promissory();
      ::__pb::Optional::new(view, self.has_promissory())
    }
    pub fn set_promissory(&mut self, val: impl ::__pb::SettableValue<crate::list_asset_files_response::Promissory>) {
      self.promissory_entry().set(val);
    }
    pub fn has_promissory(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_has_promissory(self.raw_msg()) }
    }
    pub fn clear_promissory(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_clear_promissory(self.raw_msg()) }
    }

    // reserved: optional bool
    pub fn reserved(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_reserved(self.raw_msg()) }
    }
    pub fn set_reserved(&mut self, val: bool) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_set_reserved(self.raw_msg(), val) }
    }

  }

  // SAFETY:
  // - `FundMut` does not perform any shared mutation.
  // - `FundMut` is not `Send`, and so even in the presence of mutator
  //   splitting, synchronous access of an arena is impossible.
  unsafe impl Sync for FundMut<'_> {}

  impl<'msg> ::__pb::MutProxy<'msg> for FundMut<'msg> {
    fn as_mut(&mut self) -> ::__pb::Mut<'_, Fund> {
      FundMut { inner: self.inner }
    }
    fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, Fund> where 'msg : 'shorter { self }
  }

  impl<'msg> ::__pb::ViewProxy<'msg> for FundMut<'msg> {
    type Proxied = Fund;
    fn as_view(&self) -> ::__pb::View<'_, Fund> {
      FundView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Fund> where 'msg: 'shorter {
      FundView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
  }

  #[allow(dead_code)]
  impl Fund {
    pub fn new() -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_new() } } }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
      ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
    }


    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      self.as_view().serialize()
    }
    #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
    pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      self.clear_and_parse(data)
    }
    pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      let success = unsafe {
        // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
        let data = ::__pb::__runtime::SerializedData::from_raw_parts(
          ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
          data.len(),
        );

        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_parse(self.raw_msg(), data)
      };
      success.then_some(()).ok_or(::__pb::ParseError)
    }
    pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
      let mut msg = Self::new();
      msg.clear_and_parse(data).map(|_| msg)
    }

    pub fn as_view(&self) -> FundView {
      FundView::new(::__pb::__internal::Private, self.inner.msg)
    }

    pub fn as_mut(&mut self) -> FundMut {
      FundMut::new(::__pb::__internal::Private, &mut self.inner)
    }

    // wallet_id: optional string
    pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_wallet_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.wallet_id_mut().set(val);
    }
    const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_wallet_id,
        __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_set_wallet_id,
      );
    fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            Fund::__WALLET_ID_VTABLE,
          )
        )
      }
    }

    // promissory: optional message wallet_api.v1.ListAssetFilesResponse.Promissory
    pub fn promissory(&self) -> crate::list_asset_files_response::PromissoryView<'_> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory(self.raw_msg()) };
      crate::list_asset_files_response::PromissoryView::new(::__pb::__internal::Private, submsg)
    }
    pub fn promissory_mut(&mut self) -> crate::list_asset_files_response::PromissoryMut<'_> {
      self.promissory_entry().or_default()
    }
    fn promissory_entry(&mut self)
        -> ::__pb::FieldEntry<'_, crate::list_asset_files_response::Promissory> {
      static VTABLE: ::__pb::__runtime::MessageVTable =
        ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_mut_promissory,
                                  __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_clear_promissory);
      unsafe {
        let has = self.has_promissory();
        ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          &VTABLE,
          has)
      }
    }
    pub fn promissory_opt(&self) ->
    ::__pb::Optional<crate::list_asset_files_response::PromissoryView<'_>> {
      let view = self.promissory();
      ::__pb::Optional::new(view, self.has_promissory())
    }
    pub fn set_promissory(&mut self, val: impl ::__pb::SettableValue<crate::list_asset_files_response::Promissory>) {
      self.promissory_entry().set(val);
    }
    pub fn has_promissory(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_has_promissory(self.raw_msg()) }
    }
    pub fn clear_promissory(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_clear_promissory(self.raw_msg()) }
    }

    // reserved: optional bool
    pub fn reserved(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_reserved(self.raw_msg()) }
    }
    pub fn set_reserved(&mut self, val: bool) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_set_reserved(self.raw_msg(), val) }
    }

  }  // impl Fund

  impl ::__std::ops::Drop for Fund {
    fn drop(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_delete(self.raw_msg()); }
    }
  }

  extern "C" {
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_new() -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_delete(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_promissory(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_mut_promissory(raw_msg: ::__pb::__runtime::RawMessage)
       -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_clear_promissory(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_has_promissory(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_get_reserved(raw_msg: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_ListAssetFilesResponse_Fund_set_reserved(raw_msg: ::__pb::__runtime::RawMessage, val: bool);


  }  // extern "C" for Fund


  impl Fund {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg } }
    }
    pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      let s = std::mem::ManuallyDrop::new(self);
      s.raw_msg()
    }
  }

  impl<'a> FundMut<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
        msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
      }
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.raw_msg()
    }
  }

  impl<'a> FundView<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a ::__pb::__runtime::RawMessage) -> Self {
      Self::new(::__pb::__internal::Private, *msg)
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }
  }

}  // mod list_asset_files_response

impl ListAssetFilesResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListAssetFilesResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListAssetFilesResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListCredentialsRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListCredentialsRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListCredentialsRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListCredentialsRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListCredentialsRequestMut`.
unsafe impl Sync for ListCredentialsRequest {}

// SAFETY:
// - `ListCredentialsRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListCredentialsRequest {}

impl ::__pb::Proxied for ListCredentialsRequest {
  type View<'msg> = ListCredentialsRequestView<'msg>;
  type Mut<'msg> = ListCredentialsRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListCredentialsRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListCredentialsRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListCredentialsRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_serialize(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page(self.raw_msg()) }
  }

  // page_size: optional int32
  pub fn page_size(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page_size(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // filters: optional message common.Filter
  pub fn filters(self) -> crate::FilterView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_opt(self) ->
  ::__pb::Optional<crate::FilterView<'msg>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn has_filters(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(self) -> crate::SortByView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_opt(self) ->
  ::__pb::Optional<crate::SortByView<'msg>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn has_sort_by(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListCredentialsRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListCredentialsRequestView<'_> {}

// SAFETY:
// - `ListCredentialsRequestView` is `Send` because while its alive a `ListCredentialsRequestMut` cannot.
// - `ListCredentialsRequestView` does not use thread-local data.
unsafe impl Send for ListCredentialsRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListCredentialsRequestView<'msg> {
  type Proxied = ListCredentialsRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListCredentialsRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListCredentialsRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListCredentialsRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListCredentialsRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListCredentialsRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListCredentialsRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListCredentialsRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListCredentialsRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListCredentialsRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListCredentialsRequest> for ListCredentialsRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListCredentialsRequest>)
    where ListCredentialsRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListCredentialsRequest> for ListCredentialsRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListCredentialsRequest>)
    where ListCredentialsRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListCredentialsRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListCredentialsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListCredentialsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListCredentialsRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListCredentialsRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListCredentialsRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page_size(self.raw_msg(), val) }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListCredentialsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListCredentialsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListCredentialsRequestMut` does not perform any shared mutation.
// - `ListCredentialsRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListCredentialsRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListCredentialsRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListCredentialsRequest> {
    ListCredentialsRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListCredentialsRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListCredentialsRequestMut<'msg> {
  type Proxied = ListCredentialsRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListCredentialsRequest> {
    ListCredentialsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListCredentialsRequest> where 'msg: 'shorter {
    ListCredentialsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListCredentialsRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListCredentialsRequestView {
    ListCredentialsRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListCredentialsRequestMut {
    ListCredentialsRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page_size(self.raw_msg(), val) }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListCredentialsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListCredentialsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_filters(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_sort_by(self.raw_msg()) }
  }

}  // impl ListCredentialsRequest

impl ::__std::ops::Drop for ListCredentialsRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_page_size(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_page_size(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_filters(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_filters(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_filters(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_filters(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_get_mut_sort_by(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_clear_sort_by(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsRequest_has_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> bool;


}  // extern "C" for ListCredentialsRequest


impl ListCredentialsRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListCredentialsRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListCredentialsRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListCredentialsResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListCredentialsResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListCredentialsResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListCredentialsResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListCredentialsResponseMut`.
unsafe impl Sync for ListCredentialsResponse {}

// SAFETY:
// - `ListCredentialsResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListCredentialsResponse {}

impl ::__pb::Proxied for ListCredentialsResponse {
  type View<'msg> = ListCredentialsResponseView<'msg>;
  type Mut<'msg> = ListCredentialsResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListCredentialsResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListCredentialsResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListCredentialsResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_serialize(self.raw_msg()) }
  }

  // credentials: repeated string
  pub fn credentials(self) -> ::__pb::RepeatedView<'msg, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_credentials(self.raw_msg()),
      )
    }
  }

  // total_owned_credentials: optional uint32
  pub fn total_owned_credentials(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_total_owned_credentials(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListCredentialsResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListCredentialsResponseView<'_> {}

// SAFETY:
// - `ListCredentialsResponseView` is `Send` because while its alive a `ListCredentialsResponseMut` cannot.
// - `ListCredentialsResponseView` does not use thread-local data.
unsafe impl Send for ListCredentialsResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListCredentialsResponseView<'msg> {
  type Proxied = ListCredentialsResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListCredentialsResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListCredentialsResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListCredentialsResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListCredentialsResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListCredentialsResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListCredentialsResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListCredentialsResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListCredentialsResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListCredentialsResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListCredentialsResponse> for ListCredentialsResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListCredentialsResponse>)
    where ListCredentialsResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListCredentialsResponse> for ListCredentialsResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListCredentialsResponse>)
    where ListCredentialsResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListCredentialsResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListCredentialsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListCredentialsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListCredentialsResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListCredentialsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListCredentialsResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListCredentialsResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListCredentialsResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // credentials: repeated string
  pub fn credentials(&self) -> ::__pb::RepeatedView<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_credentials(self.raw_msg()),
      )
    }
  }
  pub fn credentials_mut(&mut self) -> ::__pb::RepeatedMut<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_mut_credentials(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_credentials: optional uint32
  pub fn total_owned_credentials(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_total_owned_credentials(self.raw_msg()) }
  }
  pub fn set_total_owned_credentials(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_set_total_owned_credentials(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `ListCredentialsResponseMut` does not perform any shared mutation.
// - `ListCredentialsResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListCredentialsResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListCredentialsResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListCredentialsResponse> {
    ListCredentialsResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListCredentialsResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListCredentialsResponseMut<'msg> {
  type Proxied = ListCredentialsResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListCredentialsResponse> {
    ListCredentialsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListCredentialsResponse> where 'msg: 'shorter {
    ListCredentialsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListCredentialsResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListCredentialsResponseView {
    ListCredentialsResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListCredentialsResponseMut {
    ListCredentialsResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // credentials: repeated string
  pub fn credentials(&self) -> ::__pb::RepeatedView<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_credentials(self.raw_msg()),
      )
    }
  }
  pub fn credentials_mut(&mut self) -> ::__pb::RepeatedMut<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_mut_credentials(self.raw_msg()),
        ),
      )
    }
  }

  // total_owned_credentials: optional uint32
  pub fn total_owned_credentials(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_total_owned_credentials(self.raw_msg()) }
  }
  pub fn set_total_owned_credentials(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_set_total_owned_credentials(self.raw_msg(), val) }
  }

}  // impl ListCredentialsResponse

impl ::__std::ops::Drop for ListCredentialsResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_clear_credentials(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_mut_credentials(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_credentials(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_get_total_owned_credentials(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_ListCredentialsResponse_set_total_owned_credentials(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for ListCredentialsResponse


impl ListCredentialsResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListCredentialsResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListCredentialsResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct AddCredentialRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for AddCredentialRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for AddCredentialRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `AddCredentialRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `AddCredentialRequestMut`.
unsafe impl Sync for AddCredentialRequest {}

// SAFETY:
// - `AddCredentialRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for AddCredentialRequest {}

impl ::__pb::Proxied for AddCredentialRequest {
  type View<'msg> = AddCredentialRequestView<'msg>;
  type Mut<'msg> = AddCredentialRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct AddCredentialRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for AddCredentialRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AddCredentialRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_serialize(self.raw_msg()) }
  }

  // credential_type: optional string
  pub fn credential_type(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `AddCredentialRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for AddCredentialRequestView<'_> {}

// SAFETY:
// - `AddCredentialRequestView` is `Send` because while its alive a `AddCredentialRequestMut` cannot.
// - `AddCredentialRequestView` does not use thread-local data.
unsafe impl Send for AddCredentialRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for AddCredentialRequestView<'msg> {
  type Proxied = AddCredentialRequest;

  fn as_view(&self) -> ::__pb::View<'msg, AddCredentialRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AddCredentialRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for AddCredentialRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    AddCredentialRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    AddCredentialRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for AddCredentialRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for AddCredentialRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, AddCredentialRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, AddCredentialRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<AddCredentialRequest> for AddCredentialRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AddCredentialRequest>)
    where AddCredentialRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<AddCredentialRequest> for AddCredentialRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AddCredentialRequest>)
    where AddCredentialRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for AddCredentialRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for AddCredentialRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| AddCredentialRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct AddCredentialRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for AddCredentialRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AddCredentialRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // credential_type: optional string
  pub fn credential_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_type_mut().set(val);
  }
  fn credential_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__CREDENTIAL_TYPE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `AddCredentialRequestMut` does not perform any shared mutation.
// - `AddCredentialRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for AddCredentialRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for AddCredentialRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, AddCredentialRequest> {
    AddCredentialRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, AddCredentialRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for AddCredentialRequestMut<'msg> {
  type Proxied = AddCredentialRequest;
  fn as_view(&self) -> ::__pb::View<'_, AddCredentialRequest> {
    AddCredentialRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AddCredentialRequest> where 'msg: 'shorter {
    AddCredentialRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl AddCredentialRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> AddCredentialRequestView {
    AddCredentialRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> AddCredentialRequestMut {
    AddCredentialRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // credential_type: optional string
  pub fn credential_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_type_mut().set(val);
  }
  const __CREDENTIAL_TYPE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_credential_type,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_credential_type,
    );
  fn credential_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__CREDENTIAL_TYPE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl AddCredentialRequest

impl ::__std::ops::Drop for AddCredentialRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_credential_type(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_credential_type(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for AddCredentialRequest


impl AddCredentialRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> AddCredentialRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> AddCredentialRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct AddCredentialResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for AddCredentialResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for AddCredentialResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `AddCredentialResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `AddCredentialResponseMut`.
unsafe impl Sync for AddCredentialResponse {}

// SAFETY:
// - `AddCredentialResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for AddCredentialResponse {}

impl ::__pb::Proxied for AddCredentialResponse {
  type View<'msg> = AddCredentialResponseView<'msg>;
  type Mut<'msg> = AddCredentialResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct AddCredentialResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for AddCredentialResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AddCredentialResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_serialize(self.raw_msg()) }
  }

  // credential: optional string
  pub fn credential(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_get_credential(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `AddCredentialResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for AddCredentialResponseView<'_> {}

// SAFETY:
// - `AddCredentialResponseView` is `Send` because while its alive a `AddCredentialResponseMut` cannot.
// - `AddCredentialResponseView` does not use thread-local data.
unsafe impl Send for AddCredentialResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for AddCredentialResponseView<'msg> {
  type Proxied = AddCredentialResponse;

  fn as_view(&self) -> ::__pb::View<'msg, AddCredentialResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AddCredentialResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for AddCredentialResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    AddCredentialResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    AddCredentialResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for AddCredentialResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for AddCredentialResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, AddCredentialResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, AddCredentialResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<AddCredentialResponse> for AddCredentialResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AddCredentialResponse>)
    where AddCredentialResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<AddCredentialResponse> for AddCredentialResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AddCredentialResponse>)
    where AddCredentialResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for AddCredentialResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for AddCredentialResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AddCredentialResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AddCredentialResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| AddCredentialResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct AddCredentialResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for AddCredentialResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AddCredentialResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // credential: optional string
  pub fn credential(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_get_credential(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_mut().set(val);
  }
  fn credential_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialResponse::__CREDENTIAL_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `AddCredentialResponseMut` does not perform any shared mutation.
// - `AddCredentialResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for AddCredentialResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for AddCredentialResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, AddCredentialResponse> {
    AddCredentialResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, AddCredentialResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for AddCredentialResponseMut<'msg> {
  type Proxied = AddCredentialResponse;
  fn as_view(&self) -> ::__pb::View<'_, AddCredentialResponse> {
    AddCredentialResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AddCredentialResponse> where 'msg: 'shorter {
    AddCredentialResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl AddCredentialResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> AddCredentialResponseView {
    AddCredentialResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> AddCredentialResponseMut {
    AddCredentialResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // credential: optional string
  pub fn credential(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_get_credential(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_mut().set(val);
  }
  const __CREDENTIAL_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_get_credential,
      __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_set_credential,
    );
  fn credential_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AddCredentialResponse::__CREDENTIAL_VTABLE,
        )
      )
    }
  }

}  // impl AddCredentialResponse

impl ::__std::ops::Drop for AddCredentialResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_get_credential(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AddCredentialResponse_set_credential(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for AddCredentialResponse


impl AddCredentialResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> AddCredentialResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> AddCredentialResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct AssociateWalletRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for AssociateWalletRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for AssociateWalletRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `AssociateWalletRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `AssociateWalletRequestMut`.
unsafe impl Sync for AssociateWalletRequest {}

// SAFETY:
// - `AssociateWalletRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for AssociateWalletRequest {}

impl ::__pb::Proxied for AssociateWalletRequest {
  type View<'msg> = AssociateWalletRequestView<'msg>;
  type Mut<'msg> = AssociateWalletRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct AssociateWalletRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for AssociateWalletRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AssociateWalletRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `AssociateWalletRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for AssociateWalletRequestView<'_> {}

// SAFETY:
// - `AssociateWalletRequestView` is `Send` because while its alive a `AssociateWalletRequestMut` cannot.
// - `AssociateWalletRequestView` does not use thread-local data.
unsafe impl Send for AssociateWalletRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for AssociateWalletRequestView<'msg> {
  type Proxied = AssociateWalletRequest;

  fn as_view(&self) -> ::__pb::View<'msg, AssociateWalletRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AssociateWalletRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for AssociateWalletRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    AssociateWalletRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    AssociateWalletRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for AssociateWalletRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for AssociateWalletRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, AssociateWalletRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, AssociateWalletRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<AssociateWalletRequest> for AssociateWalletRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AssociateWalletRequest>)
    where AssociateWalletRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<AssociateWalletRequest> for AssociateWalletRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AssociateWalletRequest>)
    where AssociateWalletRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for AssociateWalletRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for AssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| AssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct AssociateWalletRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for AssociateWalletRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AssociateWalletRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `AssociateWalletRequestMut` does not perform any shared mutation.
// - `AssociateWalletRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for AssociateWalletRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for AssociateWalletRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, AssociateWalletRequest> {
    AssociateWalletRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, AssociateWalletRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for AssociateWalletRequestMut<'msg> {
  type Proxied = AssociateWalletRequest;
  fn as_view(&self) -> ::__pb::View<'_, AssociateWalletRequest> {
    AssociateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AssociateWalletRequest> where 'msg: 'shorter {
    AssociateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl AssociateWalletRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> AssociateWalletRequestView {
    AssociateWalletRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> AssociateWalletRequestMut {
    AssociateWalletRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl AssociateWalletRequest

impl ::__std::ops::Drop for AssociateWalletRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for AssociateWalletRequest


impl AssociateWalletRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> AssociateWalletRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> AssociateWalletRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct AssociateWalletResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for AssociateWalletResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for AssociateWalletResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `AssociateWalletResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `AssociateWalletResponseMut`.
unsafe impl Sync for AssociateWalletResponse {}

// SAFETY:
// - `AssociateWalletResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for AssociateWalletResponse {}

impl ::__pb::Proxied for AssociateWalletResponse {
  type View<'msg> = AssociateWalletResponseView<'msg>;
  type Mut<'msg> = AssociateWalletResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct AssociateWalletResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for AssociateWalletResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AssociateWalletResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // did: optional string
  pub fn did(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // public_key: optional string
  pub fn public_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `AssociateWalletResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for AssociateWalletResponseView<'_> {}

// SAFETY:
// - `AssociateWalletResponseView` is `Send` because while its alive a `AssociateWalletResponseMut` cannot.
// - `AssociateWalletResponseView` does not use thread-local data.
unsafe impl Send for AssociateWalletResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for AssociateWalletResponseView<'msg> {
  type Proxied = AssociateWalletResponse;

  fn as_view(&self) -> ::__pb::View<'msg, AssociateWalletResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AssociateWalletResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for AssociateWalletResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    AssociateWalletResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    AssociateWalletResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for AssociateWalletResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for AssociateWalletResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, AssociateWalletResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, AssociateWalletResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<AssociateWalletResponse> for AssociateWalletResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AssociateWalletResponse>)
    where AssociateWalletResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<AssociateWalletResponse> for AssociateWalletResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, AssociateWalletResponse>)
    where AssociateWalletResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for AssociateWalletResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for AssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(AssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_AssociateWalletResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| AssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct AssociateWalletResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for AssociateWalletResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> AssociateWalletResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `AssociateWalletResponseMut` does not perform any shared mutation.
// - `AssociateWalletResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for AssociateWalletResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for AssociateWalletResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, AssociateWalletResponse> {
    AssociateWalletResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, AssociateWalletResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for AssociateWalletResponseMut<'msg> {
  type Proxied = AssociateWalletResponse;
  fn as_view(&self) -> ::__pb::View<'_, AssociateWalletResponse> {
    AssociateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, AssociateWalletResponse> where 'msg: 'shorter {
    AssociateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl AssociateWalletResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> AssociateWalletResponseView {
    AssociateWalletResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> AssociateWalletResponseMut {
    AssociateWalletResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_did,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_did,
    );
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  const __PUBLIC_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_public_key,
      __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_public_key,
    );
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          AssociateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

}  // impl AssociateWalletResponse

impl ::__std::ops::Drop for AssociateWalletResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_get_public_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_AssociateWalletResponse_set_public_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for AssociateWalletResponse


impl AssociateWalletResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> AssociateWalletResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> AssociateWalletResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct CreateAndAssociateWalletRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateAndAssociateWalletRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateAndAssociateWalletRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateAndAssociateWalletRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateAndAssociateWalletRequestMut`.
unsafe impl Sync for CreateAndAssociateWalletRequest {}

// SAFETY:
// - `CreateAndAssociateWalletRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateAndAssociateWalletRequest {}

impl ::__pb::Proxied for CreateAndAssociateWalletRequest {
  type View<'msg> = CreateAndAssociateWalletRequestView<'msg>;
  type Mut<'msg> = CreateAndAssociateWalletRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateAndAssociateWalletRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateAndAssociateWalletRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateAndAssociateWalletRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_serialize(self.raw_msg()) }
  }

  // wallet_name: optional string
  pub fn wallet_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // token: optional string
  pub fn token(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_token(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateAndAssociateWalletRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateAndAssociateWalletRequestView<'_> {}

// SAFETY:
// - `CreateAndAssociateWalletRequestView` is `Send` because while its alive a `CreateAndAssociateWalletRequestMut` cannot.
// - `CreateAndAssociateWalletRequestView` does not use thread-local data.
unsafe impl Send for CreateAndAssociateWalletRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateAndAssociateWalletRequestView<'msg> {
  type Proxied = CreateAndAssociateWalletRequest;

  fn as_view(&self) -> ::__pb::View<'msg, CreateAndAssociateWalletRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateAndAssociateWalletRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateAndAssociateWalletRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateAndAssociateWalletRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateAndAssociateWalletRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateAndAssociateWalletRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateAndAssociateWalletRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateAndAssociateWalletRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateAndAssociateWalletRequest> for CreateAndAssociateWalletRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateAndAssociateWalletRequest>)
    where CreateAndAssociateWalletRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateAndAssociateWalletRequest> for CreateAndAssociateWalletRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateAndAssociateWalletRequest>)
    where CreateAndAssociateWalletRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateAndAssociateWalletRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateAndAssociateWalletRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateAndAssociateWalletRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateAndAssociateWalletRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateAndAssociateWalletRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // token: optional string
  pub fn token(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_token(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_token(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.token_mut().set(val);
  }
  fn token_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__TOKEN_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateAndAssociateWalletRequestMut` does not perform any shared mutation.
// - `CreateAndAssociateWalletRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateAndAssociateWalletRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateAndAssociateWalletRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateAndAssociateWalletRequest> {
    CreateAndAssociateWalletRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateAndAssociateWalletRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateAndAssociateWalletRequestMut<'msg> {
  type Proxied = CreateAndAssociateWalletRequest;
  fn as_view(&self) -> ::__pb::View<'_, CreateAndAssociateWalletRequest> {
    CreateAndAssociateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateAndAssociateWalletRequest> where 'msg: 'shorter {
    CreateAndAssociateWalletRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateAndAssociateWalletRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateAndAssociateWalletRequestView {
    CreateAndAssociateWalletRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateAndAssociateWalletRequestMut {
    CreateAndAssociateWalletRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  const __WALLET_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_wallet_name,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_wallet_name,
    );
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // token: optional string
  pub fn token(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_token(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_token(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.token_mut().set(val);
  }
  const __TOKEN_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_token,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_token,
    );
  fn token_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletRequest::__TOKEN_VTABLE,
        )
      )
    }
  }

}  // impl CreateAndAssociateWalletRequest

impl ::__std::ops::Drop for CreateAndAssociateWalletRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_wallet_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_wallet_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_get_token(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletRequest_set_token(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateAndAssociateWalletRequest


impl CreateAndAssociateWalletRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateAndAssociateWalletRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateAndAssociateWalletRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct CreateAndAssociateWalletResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for CreateAndAssociateWalletResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for CreateAndAssociateWalletResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `CreateAndAssociateWalletResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `CreateAndAssociateWalletResponseMut`.
unsafe impl Sync for CreateAndAssociateWalletResponse {}

// SAFETY:
// - `CreateAndAssociateWalletResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for CreateAndAssociateWalletResponse {}

impl ::__pb::Proxied for CreateAndAssociateWalletResponse {
  type View<'msg> = CreateAndAssociateWalletResponseView<'msg>;
  type Mut<'msg> = CreateAndAssociateWalletResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct CreateAndAssociateWalletResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for CreateAndAssociateWalletResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateAndAssociateWalletResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_name: optional string
  pub fn wallet_name(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // public_key: optional string
  pub fn public_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // did: optional string
  pub fn did(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `CreateAndAssociateWalletResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for CreateAndAssociateWalletResponseView<'_> {}

// SAFETY:
// - `CreateAndAssociateWalletResponseView` is `Send` because while its alive a `CreateAndAssociateWalletResponseMut` cannot.
// - `CreateAndAssociateWalletResponseView` does not use thread-local data.
unsafe impl Send for CreateAndAssociateWalletResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateAndAssociateWalletResponseView<'msg> {
  type Proxied = CreateAndAssociateWalletResponse;

  fn as_view(&self) -> ::__pb::View<'msg, CreateAndAssociateWalletResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateAndAssociateWalletResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for CreateAndAssociateWalletResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    CreateAndAssociateWalletResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for CreateAndAssociateWalletResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for CreateAndAssociateWalletResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, CreateAndAssociateWalletResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, CreateAndAssociateWalletResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<CreateAndAssociateWalletResponse> for CreateAndAssociateWalletResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateAndAssociateWalletResponse>)
    where CreateAndAssociateWalletResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<CreateAndAssociateWalletResponse> for CreateAndAssociateWalletResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, CreateAndAssociateWalletResponse>)
    where CreateAndAssociateWalletResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for CreateAndAssociateWalletResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for CreateAndAssociateWalletResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_CreateAndAssociateWalletResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct CreateAndAssociateWalletResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for CreateAndAssociateWalletResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> CreateAndAssociateWalletResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `CreateAndAssociateWalletResponseMut` does not perform any shared mutation.
// - `CreateAndAssociateWalletResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for CreateAndAssociateWalletResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for CreateAndAssociateWalletResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, CreateAndAssociateWalletResponse> {
    CreateAndAssociateWalletResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, CreateAndAssociateWalletResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for CreateAndAssociateWalletResponseMut<'msg> {
  type Proxied = CreateAndAssociateWalletResponse;
  fn as_view(&self) -> ::__pb::View<'_, CreateAndAssociateWalletResponse> {
    CreateAndAssociateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, CreateAndAssociateWalletResponse> where 'msg: 'shorter {
    CreateAndAssociateWalletResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl CreateAndAssociateWalletResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> CreateAndAssociateWalletResponseView {
    CreateAndAssociateWalletResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> CreateAndAssociateWalletResponseMut {
    CreateAndAssociateWalletResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // wallet_name: optional string
  pub fn wallet_name(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_name(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_name(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_name_mut().set(val);
  }
  const __WALLET_NAME_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_name,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_wallet_name,
    );
  fn wallet_name_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__WALLET_NAME_VTABLE,
        )
      )
    }
  }

  // public_key: optional string
  pub fn public_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_public_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_public_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.public_key_mut().set(val);
  }
  const __PUBLIC_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_public_key,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_public_key,
    );
  fn public_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__PUBLIC_KEY_VTABLE,
        )
      )
    }
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_did,
      __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_did,
    );
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          CreateAndAssociateWalletResponse::__DID_VTABLE,
        )
      )
    }
  }

}  // impl CreateAndAssociateWalletResponse

impl ::__std::ops::Drop for CreateAndAssociateWalletResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_wallet_name(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_wallet_name(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_public_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_public_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_CreateAndAssociateWalletResponse_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for CreateAndAssociateWalletResponse


impl CreateAndAssociateWalletResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> CreateAndAssociateWalletResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> CreateAndAssociateWalletResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct RequestPresentationRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for RequestPresentationRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for RequestPresentationRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `RequestPresentationRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `RequestPresentationRequestMut`.
unsafe impl Sync for RequestPresentationRequest {}

// SAFETY:
// - `RequestPresentationRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for RequestPresentationRequest {}

impl ::__pb::Proxied for RequestPresentationRequest {
  type View<'msg> = RequestPresentationRequestView<'msg>;
  type Mut<'msg> = RequestPresentationRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct RequestPresentationRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for RequestPresentationRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> RequestPresentationRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_serialize(self.raw_msg()) }
  }

  // did: optional string
  pub fn did(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // credential_type: optional string
  pub fn credential_type(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `RequestPresentationRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for RequestPresentationRequestView<'_> {}

// SAFETY:
// - `RequestPresentationRequestView` is `Send` because while its alive a `RequestPresentationRequestMut` cannot.
// - `RequestPresentationRequestView` does not use thread-local data.
unsafe impl Send for RequestPresentationRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for RequestPresentationRequestView<'msg> {
  type Proxied = RequestPresentationRequest;

  fn as_view(&self) -> ::__pb::View<'msg, RequestPresentationRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, RequestPresentationRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for RequestPresentationRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    RequestPresentationRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    RequestPresentationRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for RequestPresentationRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for RequestPresentationRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, RequestPresentationRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, RequestPresentationRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<RequestPresentationRequest> for RequestPresentationRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, RequestPresentationRequest>)
    where RequestPresentationRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<RequestPresentationRequest> for RequestPresentationRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, RequestPresentationRequest>)
    where RequestPresentationRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for RequestPresentationRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for RequestPresentationRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| RequestPresentationRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct RequestPresentationRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for RequestPresentationRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> RequestPresentationRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__DID_VTABLE,
        )
      )
    }
  }

  // credential_type: optional string
  pub fn credential_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_type_mut().set(val);
  }
  fn credential_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__CREDENTIAL_TYPE_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `RequestPresentationRequestMut` does not perform any shared mutation.
// - `RequestPresentationRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for RequestPresentationRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for RequestPresentationRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, RequestPresentationRequest> {
    RequestPresentationRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, RequestPresentationRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for RequestPresentationRequestMut<'msg> {
  type Proxied = RequestPresentationRequest;
  fn as_view(&self) -> ::__pb::View<'_, RequestPresentationRequest> {
    RequestPresentationRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, RequestPresentationRequest> where 'msg: 'shorter {
    RequestPresentationRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl RequestPresentationRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> RequestPresentationRequestView {
    RequestPresentationRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> RequestPresentationRequestMut {
    RequestPresentationRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // did: optional string
  pub fn did(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_did(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_did(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.did_mut().set(val);
  }
  const __DID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_did,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_did,
    );
  fn did_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__DID_VTABLE,
        )
      )
    }
  }

  // credential_type: optional string
  pub fn credential_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_credential_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_credential_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.credential_type_mut().set(val);
  }
  const __CREDENTIAL_TYPE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_credential_type,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_credential_type,
    );
  fn credential_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__CREDENTIAL_TYPE_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl RequestPresentationRequest

impl ::__std::ops::Drop for RequestPresentationRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_did(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_did(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_credential_type(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_credential_type(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for RequestPresentationRequest


impl RequestPresentationRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> RequestPresentationRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> RequestPresentationRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct RequestPresentationResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for RequestPresentationResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for RequestPresentationResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `RequestPresentationResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `RequestPresentationResponseMut`.
unsafe impl Sync for RequestPresentationResponse {}

// SAFETY:
// - `RequestPresentationResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for RequestPresentationResponse {}

impl ::__pb::Proxied for RequestPresentationResponse {
  type View<'msg> = RequestPresentationResponseView<'msg>;
  type Mut<'msg> = RequestPresentationResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct RequestPresentationResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for RequestPresentationResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> RequestPresentationResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_serialize(self.raw_msg()) }
  }

  // presentation: optional string
  pub fn presentation(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_get_presentation(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `RequestPresentationResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for RequestPresentationResponseView<'_> {}

// SAFETY:
// - `RequestPresentationResponseView` is `Send` because while its alive a `RequestPresentationResponseMut` cannot.
// - `RequestPresentationResponseView` does not use thread-local data.
unsafe impl Send for RequestPresentationResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for RequestPresentationResponseView<'msg> {
  type Proxied = RequestPresentationResponse;

  fn as_view(&self) -> ::__pb::View<'msg, RequestPresentationResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, RequestPresentationResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for RequestPresentationResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    RequestPresentationResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    RequestPresentationResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for RequestPresentationResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for RequestPresentationResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, RequestPresentationResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, RequestPresentationResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<RequestPresentationResponse> for RequestPresentationResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, RequestPresentationResponse>)
    where RequestPresentationResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<RequestPresentationResponse> for RequestPresentationResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, RequestPresentationResponse>)
    where RequestPresentationResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for RequestPresentationResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for RequestPresentationResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(RequestPresentationResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_RequestPresentationResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| RequestPresentationResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct RequestPresentationResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for RequestPresentationResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> RequestPresentationResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // presentation: optional string
  pub fn presentation(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_get_presentation(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_presentation(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.presentation_mut().set(val);
  }
  fn presentation_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationResponse::__PRESENTATION_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `RequestPresentationResponseMut` does not perform any shared mutation.
// - `RequestPresentationResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for RequestPresentationResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for RequestPresentationResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, RequestPresentationResponse> {
    RequestPresentationResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, RequestPresentationResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for RequestPresentationResponseMut<'msg> {
  type Proxied = RequestPresentationResponse;
  fn as_view(&self) -> ::__pb::View<'_, RequestPresentationResponse> {
    RequestPresentationResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, RequestPresentationResponse> where 'msg: 'shorter {
    RequestPresentationResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl RequestPresentationResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> RequestPresentationResponseView {
    RequestPresentationResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> RequestPresentationResponseMut {
    RequestPresentationResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // presentation: optional string
  pub fn presentation(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_get_presentation(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_presentation(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.presentation_mut().set(val);
  }
  const __PRESENTATION_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_get_presentation,
      __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_set_presentation,
    );
  fn presentation_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          RequestPresentationResponse::__PRESENTATION_VTABLE,
        )
      )
    }
  }

}  // impl RequestPresentationResponse

impl ::__std::ops::Drop for RequestPresentationResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_get_presentation(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_RequestPresentationResponse_set_presentation(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for RequestPresentationResponse


impl RequestPresentationResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> RequestPresentationResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> RequestPresentationResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareFundsChangeRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareFundsChangeRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareFundsChangeRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareFundsChangeRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareFundsChangeRequestMut`.
unsafe impl Sync for PrepareFundsChangeRequest {}

// SAFETY:
// - `PrepareFundsChangeRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareFundsChangeRequest {}

impl ::__pb::Proxied for PrepareFundsChangeRequest {
  type View<'msg> = PrepareFundsChangeRequestView<'msg>;
  type Mut<'msg> = PrepareFundsChangeRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareFundsChangeRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareFundsChangeRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareFundsChangeRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_serialize(self.raw_msg()) }
  }

  // amount: optional message common.Amount
  pub fn amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn has_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_has_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareFundsChangeRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareFundsChangeRequestView<'_> {}

// SAFETY:
// - `PrepareFundsChangeRequestView` is `Send` because while its alive a `PrepareFundsChangeRequestMut` cannot.
// - `PrepareFundsChangeRequestView` does not use thread-local data.
unsafe impl Send for PrepareFundsChangeRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareFundsChangeRequestView<'msg> {
  type Proxied = PrepareFundsChangeRequest;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareFundsChangeRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareFundsChangeRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareFundsChangeRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareFundsChangeRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareFundsChangeRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareFundsChangeRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareFundsChangeRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareFundsChangeRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareFundsChangeRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareFundsChangeRequest> for PrepareFundsChangeRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareFundsChangeRequest>)
    where PrepareFundsChangeRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareFundsChangeRequest> for PrepareFundsChangeRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareFundsChangeRequest>)
    where PrepareFundsChangeRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareFundsChangeRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareFundsChangeRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareFundsChangeRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareFundsChangeRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_clear_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_user_reference(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.user_reference_mut().set(val);
  }
  fn user_reference_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__USER_REFERENCE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareFundsChangeRequestMut` does not perform any shared mutation.
// - `PrepareFundsChangeRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareFundsChangeRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareFundsChangeRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareFundsChangeRequest> {
    PrepareFundsChangeRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareFundsChangeRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareFundsChangeRequestMut<'msg> {
  type Proxied = PrepareFundsChangeRequest;
  fn as_view(&self) -> ::__pb::View<'_, PrepareFundsChangeRequest> {
    PrepareFundsChangeRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareFundsChangeRequest> where 'msg: 'shorter {
    PrepareFundsChangeRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareFundsChangeRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareFundsChangeRequestView {
    PrepareFundsChangeRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareFundsChangeRequestMut {
    PrepareFundsChangeRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_clear_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_user_reference(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.user_reference_mut().set(val);
  }
  const __USER_REFERENCE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_user_reference,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_user_reference,
    );
  fn user_reference_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__USER_REFERENCE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl PrepareFundsChangeRequest

impl ::__std::ops::Drop for PrepareFundsChangeRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_user_reference(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_user_reference(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareFundsChangeRequest


impl PrepareFundsChangeRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareFundsChangeRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareFundsChangeRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareFundsChangeResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareFundsChangeResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareFundsChangeResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareFundsChangeResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareFundsChangeResponseMut`.
unsafe impl Sync for PrepareFundsChangeResponse {}

// SAFETY:
// - `PrepareFundsChangeResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareFundsChangeResponse {}

impl ::__pb::Proxied for PrepareFundsChangeResponse {
  type View<'msg> = PrepareFundsChangeResponseView<'msg>;
  type Mut<'msg> = PrepareFundsChangeResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareFundsChangeResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareFundsChangeResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareFundsChangeResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_serialize(self.raw_msg()) }
  }

  // status: optional enum wallet_api.v1.PrepareFundsChangeResponse.Status
  pub fn status(self) -> crate::prepare_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_status(self.raw_msg()) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareFundsChangeResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareFundsChangeResponseView<'_> {}

// SAFETY:
// - `PrepareFundsChangeResponseView` is `Send` because while its alive a `PrepareFundsChangeResponseMut` cannot.
// - `PrepareFundsChangeResponseView` does not use thread-local data.
unsafe impl Send for PrepareFundsChangeResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareFundsChangeResponseView<'msg> {
  type Proxied = PrepareFundsChangeResponse;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareFundsChangeResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareFundsChangeResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareFundsChangeResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareFundsChangeResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareFundsChangeResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareFundsChangeResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareFundsChangeResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareFundsChangeResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareFundsChangeResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareFundsChangeResponse> for PrepareFundsChangeResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareFundsChangeResponse>)
    where PrepareFundsChangeResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareFundsChangeResponse> for PrepareFundsChangeResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareFundsChangeResponse>)
    where PrepareFundsChangeResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareFundsChangeResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareFundsChangeResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareFundsChangeResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareFundsChangeResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // status: optional enum wallet_api.v1.PrepareFundsChangeResponse.Status
  pub fn status(&self) -> crate::prepare_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_funds_change_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeResponse::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareFundsChangeResponseMut` does not perform any shared mutation.
// - `PrepareFundsChangeResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareFundsChangeResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareFundsChangeResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareFundsChangeResponse> {
    PrepareFundsChangeResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareFundsChangeResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareFundsChangeResponseMut<'msg> {
  type Proxied = PrepareFundsChangeResponse;
  fn as_view(&self) -> ::__pb::View<'_, PrepareFundsChangeResponse> {
    PrepareFundsChangeResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareFundsChangeResponse> where 'msg: 'shorter {
    PrepareFundsChangeResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareFundsChangeResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareFundsChangeResponseView {
    PrepareFundsChangeResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareFundsChangeResponseMut {
    PrepareFundsChangeResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // status: optional enum wallet_api.v1.PrepareFundsChangeResponse.Status
  pub fn status(&self) -> crate::prepare_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_funds_change_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_uetr,
      __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareFundsChangeResponse::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl PrepareFundsChangeResponse

impl ::__std::ops::Drop for PrepareFundsChangeResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> crate::prepare_funds_change_response::Status;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: crate::prepare_funds_change_response::Status);

  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareFundsChangeResponse_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareFundsChangeResponse

pub mod prepare_funds_change_response {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Status(i32);

  #[allow(non_upper_case_globals)]
  impl Status {
    pub const Unspecified: Status = Status(0);
    pub const Success: Status = Status(1);
    pub const InsufficientFunds: Status = Status(2);
    pub const FundsPresentNoop: Status = Status(3);
  }

  impl ::__std::convert::From<Status> for i32 {
    fn from(val: Status) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Status {
    fn from(val: i32) -> Status {
      Self(val)
    }
  }

  impl ::__std::default::Default for Status {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Status)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Status {
    type View<'a> = Status;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Status>;
  }

  impl ::__pb::ViewProxy<'_> for Status {
    type Proxied = Status;

    fn as_view(&self) -> Status {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Status> {
      self
    }
  }

  impl ::__pb::SettableValue<Status> for Status {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Status>
    ) where Status: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Status {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Status {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Status) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Status> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Status,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Status {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Status {
    const NAME: &'static str = "Status";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareFundsChangeResponse_Status_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod prepare_funds_change_response

impl PrepareFundsChangeResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareFundsChangeResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareFundsChangeResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareTransactionRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareTransactionRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareTransactionRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareTransactionRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareTransactionRequestMut`.
unsafe impl Sync for PrepareTransactionRequest {}

// SAFETY:
// - `PrepareTransactionRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareTransactionRequest {}

impl ::__pb::Proxied for PrepareTransactionRequest {
  type View<'msg> = PrepareTransactionRequestView<'msg>;
  type Mut<'msg> = PrepareTransactionRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareTransactionRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareTransactionRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareTransactionRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_serialize(self.raw_msg()) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(self) -> ::__pb::RepeatedView<'msg, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_commitments(self.raw_msg()),
      )
    }
  }

  // conditions: repeated message common.Condition
  pub fn conditions(self) -> ::__pb::RepeatedView<'msg, crate::Condition> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_conditions(self.raw_msg()),
      )
    }
  }

  // memo: optional string
  pub fn memo(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareTransactionRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareTransactionRequestView<'_> {}

// SAFETY:
// - `PrepareTransactionRequestView` is `Send` because while its alive a `PrepareTransactionRequestMut` cannot.
// - `PrepareTransactionRequestView` does not use thread-local data.
unsafe impl Send for PrepareTransactionRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareTransactionRequestView<'msg> {
  type Proxied = PrepareTransactionRequest;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareTransactionRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareTransactionRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareTransactionRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareTransactionRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareTransactionRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareTransactionRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareTransactionRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareTransactionRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareTransactionRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareTransactionRequest> for PrepareTransactionRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareTransactionRequest>)
    where PrepareTransactionRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareTransactionRequest> for PrepareTransactionRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareTransactionRequest>)
    where PrepareTransactionRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareTransactionRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareTransactionRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareTransactionRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareTransactionRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(&self) -> ::__pb::RepeatedView<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_commitments(self.raw_msg()),
      )
    }
  }
  pub fn commitments_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_commitments(self.raw_msg()),
        ),
      )
    }
  }

  // conditions: repeated message common.Condition
  pub fn conditions(&self) -> ::__pb::RepeatedView<'_, crate::Condition> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_conditions(self.raw_msg()),
      )
    }
  }
  pub fn conditions_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Condition> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_conditions(self.raw_msg()),
        ),
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__MEMO_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareTransactionRequestMut` does not perform any shared mutation.
// - `PrepareTransactionRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareTransactionRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareTransactionRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareTransactionRequest> {
    PrepareTransactionRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareTransactionRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareTransactionRequestMut<'msg> {
  type Proxied = PrepareTransactionRequest;
  fn as_view(&self) -> ::__pb::View<'_, PrepareTransactionRequest> {
    PrepareTransactionRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareTransactionRequest> where 'msg: 'shorter {
    PrepareTransactionRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareTransactionRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareTransactionRequestView {
    PrepareTransactionRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareTransactionRequestMut {
    PrepareTransactionRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(&self) -> ::__pb::RepeatedView<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_commitments(self.raw_msg()),
      )
    }
  }
  pub fn commitments_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_commitments(self.raw_msg()),
        ),
      )
    }
  }

  // conditions: repeated message common.Condition
  pub fn conditions(&self) -> ::__pb::RepeatedView<'_, crate::Condition> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_conditions(self.raw_msg()),
      )
    }
  }
  pub fn conditions_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Condition> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_conditions(self.raw_msg()),
        ),
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  const __MEMO_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_memo,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_memo,
    );
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionRequest::__MEMO_VTABLE,
        )
      )
    }
  }

}  // impl PrepareTransactionRequest

impl ::__std::ops::Drop for PrepareTransactionRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_clear_commitments(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_commitments(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_commitments(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_clear_conditions(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_mut_conditions(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_conditions(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_get_memo(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionRequest_set_memo(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareTransactionRequest


impl PrepareTransactionRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareTransactionRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareTransactionRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareTransactionResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareTransactionResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareTransactionResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareTransactionResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareTransactionResponseMut`.
unsafe impl Sync for PrepareTransactionResponse {}

// SAFETY:
// - `PrepareTransactionResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareTransactionResponse {}

impl ::__pb::Proxied for PrepareTransactionResponse {
  type View<'msg> = PrepareTransactionResponseView<'msg>;
  type Mut<'msg> = PrepareTransactionResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareTransactionResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareTransactionResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareTransactionResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_serialize(self.raw_msg()) }
  }

  // status: optional enum wallet_api.v1.PrepareTransactionResponse.Status
  pub fn status(self) -> crate::prepare_transaction_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_status(self.raw_msg()) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareTransactionResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareTransactionResponseView<'_> {}

// SAFETY:
// - `PrepareTransactionResponseView` is `Send` because while its alive a `PrepareTransactionResponseMut` cannot.
// - `PrepareTransactionResponseView` does not use thread-local data.
unsafe impl Send for PrepareTransactionResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareTransactionResponseView<'msg> {
  type Proxied = PrepareTransactionResponse;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareTransactionResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareTransactionResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareTransactionResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareTransactionResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareTransactionResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareTransactionResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareTransactionResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareTransactionResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareTransactionResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareTransactionResponse> for PrepareTransactionResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareTransactionResponse>)
    where PrepareTransactionResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareTransactionResponse> for PrepareTransactionResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareTransactionResponse>)
    where PrepareTransactionResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareTransactionResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareTransactionResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareTransactionResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareTransactionResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // status: optional enum wallet_api.v1.PrepareTransactionResponse.Status
  pub fn status(&self) -> crate::prepare_transaction_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_transaction_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionResponse::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareTransactionResponseMut` does not perform any shared mutation.
// - `PrepareTransactionResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareTransactionResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareTransactionResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareTransactionResponse> {
    PrepareTransactionResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareTransactionResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareTransactionResponseMut<'msg> {
  type Proxied = PrepareTransactionResponse;
  fn as_view(&self) -> ::__pb::View<'_, PrepareTransactionResponse> {
    PrepareTransactionResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareTransactionResponse> where 'msg: 'shorter {
    PrepareTransactionResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareTransactionResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareTransactionResponseView {
    PrepareTransactionResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareTransactionResponseMut {
    PrepareTransactionResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // status: optional enum wallet_api.v1.PrepareTransactionResponse.Status
  pub fn status(&self) -> crate::prepare_transaction_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_transaction_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_uetr,
      __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareTransactionResponse::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl PrepareTransactionResponse

impl ::__std::ops::Drop for PrepareTransactionResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> crate::prepare_transaction_response::Status;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: crate::prepare_transaction_response::Status);

  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareTransactionResponse_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareTransactionResponse

pub mod prepare_transaction_response {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Status(i32);

  #[allow(non_upper_case_globals)]
  impl Status {
    pub const Unspecified: Status = Status(0);
    pub const Success: Status = Status(1);
    pub const Failure: Status = Status(2);
  }

  impl ::__std::convert::From<Status> for i32 {
    fn from(val: Status) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Status {
    fn from(val: i32) -> Status {
      Self(val)
    }
  }

  impl ::__std::default::Default for Status {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Status)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Status {
    type View<'a> = Status;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Status>;
  }

  impl ::__pb::ViewProxy<'_> for Status {
    type Proxied = Status;

    fn as_view(&self) -> Status {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Status> {
      self
    }
  }

  impl ::__pb::SettableValue<Status> for Status {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Status>
    ) where Status: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Status {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Status {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Status) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Status> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Status,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Status {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Status {
    const NAME: &'static str = "Status";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareTransactionResponse_Status_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod prepare_transaction_response

impl PrepareTransactionResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareTransactionResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareTransactionResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListTransactionsRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListTransactionsRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListTransactionsRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListTransactionsRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListTransactionsRequestMut`.
unsafe impl Sync for ListTransactionsRequest {}

// SAFETY:
// - `ListTransactionsRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListTransactionsRequest {}

impl ::__pb::Proxied for ListTransactionsRequest {
  type View<'msg> = ListTransactionsRequestView<'msg>;
  type Mut<'msg> = ListTransactionsRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListTransactionsRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListTransactionsRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListTransactionsRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // filters: optional message common.Filter
  pub fn filters(self) -> crate::FilterView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_opt(self) ->
  ::__pb::Optional<crate::FilterView<'msg>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn has_filters(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_filters(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page(self.raw_msg()) }
  }

  // page_size: optional int32
  pub fn page_size(self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page_size(self.raw_msg()) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(self) -> crate::SortByView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_opt(self) ->
  ::__pb::Optional<crate::SortByView<'msg>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn has_sort_by(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListTransactionsRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListTransactionsRequestView<'_> {}

// SAFETY:
// - `ListTransactionsRequestView` is `Send` because while its alive a `ListTransactionsRequestMut` cannot.
// - `ListTransactionsRequestView` does not use thread-local data.
unsafe impl Send for ListTransactionsRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListTransactionsRequestView<'msg> {
  type Proxied = ListTransactionsRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListTransactionsRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListTransactionsRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListTransactionsRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListTransactionsRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListTransactionsRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListTransactionsRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListTransactionsRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListTransactionsRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListTransactionsRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListTransactionsRequest> for ListTransactionsRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListTransactionsRequest>)
    where ListTransactionsRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListTransactionsRequest> for ListTransactionsRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListTransactionsRequest>)
    where ListTransactionsRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListTransactionsRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListTransactionsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListTransactionsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListTransactionsRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListTransactionsRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListTransactionsRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListTransactionsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListTransactionsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_filters(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page_size(self.raw_msg(), val) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_sort_by(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListTransactionsRequestMut` does not perform any shared mutation.
// - `ListTransactionsRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListTransactionsRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListTransactionsRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListTransactionsRequest> {
    ListTransactionsRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListTransactionsRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListTransactionsRequestMut<'msg> {
  type Proxied = ListTransactionsRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListTransactionsRequest> {
    ListTransactionsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListTransactionsRequest> where 'msg: 'shorter {
    ListTransactionsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListTransactionsRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListTransactionsRequestView {
    ListTransactionsRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListTransactionsRequestMut {
    ListTransactionsRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListTransactionsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListTransactionsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // filters: optional message common.Filter
  pub fn filters(&self) -> crate::FilterView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters(self.raw_msg()) };
    crate::FilterView::new(::__pb::__internal::Private, submsg)
  }
  pub fn filters_mut(&mut self) -> crate::FilterMut<'_> {
    self.filters_entry().or_default()
  }
  fn filters_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Filter> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_filters,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_filters);
    unsafe {
      let has = self.has_filters();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn filters_opt(&self) ->
  ::__pb::Optional<crate::FilterView<'_>> {
    let view = self.filters();
    ::__pb::Optional::new(view, self.has_filters())
  }
  pub fn set_filters(&mut self, val: impl ::__pb::SettableValue<crate::Filter>) {
    self.filters_entry().set(val);
  }
  pub fn has_filters(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_filters(self.raw_msg()) }
  }
  pub fn clear_filters(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_filters(self.raw_msg()) }
  }

  // page: optional int32
  pub fn page(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page(self.raw_msg()) }
  }
  pub fn set_page(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page(self.raw_msg(), val) }
  }

  // page_size: optional int32
  pub fn page_size(&self) -> i32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page_size(self.raw_msg()) }
  }
  pub fn set_page_size(&mut self, val: i32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page_size(self.raw_msg(), val) }
  }

  // sort_by: optional message common.SortBy
  pub fn sort_by(&self) -> crate::SortByView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by(self.raw_msg()) };
    crate::SortByView::new(::__pb::__internal::Private, submsg)
  }
  pub fn sort_by_mut(&mut self) -> crate::SortByMut<'_> {
    self.sort_by_entry().or_default()
  }
  fn sort_by_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::SortBy> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_sort_by,
                                __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_sort_by);
    unsafe {
      let has = self.has_sort_by();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn sort_by_opt(&self) ->
  ::__pb::Optional<crate::SortByView<'_>> {
    let view = self.sort_by();
    ::__pb::Optional::new(view, self.has_sort_by())
  }
  pub fn set_sort_by(&mut self, val: impl ::__pb::SettableValue<crate::SortBy>) {
    self.sort_by_entry().set(val);
  }
  pub fn has_sort_by(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_sort_by(self.raw_msg()) }
  }
  pub fn clear_sort_by(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_sort_by(self.raw_msg()) }
  }

}  // impl ListTransactionsRequest

impl ::__std::ops::Drop for ListTransactionsRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_filters(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_filters(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_filters(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_filters(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_page_size(raw_msg: ::__pb::__runtime::RawMessage) -> i32;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_set_page_size(raw_msg: ::__pb::__runtime::RawMessage, val: i32);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_get_mut_sort_by(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_clear_sort_by(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsRequest_has_sort_by(raw_msg: ::__pb::__runtime::RawMessage) -> bool;


}  // extern "C" for ListTransactionsRequest


impl ListTransactionsRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListTransactionsRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListTransactionsRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ContractSummary {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ContractSummary {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ContractSummary {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ContractSummary` is `Sync` because it does not implement interior mutability.
//    Neither does `ContractSummaryMut`.
unsafe impl Sync for ContractSummary {}

// SAFETY:
// - `ContractSummary` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ContractSummary {}

impl ::__pb::Proxied for ContractSummary {
  type View<'msg> = ContractSummaryView<'msg>;
  type Mut<'msg> = ContractSummaryMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ContractSummaryView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ContractSummaryView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ContractSummaryView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_serialize(self.raw_msg()) }
  }

  // contract_id: optional string
  pub fn contract_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // contract_type: optional string
  pub fn contract_type(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // created: optional string
  pub fn created(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // counterparties: repeated string
  pub fn counterparties(self) -> ::__pb::RepeatedView<'msg, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ContractSummary_get_counterparties(self.raw_msg()),
      )
    }
  }

  // status: optional string
  pub fn status(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_status(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // memo: optional string
  pub fn memo(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `ContractSummaryView` is `Sync` because it does not support mutation.
unsafe impl Sync for ContractSummaryView<'_> {}

// SAFETY:
// - `ContractSummaryView` is `Send` because while its alive a `ContractSummaryMut` cannot.
// - `ContractSummaryView` does not use thread-local data.
unsafe impl Send for ContractSummaryView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ContractSummaryView<'msg> {
  type Proxied = ContractSummary;

  fn as_view(&self) -> ::__pb::View<'msg, ContractSummary> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ContractSummary> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ContractSummary {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ContractSummaryView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ContractSummaryMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ContractSummary {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ContractSummary {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ContractSummary>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ContractSummary>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ContractSummary> for ContractSummaryView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ContractSummary>)
    where ContractSummary: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ContractSummary> for ContractSummary {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ContractSummary>)
    where ContractSummary: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ContractSummary {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ContractSummary_copy_from(
        __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ContractSummary_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ContractSummary {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ContractSummaryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ContractSummary_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ContractSummaryView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ContractSummaryMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ContractSummaryMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ContractSummaryMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // contract_id: optional string
  pub fn contract_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_id_mut().set(val);
  }
  fn contract_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CONTRACT_ID_VTABLE,
        )
      )
    }
  }

  // contract_type: optional string
  pub fn contract_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_type_mut().set(val);
  }
  fn contract_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CONTRACT_TYPE_VTABLE,
        )
      )
    }
  }

  // created: optional string
  pub fn created(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_created(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.created_mut().set(val);
  }
  fn created_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CREATED_VTABLE,
        )
      )
    }
  }

  // counterparties: repeated string
  pub fn counterparties(&self) -> ::__pb::RepeatedView<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ContractSummary_get_counterparties(self.raw_msg()),
      )
    }
  }
  pub fn counterparties_mut(&mut self) -> ::__pb::RepeatedMut<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ContractSummary_get_mut_counterparties(self.raw_msg()),
        ),
      )
    }
  }

  // status: optional string
  pub fn status(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_status(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_status(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.status_mut().set(val);
  }
  fn status_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__STATUS_VTABLE,
        )
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__MEMO_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `ContractSummaryMut` does not perform any shared mutation.
// - `ContractSummaryMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ContractSummaryMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ContractSummaryMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ContractSummary> {
    ContractSummaryMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ContractSummary> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ContractSummaryMut<'msg> {
  type Proxied = ContractSummary;
  fn as_view(&self) -> ::__pb::View<'_, ContractSummary> {
    ContractSummaryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ContractSummary> where 'msg: 'shorter {
    ContractSummaryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ContractSummary {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ContractSummary_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ContractSummaryView {
    ContractSummaryView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ContractSummaryMut {
    ContractSummaryMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // contract_id: optional string
  pub fn contract_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_id_mut().set(val);
  }
  const __CONTRACT_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_id,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_set_contract_id,
    );
  fn contract_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CONTRACT_ID_VTABLE,
        )
      )
    }
  }

  // contract_type: optional string
  pub fn contract_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_type_mut().set(val);
  }
  const __CONTRACT_TYPE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_type,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_set_contract_type,
    );
  fn contract_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CONTRACT_TYPE_VTABLE,
        )
      )
    }
  }

  // created: optional string
  pub fn created(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_created(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.created_mut().set(val);
  }
  const __CREATED_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_get_created,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_set_created,
    );
  fn created_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__CREATED_VTABLE,
        )
      )
    }
  }

  // counterparties: repeated string
  pub fn counterparties(&self) -> ::__pb::RepeatedView<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ContractSummary_get_counterparties(self.raw_msg()),
      )
    }
  }
  pub fn counterparties_mut(&mut self) -> ::__pb::RepeatedMut<'_, ::__pb::ProtoStr> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ContractSummary_get_mut_counterparties(self.raw_msg()),
        ),
      )
    }
  }

  // status: optional string
  pub fn status(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_status(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_status(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.status_mut().set(val);
  }
  const __STATUS_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_get_status,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_set_status,
    );
  fn status_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__STATUS_VTABLE,
        )
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  const __MEMO_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_get_memo,
      __rust_proto_thunk__wallet_api_v1_ContractSummary_set_memo,
    );
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ContractSummary::__MEMO_VTABLE,
        )
      )
    }
  }

}  // impl ContractSummary

impl ::__std::ops::Drop for ContractSummary {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ContractSummary_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_set_contract_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_contract_type(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_set_contract_type(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_created(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_set_created(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_clear_counterparties(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_mut_counterparties(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_counterparties(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_get_memo(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ContractSummary_set_memo(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for ContractSummary


impl ContractSummary {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ContractSummaryMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ContractSummaryView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListTransactionsResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListTransactionsResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListTransactionsResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListTransactionsResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListTransactionsResponseMut`.
unsafe impl Sync for ListTransactionsResponse {}

// SAFETY:
// - `ListTransactionsResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListTransactionsResponse {}

impl ::__pb::Proxied for ListTransactionsResponse {
  type View<'msg> = ListTransactionsResponseView<'msg>;
  type Mut<'msg> = ListTransactionsResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListTransactionsResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListTransactionsResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListTransactionsResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_serialize(self.raw_msg()) }
  }

  // contracts: repeated message wallet_api.v1.ContractSummary
  pub fn contracts(self) -> ::__pb::RepeatedView<'msg, crate::ContractSummary> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_contracts(self.raw_msg()),
      )
    }
  }

  // totalContracts: optional uint32
  pub fn totalContracts(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_totalContracts(self.raw_msg()) }
  }

}

// SAFETY:
// - `ListTransactionsResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListTransactionsResponseView<'_> {}

// SAFETY:
// - `ListTransactionsResponseView` is `Send` because while its alive a `ListTransactionsResponseMut` cannot.
// - `ListTransactionsResponseView` does not use thread-local data.
unsafe impl Send for ListTransactionsResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListTransactionsResponseView<'msg> {
  type Proxied = ListTransactionsResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListTransactionsResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListTransactionsResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListTransactionsResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListTransactionsResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListTransactionsResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListTransactionsResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListTransactionsResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListTransactionsResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListTransactionsResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListTransactionsResponse> for ListTransactionsResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListTransactionsResponse>)
    where ListTransactionsResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListTransactionsResponse> for ListTransactionsResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListTransactionsResponse>)
    where ListTransactionsResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListTransactionsResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListTransactionsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListTransactionsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListTransactionsResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListTransactionsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListTransactionsResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListTransactionsResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListTransactionsResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // contracts: repeated message wallet_api.v1.ContractSummary
  pub fn contracts(&self) -> ::__pb::RepeatedView<'_, crate::ContractSummary> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_contracts(self.raw_msg()),
      )
    }
  }
  pub fn contracts_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::ContractSummary> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_mut_contracts(self.raw_msg()),
        ),
      )
    }
  }

  // totalContracts: optional uint32
  pub fn totalContracts(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_totalContracts(self.raw_msg()) }
  }
  pub fn set_totalContracts(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_set_totalContracts(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `ListTransactionsResponseMut` does not perform any shared mutation.
// - `ListTransactionsResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListTransactionsResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListTransactionsResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListTransactionsResponse> {
    ListTransactionsResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListTransactionsResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListTransactionsResponseMut<'msg> {
  type Proxied = ListTransactionsResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListTransactionsResponse> {
    ListTransactionsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListTransactionsResponse> where 'msg: 'shorter {
    ListTransactionsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListTransactionsResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListTransactionsResponseView {
    ListTransactionsResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListTransactionsResponseMut {
    ListTransactionsResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // contracts: repeated message wallet_api.v1.ContractSummary
  pub fn contracts(&self) -> ::__pb::RepeatedView<'_, crate::ContractSummary> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_contracts(self.raw_msg()),
      )
    }
  }
  pub fn contracts_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::ContractSummary> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_mut_contracts(self.raw_msg()),
        ),
      )
    }
  }

  // totalContracts: optional uint32
  pub fn totalContracts(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_totalContracts(self.raw_msg()) }
  }
  pub fn set_totalContracts(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_set_totalContracts(self.raw_msg(), val) }
  }

}  // impl ListTransactionsResponse

impl ::__std::ops::Drop for ListTransactionsResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_clear_contracts(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_mut_contracts(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_contracts(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_get_totalContracts(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_ListTransactionsResponse_set_totalContracts(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for ListTransactionsResponse


impl ListTransactionsResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListTransactionsResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListTransactionsResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct BalanceDetail {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for BalanceDetail {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for BalanceDetail {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `BalanceDetail` is `Sync` because it does not implement interior mutability.
//    Neither does `BalanceDetailMut`.
unsafe impl Sync for BalanceDetail {}

// SAFETY:
// - `BalanceDetail` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for BalanceDetail {}

impl ::__pb::Proxied for BalanceDetail {
  type View<'msg> = BalanceDetailView<'msg>;
  type Mut<'msg> = BalanceDetailMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct BalanceDetailView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for BalanceDetailView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> BalanceDetailView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_serialize(self.raw_msg()) }
  }

  // balance: optional message wallet_api.v1.WalletBalance
  pub fn balance(self) -> crate::WalletBalanceView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance(self.raw_msg()) };
    crate::WalletBalanceView::new(::__pb::__internal::Private, submsg)
  }
  pub fn balance_opt(self) ->
  ::__pb::Optional<crate::WalletBalanceView<'msg>> {
    let view = self.balance();
    ::__pb::Optional::new(view, self.has_balance())
  }
  pub fn has_balance(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_has_balance(self.raw_msg()) }
  }

  // kind: optional enum wallet_api.v1.BalanceDetail.Kind
  pub fn kind(self) -> crate::balance_detail::Kind {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_kind(self.raw_msg()) }
  }

}

// SAFETY:
// - `BalanceDetailView` is `Sync` because it does not support mutation.
unsafe impl Sync for BalanceDetailView<'_> {}

// SAFETY:
// - `BalanceDetailView` is `Send` because while its alive a `BalanceDetailMut` cannot.
// - `BalanceDetailView` does not use thread-local data.
unsafe impl Send for BalanceDetailView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for BalanceDetailView<'msg> {
  type Proxied = BalanceDetail;

  fn as_view(&self) -> ::__pb::View<'msg, BalanceDetail> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, BalanceDetail> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for BalanceDetail {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    BalanceDetailView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    BalanceDetailMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for BalanceDetail {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for BalanceDetail {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, BalanceDetail>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, BalanceDetail>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<BalanceDetail> for BalanceDetailView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, BalanceDetail>)
    where BalanceDetail: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<BalanceDetail> for BalanceDetail {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, BalanceDetail>)
    where BalanceDetail: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for BalanceDetail {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_BalanceDetail_copy_from(
        __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_BalanceDetail_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for BalanceDetail {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(BalanceDetailView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| BalanceDetailView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct BalanceDetailMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for BalanceDetailMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> BalanceDetailMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // balance: optional message wallet_api.v1.WalletBalance
  pub fn balance(&self) -> crate::WalletBalanceView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance(self.raw_msg()) };
    crate::WalletBalanceView::new(::__pb::__internal::Private, submsg)
  }
  pub fn balance_mut(&mut self) -> crate::WalletBalanceMut<'_> {
    self.balance_entry().or_default()
  }
  fn balance_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::WalletBalance> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_mut_balance,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_clear_balance);
    unsafe {
      let has = self.has_balance();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn balance_opt(&self) ->
  ::__pb::Optional<crate::WalletBalanceView<'_>> {
    let view = self.balance();
    ::__pb::Optional::new(view, self.has_balance())
  }
  pub fn set_balance(&mut self, val: impl ::__pb::SettableValue<crate::WalletBalance>) {
    self.balance_entry().set(val);
  }
  pub fn has_balance(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_has_balance(self.raw_msg()) }
  }
  pub fn clear_balance(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_clear_balance(self.raw_msg()) }
  }

  // kind: optional enum wallet_api.v1.BalanceDetail.Kind
  pub fn kind(&self) -> crate::balance_detail::Kind {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_kind(self.raw_msg()) }
  }
  pub fn set_kind(&mut self, val: crate::balance_detail::Kind) {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_set_kind(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `BalanceDetailMut` does not perform any shared mutation.
// - `BalanceDetailMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for BalanceDetailMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for BalanceDetailMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, BalanceDetail> {
    BalanceDetailMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, BalanceDetail> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for BalanceDetailMut<'msg> {
  type Proxied = BalanceDetail;
  fn as_view(&self) -> ::__pb::View<'_, BalanceDetail> {
    BalanceDetailView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, BalanceDetail> where 'msg: 'shorter {
    BalanceDetailView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl BalanceDetail {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_BalanceDetail_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> BalanceDetailView {
    BalanceDetailView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> BalanceDetailMut {
    BalanceDetailMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // balance: optional message wallet_api.v1.WalletBalance
  pub fn balance(&self) -> crate::WalletBalanceView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance(self.raw_msg()) };
    crate::WalletBalanceView::new(::__pb::__internal::Private, submsg)
  }
  pub fn balance_mut(&mut self) -> crate::WalletBalanceMut<'_> {
    self.balance_entry().or_default()
  }
  fn balance_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::WalletBalance> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_mut_balance,
                                __rust_proto_thunk__wallet_api_v1_BalanceDetail_clear_balance);
    unsafe {
      let has = self.has_balance();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn balance_opt(&self) ->
  ::__pb::Optional<crate::WalletBalanceView<'_>> {
    let view = self.balance();
    ::__pb::Optional::new(view, self.has_balance())
  }
  pub fn set_balance(&mut self, val: impl ::__pb::SettableValue<crate::WalletBalance>) {
    self.balance_entry().set(val);
  }
  pub fn has_balance(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_has_balance(self.raw_msg()) }
  }
  pub fn clear_balance(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_clear_balance(self.raw_msg()) }
  }

  // kind: optional enum wallet_api.v1.BalanceDetail.Kind
  pub fn kind(&self) -> crate::balance_detail::Kind {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_kind(self.raw_msg()) }
  }
  pub fn set_kind(&mut self, val: crate::balance_detail::Kind) {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_set_kind(self.raw_msg(), val) }
  }

}  // impl BalanceDetail

impl ::__std::ops::Drop for BalanceDetail {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_BalanceDetail_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_balance(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_mut_balance(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_clear_balance(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_has_balance(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_get_kind(raw_msg: ::__pb::__runtime::RawMessage) -> crate::balance_detail::Kind;
  fn __rust_proto_thunk__wallet_api_v1_BalanceDetail_set_kind(raw_msg: ::__pb::__runtime::RawMessage, val: crate::balance_detail::Kind);


}  // extern "C" for BalanceDetail

pub mod balance_detail {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Kind(i32);

  #[allow(non_upper_case_globals)]
  impl Kind {
    pub const Available: Kind = Kind(0);
    pub const Reserved: Kind = Kind(1);
  }

  impl ::__std::convert::From<Kind> for i32 {
    fn from(val: Kind) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Kind {
    fn from(val: i32) -> Kind {
      Self(val)
    }
  }

  impl ::__std::default::Default for Kind {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Kind {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Kind)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Kind {
    type View<'a> = Kind;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Kind>;
  }

  impl ::__pb::ViewProxy<'_> for Kind {
    type Proxied = Kind;

    fn as_view(&self) -> Kind {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Kind> {
      self
    }
  }

  impl ::__pb::SettableValue<Kind> for Kind {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Kind>
    ) where Kind: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Kind {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Kind>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Kind>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Kind {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Kind) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Kind> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Kind,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Kind {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Kind {
    const NAME: &'static str = "Kind";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Kind) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Kind) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Kind);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Kind {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_BalanceDetail_Kind_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod balance_detail

impl BalanceDetail {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> BalanceDetailMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> BalanceDetailView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletBalanceDetailsRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletBalanceDetailsRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletBalanceDetailsRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletBalanceDetailsRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletBalanceDetailsRequestMut`.
unsafe impl Sync for ListWalletBalanceDetailsRequest {}

// SAFETY:
// - `ListWalletBalanceDetailsRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletBalanceDetailsRequest {}

impl ::__pb::Proxied for ListWalletBalanceDetailsRequest {
  type View<'msg> = ListWalletBalanceDetailsRequestView<'msg>;
  type Mut<'msg> = ListWalletBalanceDetailsRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletBalanceDetailsRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletBalanceDetailsRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalanceDetailsRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `ListWalletBalanceDetailsRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletBalanceDetailsRequestView<'_> {}

// SAFETY:
// - `ListWalletBalanceDetailsRequestView` is `Send` because while its alive a `ListWalletBalanceDetailsRequestMut` cannot.
// - `ListWalletBalanceDetailsRequestView` does not use thread-local data.
unsafe impl Send for ListWalletBalanceDetailsRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalanceDetailsRequestView<'msg> {
  type Proxied = ListWalletBalanceDetailsRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletBalanceDetailsRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalanceDetailsRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletBalanceDetailsRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletBalanceDetailsRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletBalanceDetailsRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletBalanceDetailsRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletBalanceDetailsRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletBalanceDetailsRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletBalanceDetailsRequest> for ListWalletBalanceDetailsRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalanceDetailsRequest>)
    where ListWalletBalanceDetailsRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletBalanceDetailsRequest> for ListWalletBalanceDetailsRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalanceDetailsRequest>)
    where ListWalletBalanceDetailsRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletBalanceDetailsRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletBalanceDetailsRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletBalanceDetailsRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletBalanceDetailsRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalanceDetailsRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalanceDetailsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalanceDetailsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `ListWalletBalanceDetailsRequestMut` does not perform any shared mutation.
// - `ListWalletBalanceDetailsRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletBalanceDetailsRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletBalanceDetailsRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletBalanceDetailsRequest> {
    ListWalletBalanceDetailsRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletBalanceDetailsRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalanceDetailsRequestMut<'msg> {
  type Proxied = ListWalletBalanceDetailsRequest;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletBalanceDetailsRequest> {
    ListWalletBalanceDetailsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalanceDetailsRequest> where 'msg: 'shorter {
    ListWalletBalanceDetailsRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletBalanceDetailsRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletBalanceDetailsRequestView {
    ListWalletBalanceDetailsRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletBalanceDetailsRequestMut {
    ListWalletBalanceDetailsRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalanceDetailsRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ListWalletBalanceDetailsRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl ListWalletBalanceDetailsRequest

impl ::__std::ops::Drop for ListWalletBalanceDetailsRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for ListWalletBalanceDetailsRequest


impl ListWalletBalanceDetailsRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletBalanceDetailsRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletBalanceDetailsRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ListWalletBalanceDetailsResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ListWalletBalanceDetailsResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ListWalletBalanceDetailsResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ListWalletBalanceDetailsResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ListWalletBalanceDetailsResponseMut`.
unsafe impl Sync for ListWalletBalanceDetailsResponse {}

// SAFETY:
// - `ListWalletBalanceDetailsResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ListWalletBalanceDetailsResponse {}

impl ::__pb::Proxied for ListWalletBalanceDetailsResponse {
  type View<'msg> = ListWalletBalanceDetailsResponseView<'msg>;
  type Mut<'msg> = ListWalletBalanceDetailsResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ListWalletBalanceDetailsResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ListWalletBalanceDetailsResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalanceDetailsResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_serialize(self.raw_msg()) }
  }

  // balances: repeated message wallet_api.v1.BalanceDetail
  pub fn balances(self) -> ::__pb::RepeatedView<'msg, crate::BalanceDetail> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_balances(self.raw_msg()),
      )
    }
  }

}

// SAFETY:
// - `ListWalletBalanceDetailsResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ListWalletBalanceDetailsResponseView<'_> {}

// SAFETY:
// - `ListWalletBalanceDetailsResponseView` is `Send` because while its alive a `ListWalletBalanceDetailsResponseMut` cannot.
// - `ListWalletBalanceDetailsResponseView` does not use thread-local data.
unsafe impl Send for ListWalletBalanceDetailsResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalanceDetailsResponseView<'msg> {
  type Proxied = ListWalletBalanceDetailsResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ListWalletBalanceDetailsResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalanceDetailsResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ListWalletBalanceDetailsResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ListWalletBalanceDetailsResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ListWalletBalanceDetailsResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ListWalletBalanceDetailsResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ListWalletBalanceDetailsResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ListWalletBalanceDetailsResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ListWalletBalanceDetailsResponse> for ListWalletBalanceDetailsResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalanceDetailsResponse>)
    where ListWalletBalanceDetailsResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ListWalletBalanceDetailsResponse> for ListWalletBalanceDetailsResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ListWalletBalanceDetailsResponse>)
    where ListWalletBalanceDetailsResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ListWalletBalanceDetailsResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ListWalletBalanceDetailsResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ListWalletBalanceDetailsResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ListWalletBalanceDetailsResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ListWalletBalanceDetailsResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ListWalletBalanceDetailsResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // balances: repeated message wallet_api.v1.BalanceDetail
  pub fn balances(&self) -> ::__pb::RepeatedView<'_, crate::BalanceDetail> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_balances(self.raw_msg()),
      )
    }
  }
  pub fn balances_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::BalanceDetail> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_mut_balances(self.raw_msg()),
        ),
      )
    }
  }

}

// SAFETY:
// - `ListWalletBalanceDetailsResponseMut` does not perform any shared mutation.
// - `ListWalletBalanceDetailsResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ListWalletBalanceDetailsResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ListWalletBalanceDetailsResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ListWalletBalanceDetailsResponse> {
    ListWalletBalanceDetailsResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ListWalletBalanceDetailsResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ListWalletBalanceDetailsResponseMut<'msg> {
  type Proxied = ListWalletBalanceDetailsResponse;
  fn as_view(&self) -> ::__pb::View<'_, ListWalletBalanceDetailsResponse> {
    ListWalletBalanceDetailsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ListWalletBalanceDetailsResponse> where 'msg: 'shorter {
    ListWalletBalanceDetailsResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ListWalletBalanceDetailsResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ListWalletBalanceDetailsResponseView {
    ListWalletBalanceDetailsResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ListWalletBalanceDetailsResponseMut {
    ListWalletBalanceDetailsResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // balances: repeated message wallet_api.v1.BalanceDetail
  pub fn balances(&self) -> ::__pb::RepeatedView<'_, crate::BalanceDetail> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_balances(self.raw_msg()),
      )
    }
  }
  pub fn balances_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::BalanceDetail> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_mut_balances(self.raw_msg()),
        ),
      )
    }
  }

}  // impl ListWalletBalanceDetailsResponse

impl ::__std::ops::Drop for ListWalletBalanceDetailsResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_clear_balances(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_mut_balances(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_ListWalletBalanceDetailsResponse_get_balances(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;


}  // extern "C" for ListWalletBalanceDetailsResponse


impl ListWalletBalanceDetailsResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ListWalletBalanceDetailsResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ListWalletBalanceDetailsResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct GetTransactionDetailRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for GetTransactionDetailRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for GetTransactionDetailRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `GetTransactionDetailRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `GetTransactionDetailRequestMut`.
unsafe impl Sync for GetTransactionDetailRequest {}

// SAFETY:
// - `GetTransactionDetailRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for GetTransactionDetailRequest {}

impl ::__pb::Proxied for GetTransactionDetailRequest {
  type View<'msg> = GetTransactionDetailRequestView<'msg>;
  type Mut<'msg> = GetTransactionDetailRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct GetTransactionDetailRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for GetTransactionDetailRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> GetTransactionDetailRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `GetTransactionDetailRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for GetTransactionDetailRequestView<'_> {}

// SAFETY:
// - `GetTransactionDetailRequestView` is `Send` because while its alive a `GetTransactionDetailRequestMut` cannot.
// - `GetTransactionDetailRequestView` does not use thread-local data.
unsafe impl Send for GetTransactionDetailRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for GetTransactionDetailRequestView<'msg> {
  type Proxied = GetTransactionDetailRequest;

  fn as_view(&self) -> ::__pb::View<'msg, GetTransactionDetailRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, GetTransactionDetailRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for GetTransactionDetailRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    GetTransactionDetailRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    GetTransactionDetailRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for GetTransactionDetailRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for GetTransactionDetailRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, GetTransactionDetailRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, GetTransactionDetailRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<GetTransactionDetailRequest> for GetTransactionDetailRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, GetTransactionDetailRequest>)
    where GetTransactionDetailRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<GetTransactionDetailRequest> for GetTransactionDetailRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, GetTransactionDetailRequest>)
    where GetTransactionDetailRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for GetTransactionDetailRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for GetTransactionDetailRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| GetTransactionDetailRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct GetTransactionDetailRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for GetTransactionDetailRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> GetTransactionDetailRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `GetTransactionDetailRequestMut` does not perform any shared mutation.
// - `GetTransactionDetailRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for GetTransactionDetailRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for GetTransactionDetailRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, GetTransactionDetailRequest> {
    GetTransactionDetailRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, GetTransactionDetailRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for GetTransactionDetailRequestMut<'msg> {
  type Proxied = GetTransactionDetailRequest;
  fn as_view(&self) -> ::__pb::View<'_, GetTransactionDetailRequest> {
    GetTransactionDetailRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, GetTransactionDetailRequest> where 'msg: 'shorter {
    GetTransactionDetailRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl GetTransactionDetailRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> GetTransactionDetailRequestView {
    GetTransactionDetailRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> GetTransactionDetailRequestMut {
    GetTransactionDetailRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_uetr,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailRequest::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl GetTransactionDetailRequest

impl ::__std::ops::Drop for GetTransactionDetailRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailRequest_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for GetTransactionDetailRequest


impl GetTransactionDetailRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> GetTransactionDetailRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> GetTransactionDetailRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct GetTransactionDetailResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for GetTransactionDetailResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for GetTransactionDetailResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `GetTransactionDetailResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `GetTransactionDetailResponseMut`.
unsafe impl Sync for GetTransactionDetailResponse {}

// SAFETY:
// - `GetTransactionDetailResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for GetTransactionDetailResponse {}

impl ::__pb::Proxied for GetTransactionDetailResponse {
  type View<'msg> = GetTransactionDetailResponseView<'msg>;
  type Mut<'msg> = GetTransactionDetailResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct GetTransactionDetailResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for GetTransactionDetailResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> GetTransactionDetailResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_serialize(self.raw_msg()) }
  }

  // contract_type: optional string
  pub fn contract_type(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(self) -> ::__pb::RepeatedView<'msg, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_commitments(self.raw_msg()),
      )
    }
  }

  // created: optional string
  pub fn created(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // hash_presenter: optional string
  pub fn hash_presenter(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash_presenter(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // hash: optional bytes
  pub fn hash(self) -> &'msg [u8] {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash(self.raw_msg()).as_ref() };
    view
  }

  // expiration: optional string
  pub fn expiration(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_expiration(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // memo: optional string
  pub fn memo(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // log: repeated message wallet_api.v1.GetTransactionDetailResponse.LogEntry
  pub fn log(self) -> ::__pb::RepeatedView<'msg, crate::get_transaction_detail_response::LogEntry> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_log(self.raw_msg()),
      )
    }
  }

}

// SAFETY:
// - `GetTransactionDetailResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for GetTransactionDetailResponseView<'_> {}

// SAFETY:
// - `GetTransactionDetailResponseView` is `Send` because while its alive a `GetTransactionDetailResponseMut` cannot.
// - `GetTransactionDetailResponseView` does not use thread-local data.
unsafe impl Send for GetTransactionDetailResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for GetTransactionDetailResponseView<'msg> {
  type Proxied = GetTransactionDetailResponse;

  fn as_view(&self) -> ::__pb::View<'msg, GetTransactionDetailResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, GetTransactionDetailResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for GetTransactionDetailResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    GetTransactionDetailResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    GetTransactionDetailResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for GetTransactionDetailResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for GetTransactionDetailResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, GetTransactionDetailResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, GetTransactionDetailResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<GetTransactionDetailResponse> for GetTransactionDetailResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, GetTransactionDetailResponse>)
    where GetTransactionDetailResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<GetTransactionDetailResponse> for GetTransactionDetailResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, GetTransactionDetailResponse>)
    where GetTransactionDetailResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for GetTransactionDetailResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for GetTransactionDetailResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(GetTransactionDetailResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| GetTransactionDetailResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct GetTransactionDetailResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for GetTransactionDetailResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> GetTransactionDetailResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // contract_type: optional string
  pub fn contract_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_type_mut().set(val);
  }
  fn contract_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__CONTRACT_TYPE_VTABLE,
        )
      )
    }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(&self) -> ::__pb::RepeatedView<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_commitments(self.raw_msg()),
      )
    }
  }
  pub fn commitments_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_commitments(self.raw_msg()),
        ),
      )
    }
  }

  // created: optional string
  pub fn created(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_created(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.created_mut().set(val);
  }
  fn created_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__CREATED_VTABLE,
        )
      )
    }
  }

  // hash_presenter: optional string
  pub fn hash_presenter(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash_presenter(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_hash_presenter(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.hash_presenter_mut().set(val);
  }
  fn hash_presenter_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__HASH_PRESENTER_VTABLE,
        )
      )
    }
  }

  // hash: optional bytes
  pub fn hash(&self) -> &'_ [u8] {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash(self.raw_msg()).as_ref() };
    view
  }
  pub fn set_hash(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
    self.hash_mut().set(val);
  }
  fn hash_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
    unsafe {
      <::__pb::Mut<[u8]>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__HASH_VTABLE,
        )
      )
    }
  }

  // expiration: optional string
  pub fn expiration(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_expiration(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_expiration(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.expiration_mut().set(val);
  }
  fn expiration_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__EXPIRATION_VTABLE,
        )
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__MEMO_VTABLE,
        )
      )
    }
  }

  // log: repeated message wallet_api.v1.GetTransactionDetailResponse.LogEntry
  pub fn log(&self) -> ::__pb::RepeatedView<'_, crate::get_transaction_detail_response::LogEntry> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_log(self.raw_msg()),
      )
    }
  }
  pub fn log_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::get_transaction_detail_response::LogEntry> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_log(self.raw_msg()),
        ),
      )
    }
  }

}

// SAFETY:
// - `GetTransactionDetailResponseMut` does not perform any shared mutation.
// - `GetTransactionDetailResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for GetTransactionDetailResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for GetTransactionDetailResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, GetTransactionDetailResponse> {
    GetTransactionDetailResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, GetTransactionDetailResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for GetTransactionDetailResponseMut<'msg> {
  type Proxied = GetTransactionDetailResponse;
  fn as_view(&self) -> ::__pb::View<'_, GetTransactionDetailResponse> {
    GetTransactionDetailResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, GetTransactionDetailResponse> where 'msg: 'shorter {
    GetTransactionDetailResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl GetTransactionDetailResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> GetTransactionDetailResponseView {
    GetTransactionDetailResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> GetTransactionDetailResponseMut {
    GetTransactionDetailResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // contract_type: optional string
  pub fn contract_type(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_contract_type(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_contract_type(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.contract_type_mut().set(val);
  }
  const __CONTRACT_TYPE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_contract_type,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_contract_type,
    );
  fn contract_type_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__CONTRACT_TYPE_VTABLE,
        )
      )
    }
  }

  // commitments: repeated message common.Commitment
  pub fn commitments(&self) -> ::__pb::RepeatedView<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_commitments(self.raw_msg()),
      )
    }
  }
  pub fn commitments_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::Commitment> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_commitments(self.raw_msg()),
        ),
      )
    }
  }

  // created: optional string
  pub fn created(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_created(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_created(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.created_mut().set(val);
  }
  const __CREATED_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_created,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_created,
    );
  fn created_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__CREATED_VTABLE,
        )
      )
    }
  }

  // hash_presenter: optional string
  pub fn hash_presenter(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash_presenter(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_hash_presenter(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.hash_presenter_mut().set(val);
  }
  const __HASH_PRESENTER_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash_presenter,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_hash_presenter,
    );
  fn hash_presenter_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__HASH_PRESENTER_VTABLE,
        )
      )
    }
  }

  // hash: optional bytes
  pub fn hash(&self) -> &'_ [u8] {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash(self.raw_msg()).as_ref() };
    view
  }
  pub fn set_hash(&mut self, val: impl ::__pb::SettableValue<[u8]>) {
    self.hash_mut().set(val);
  }
  const __HASH_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_hash,
    );
  fn hash_mut(&mut self) -> ::__pb::Mut<'_, [u8]> {
    unsafe {
      <::__pb::Mut<[u8]>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__HASH_VTABLE,
        )
      )
    }
  }

  // expiration: optional string
  pub fn expiration(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_expiration(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_expiration(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.expiration_mut().set(val);
  }
  const __EXPIRATION_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_expiration,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_expiration,
    );
  fn expiration_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__EXPIRATION_VTABLE,
        )
      )
    }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  const __MEMO_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_memo,
      __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_memo,
    );
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          GetTransactionDetailResponse::__MEMO_VTABLE,
        )
      )
    }
  }

  // log: repeated message wallet_api.v1.GetTransactionDetailResponse.LogEntry
  pub fn log(&self) -> ::__pb::RepeatedView<'_, crate::get_transaction_detail_response::LogEntry> {
    unsafe {
      ::__pb::RepeatedView::from_raw(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_log(self.raw_msg()),
      )
    }
  }
  pub fn log_mut(&mut self) -> ::__pb::RepeatedMut<'_, crate::get_transaction_detail_response::LogEntry> {
    unsafe {
      ::__pb::RepeatedMut::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__runtime::InnerRepeatedMut::new(
          ::__pb::__internal::Private,
          __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_log(self.raw_msg()),
        ),
      )
    }
  }

}  // impl GetTransactionDetailResponse

impl ::__std::ops::Drop for GetTransactionDetailResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_contract_type(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_contract_type(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_clear_commitments(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_commitments(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_commitments(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_created(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_created(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash_presenter(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_hash_presenter(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_hash(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_hash(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_expiration(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_expiration(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_memo(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_set_memo(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_clear_log(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_mut_log(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;
  fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_get_log(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawRepeatedField;


}  // extern "C" for GetTransactionDetailResponse

pub mod get_transaction_detail_response {
  #[allow(non_camel_case_types)]
  pub struct LogEntry {
    inner: ::__pb::__runtime::MessageInner
  }

  impl std::fmt::Debug for LogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  impl std::default::Default for LogEntry {
    fn default() -> Self {
      Self::new()
    }
  }

  // SAFETY:
  // - `LogEntry` is `Sync` because it does not implement interior mutability.
  //    Neither does `LogEntryMut`.
  unsafe impl Sync for LogEntry {}

  // SAFETY:
  // - `LogEntry` is `Send` because it uniquely owns its arena and does
  //   not use thread-local data.
  unsafe impl Send for LogEntry {}

  impl ::__pb::Proxied for LogEntry {
    type View<'msg> = LogEntryView<'msg>;
    type Mut<'msg> = LogEntryMut<'msg>;
  }

  #[derive(Copy, Clone)]
  #[allow(dead_code)]
  pub struct LogEntryView<'msg> {
    msg: ::__pb::__runtime::RawMessage,
    _phantom: ::__std::marker::PhantomData<&'msg ()>,
  }

  impl std::fmt::Debug for LogEntryView<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> LogEntryView<'msg> {
    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { msg, _phantom: ::__std::marker::PhantomData }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_serialize(self.raw_msg()) }
    }

    // sender: optional string
    pub fn sender(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_sender(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // receiver: optional string
    pub fn receiver(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_receiver(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // amount: optional message common.Amount
    pub fn amount(self) -> crate::AmountView<'msg> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount(self.raw_msg()) };
      crate::AmountView::new(::__pb::__internal::Private, submsg)
    }
    pub fn amount_opt(self) ->
    ::__pb::Optional<crate::AmountView<'msg>> {
      let view = self.amount();
      ::__pb::Optional::new(view, self.has_amount())
    }
    pub fn has_amount(self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_has_amount(self.raw_msg()) }
    }

    // timestamp: optional string
    pub fn timestamp(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_timestamp(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // kind: optional string
    pub fn kind(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_kind(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // state: optional string
    pub fn state(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_state(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // event: optional string
    pub fn event(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_event(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

    // promissory_id: optional string
    pub fn promissory_id(self) -> &'msg ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_promissory_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }

  }

  // SAFETY:
  // - `LogEntryView` is `Sync` because it does not support mutation.
  unsafe impl Sync for LogEntryView<'_> {}

  // SAFETY:
  // - `LogEntryView` is `Send` because while its alive a `LogEntryMut` cannot.
  // - `LogEntryView` does not use thread-local data.
  unsafe impl Send for LogEntryView<'_> {}

  impl<'msg> ::__pb::ViewProxy<'msg> for LogEntryView<'msg> {
    type Proxied = LogEntry;

    fn as_view(&self) -> ::__pb::View<'msg, LogEntry> {
      *self
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, LogEntry> where 'msg: 'shorter {
      self
    }
  }

  impl ::__pb::__internal::ProxiedWithRawVTable for LogEntry {
    type VTable = ::__pb::__runtime::MessageVTable;

    fn make_view(_private: ::__pb::__internal::Private,
                mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::View<'_, Self> {
      let msg = unsafe {
        (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
      };
      LogEntryView::new(::__pb::__internal::Private, msg)
    }

    fn make_mut(_private: ::__pb::__internal::Private,
                inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
                -> ::__pb::Mut<'_, Self> {
      let raw_submsg = unsafe {
        (inner.vtable().mut_getter)(inner.msg_ref().msg())
      };
      LogEntryMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
    }
  }

  impl ::__pb::__internal::ProxiedWithRawOptionalVTable for LogEntry {
    type OptionalVTable = ::__pb::__runtime::MessageVTable;

    fn upcast_vtable(_private: ::__pb::__internal::Private,
                     optional_vtable: &'static Self::OptionalVTable)
                    -> &'static Self::VTable {
      &optional_vtable
    }
  }

  impl ::__pb::ProxiedWithPresence for LogEntry {
    type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, LogEntry>;
    type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, LogEntry>;

    fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
       -> Self::AbsentMutData<'_> {
       // SAFETY: The raw ptr msg_ref is valid
      unsafe {
        (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         present_mutator.msg_ref(),
         present_mutator.optional_vtable())
      }
    }

    fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
       -> Self::PresentMutData<'_> {
     unsafe {
       ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
         absent_mutator.msg_ref(),
         absent_mutator.optional_vtable())
     }
    }
  }

  impl<'msg> ::__pb::SettableValue<LogEntry> for LogEntryView<'msg> {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, LogEntry>)
      where LogEntry: 'dst {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_copy_from(mutator.inner.msg(), self.msg) };
    }
  }

  impl ::__pb::SettableValue<LogEntry> for LogEntry {
    fn set_on<'dst>(
      self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, LogEntry>)
      where LogEntry: 'dst {
      self.as_view().set_on(::__pb::__internal::Private, mutator);
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for LogEntry {
    fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_len(f.as_raw(::__pb::__internal::Private)) }
    }

    unsafe fn repeated_set_unchecked(
      mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
      i: usize,
      v: ::__pb::View<Self>,
    ) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `i < len(f)` is promised by caller.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_copy_from(
          __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
          v.raw_msg(),
        );
      }
    }

    unsafe fn repeated_get_unchecked(
      f: ::__pb::View<::__pb::Repeated<Self>>,
      i: usize,
    ) -> ::__pb::View<Self> {
      // SAFETY:
      // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
      // - `i < len(f)` is promised by caller.
      let msg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
      ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
    }
    fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
    }

    fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
      // SAFETY:
      // - `f.as_raw()` is a valid `RepeatedPtrField*`.
      // - `v.raw_msg()` is a valid `const Message&`.
      unsafe {
        let new_elem = __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_add(f.as_raw(::__pb::__internal::Private));
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_copy_from(new_elem, v.raw_msg());
      }
    }

    fn repeated_copy_from(
      src: ::__pb::View<::__pb::Repeated<Self>>,
      mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      // SAFETY:
      // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
      // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
      unsafe {
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
      }
    }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i32> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u32> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u32_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<i64> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_i64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<u64> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_u64_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<bool> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
          let key = key;
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_bool_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ffi_key,
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }
  extern "C" {
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMap;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(m: ::__pb::__runtime::RawMap);
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(m: ::__pb::__runtime::RawMap) -> usize;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
      fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for LogEntry {
      fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
          unsafe {
              ::__pb::Map::from_inner(
                  ::__pb::__internal::Private,
                  ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_new())
              )
          }
      }

      unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_free(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear(map.as_raw(::__pb::__internal::Private)); }
      }

      fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_size(map.as_raw(::__pb::__internal::Private)) }
      }

      fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
      }

      fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
          let key = key.as_bytes().into();
          let mut value = ::__std::mem::MaybeUninit::uninit();
          let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
          if !found {
              return None;
          }
          Some(LogEntryView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
      }

      fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
          let mut value = ::__std::mem::MaybeUninit::uninit();
          unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
      }

      fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
          // SAFETY:
          // - The backing map for `map.as_raw` is valid for at least '_.
          // - A View that is live for '_ guarantees the backing map is unmodified for '_.
          // - The `iter` function produces an iterator that is valid for the key
          //   and value types, and live for at least '_.
          unsafe {
              ::__pb::MapIter::from_raw(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter(map.as_raw(::__pb::__internal::Private))
              )
          }
      }

      fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
          // SAFETY:
          // - The `MapIter` API forbids the backing map from being mutated for 'a,
          //   and guarantees that it's the correct key and value types.
          // - The thunk is safe to call as long as the iterator isn't at the end.
          // - The thunk always writes to key and value fields and does not read.
          // - The thunk does not increment the iterator.
          unsafe {
              iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                  ::__pb::__internal::Private,
                  __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_GetTransactionDetailResponse_LogEntry_iter_get,
                  |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                  |raw_msg| LogEntryView::new(::__pb::__internal::Private, raw_msg)
              )
          }
      }
  }

  #[allow(dead_code)]
  #[allow(non_camel_case_types)]
  pub struct LogEntryMut<'msg> {
    inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
  }

  impl std::fmt::Debug for LogEntryMut<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
      ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
    }
  }

  #[allow(dead_code)]
  impl<'msg> LogEntryMut<'msg> {
    #[doc(hidden)]
    pub fn from_parent(
               _private: ::__pb::__internal::Private,
               parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
               msg: ::__pb::__runtime::RawMessage)
      -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
                 ::__pb::__internal::Private, parent, msg)
      }
    }

    #[doc(hidden)]
    pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
      Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
    }

    #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
    pub fn or_default(self) -> Self { self }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg()
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
      self.inner
    }

    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      ::__pb::ViewProxy::as_view(self).serialize()
    }


    // sender: optional string
    pub fn sender(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_sender(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_sender(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.sender_mut().set(val);
    }
    fn sender_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__SENDER_VTABLE,
          )
        )
      }
    }

    // receiver: optional string
    pub fn receiver(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_receiver(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_receiver(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.receiver_mut().set(val);
    }
    fn receiver_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__RECEIVER_VTABLE,
          )
        )
      }
    }

    // amount: optional message common.Amount
    pub fn amount(&self) -> crate::AmountView<'_> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount(self.raw_msg()) };
      crate::AmountView::new(::__pb::__internal::Private, submsg)
    }
    pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
      self.amount_entry().or_default()
    }
    fn amount_entry(&mut self)
        -> ::__pb::FieldEntry<'_, crate::Amount> {
      static VTABLE: ::__pb::__runtime::MessageVTable =
        ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_mut_amount,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear_amount);
      unsafe {
        let has = self.has_amount();
        ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          &VTABLE,
          has)
      }
    }
    pub fn amount_opt(&self) ->
    ::__pb::Optional<crate::AmountView<'_>> {
      let view = self.amount();
      ::__pb::Optional::new(view, self.has_amount())
    }
    pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
      self.amount_entry().set(val);
    }
    pub fn has_amount(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_has_amount(self.raw_msg()) }
    }
    pub fn clear_amount(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear_amount(self.raw_msg()) }
    }

    // timestamp: optional string
    pub fn timestamp(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_timestamp(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_timestamp(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.timestamp_mut().set(val);
    }
    fn timestamp_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__TIMESTAMP_VTABLE,
          )
        )
      }
    }

    // kind: optional string
    pub fn kind(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_kind(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_kind(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.kind_mut().set(val);
    }
    fn kind_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__KIND_VTABLE,
          )
        )
      }
    }

    // state: optional string
    pub fn state(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_state(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_state(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.state_mut().set(val);
    }
    fn state_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__STATE_VTABLE,
          )
        )
      }
    }

    // event: optional string
    pub fn event(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_event(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_event(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.event_mut().set(val);
    }
    fn event_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__EVENT_VTABLE,
          )
        )
      }
    }

    // promissory_id: optional string
    pub fn promissory_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_promissory_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_promissory_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.promissory_id_mut().set(val);
    }
    fn promissory_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__PROMISSORY_ID_VTABLE,
          )
        )
      }
    }

  }

  // SAFETY:
  // - `LogEntryMut` does not perform any shared mutation.
  // - `LogEntryMut` is not `Send`, and so even in the presence of mutator
  //   splitting, synchronous access of an arena is impossible.
  unsafe impl Sync for LogEntryMut<'_> {}

  impl<'msg> ::__pb::MutProxy<'msg> for LogEntryMut<'msg> {
    fn as_mut(&mut self) -> ::__pb::Mut<'_, LogEntry> {
      LogEntryMut { inner: self.inner }
    }
    fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, LogEntry> where 'msg : 'shorter { self }
  }

  impl<'msg> ::__pb::ViewProxy<'msg> for LogEntryMut<'msg> {
    type Proxied = LogEntry;
    fn as_view(&self) -> ::__pb::View<'_, LogEntry> {
      LogEntryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, LogEntry> where 'msg: 'shorter {
      LogEntryView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
    }
  }

  #[allow(dead_code)]
  impl LogEntry {
    pub fn new() -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() } } }
    }

    fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
      self.inner.msg
    }

    fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
      ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
    }


    pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
      self.as_view().serialize()
    }
    #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
    pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      self.clear_and_parse(data)
    }
    pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
      let success = unsafe {
        // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
        let data = ::__pb::__runtime::SerializedData::from_raw_parts(
          ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
          data.len(),
        );

        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_parse(self.raw_msg(), data)
      };
      success.then_some(()).ok_or(::__pb::ParseError)
    }
    pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
      let mut msg = Self::new();
      msg.clear_and_parse(data).map(|_| msg)
    }

    pub fn as_view(&self) -> LogEntryView {
      LogEntryView::new(::__pb::__internal::Private, self.inner.msg)
    }

    pub fn as_mut(&mut self) -> LogEntryMut {
      LogEntryMut::new(::__pb::__internal::Private, &mut self.inner)
    }

    // sender: optional string
    pub fn sender(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_sender(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_sender(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.sender_mut().set(val);
    }
    const __SENDER_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_sender,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_sender,
      );
    fn sender_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__SENDER_VTABLE,
          )
        )
      }
    }

    // receiver: optional string
    pub fn receiver(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_receiver(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_receiver(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.receiver_mut().set(val);
    }
    const __RECEIVER_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_receiver,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_receiver,
      );
    fn receiver_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__RECEIVER_VTABLE,
          )
        )
      }
    }

    // amount: optional message common.Amount
    pub fn amount(&self) -> crate::AmountView<'_> {
                    let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount(self.raw_msg()) };
      crate::AmountView::new(::__pb::__internal::Private, submsg)
    }
    pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
      self.amount_entry().or_default()
    }
    fn amount_entry(&mut self)
        -> ::__pb::FieldEntry<'_, crate::Amount> {
      static VTABLE: ::__pb::__runtime::MessageVTable =
        ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_mut_amount,
                                  __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear_amount);
      unsafe {
        let has = self.has_amount();
        ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          &VTABLE,
          has)
      }
    }
    pub fn amount_opt(&self) ->
    ::__pb::Optional<crate::AmountView<'_>> {
      let view = self.amount();
      ::__pb::Optional::new(view, self.has_amount())
    }
    pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
      self.amount_entry().set(val);
    }
    pub fn has_amount(&self) -> bool {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_has_amount(self.raw_msg()) }
    }
    pub fn clear_amount(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear_amount(self.raw_msg()) }
    }

    // timestamp: optional string
    pub fn timestamp(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_timestamp(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_timestamp(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.timestamp_mut().set(val);
    }
    const __TIMESTAMP_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_timestamp,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_timestamp,
      );
    fn timestamp_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__TIMESTAMP_VTABLE,
          )
        )
      }
    }

    // kind: optional string
    pub fn kind(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_kind(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_kind(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.kind_mut().set(val);
    }
    const __KIND_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_kind,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_kind,
      );
    fn kind_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__KIND_VTABLE,
          )
        )
      }
    }

    // state: optional string
    pub fn state(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_state(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_state(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.state_mut().set(val);
    }
    const __STATE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_state,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_state,
      );
    fn state_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__STATE_VTABLE,
          )
        )
      }
    }

    // event: optional string
    pub fn event(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_event(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_event(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.event_mut().set(val);
    }
    const __EVENT_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_event,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_event,
      );
    fn event_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__EVENT_VTABLE,
          )
        )
      }
    }

    // promissory_id: optional string
    pub fn promissory_id(&self) -> &'_ ::__pb::ProtoStr {
      let view = unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_promissory_id(self.raw_msg()).as_ref() };
      // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
      unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
    }
    pub fn set_promissory_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
      self.promissory_id_mut().set(val);
    }
    const __PROMISSORY_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
      &::__pb::__internal::BytesMutVTable::new(
        ::__pb::__internal::Private,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_promissory_id,
        __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_promissory_id,
      );
    fn promissory_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
      unsafe {
        <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
          ::__pb::__internal::Private,
          ::__pb::__internal::RawVTableMutator::new(
            ::__pb::__internal::Private,
            self.as_mutator_message_ref(),
            LogEntry::__PROMISSORY_ID_VTABLE,
          )
        )
      }
    }

  }  // impl LogEntry

  impl ::__std::ops::Drop for LogEntry {
    fn drop(&mut self) {
      unsafe { __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_delete(self.raw_msg()); }
    }
  }

  extern "C" {
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_new() -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_delete(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_sender(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_sender(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_receiver(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_receiver(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
       -> ::__pb::__runtime::RawMessage;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_timestamp(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_timestamp(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_kind(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_kind(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_state(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_state(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_event(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_event(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_get_promissory_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
    fn __rust_proto_thunk__wallet_api_v1_GetTransactionDetailResponse_LogEntry_set_promissory_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


  }  // extern "C" for LogEntry


  impl LogEntry {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
      Self { inner: ::__pb::__runtime::MessageInner { msg } }
    }
    pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      let s = std::mem::ManuallyDrop::new(self);
      s.raw_msg()
    }
  }

  impl<'a> LogEntryMut<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
        msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
      Self {
        inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
      }
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.raw_msg()
    }
  }

  impl<'a> LogEntryView<'a> {
    pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a ::__pb::__runtime::RawMessage) -> Self {
      Self::new(::__pb::__internal::Private, *msg)
    }
    pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
      self.msg
    }
  }

}  // mod get_transaction_detail_response

impl GetTransactionDetailResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> GetTransactionDetailResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> GetTransactionDetailResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareAtomicAssetSwapRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareAtomicAssetSwapRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareAtomicAssetSwapRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareAtomicAssetSwapRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareAtomicAssetSwapRequestMut`.
unsafe impl Sync for PrepareAtomicAssetSwapRequest {}

// SAFETY:
// - `PrepareAtomicAssetSwapRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareAtomicAssetSwapRequest {}

impl ::__pb::Proxied for PrepareAtomicAssetSwapRequest {
  type View<'msg> = PrepareAtomicAssetSwapRequestView<'msg>;
  type Mut<'msg> = PrepareAtomicAssetSwapRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareAtomicAssetSwapRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareAtomicAssetSwapRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareAtomicAssetSwapRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_serialize(self.raw_msg()) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // amount: optional message common.Amount
  pub fn amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn has_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn has_respondent_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // timeout: optional uint32
  pub fn timeout(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_timeout(self.raw_msg()) }
  }

}

// SAFETY:
// - `PrepareAtomicAssetSwapRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareAtomicAssetSwapRequestView<'_> {}

// SAFETY:
// - `PrepareAtomicAssetSwapRequestView` is `Send` because while its alive a `PrepareAtomicAssetSwapRequestMut` cannot.
// - `PrepareAtomicAssetSwapRequestView` does not use thread-local data.
unsafe impl Send for PrepareAtomicAssetSwapRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareAtomicAssetSwapRequestView<'msg> {
  type Proxied = PrepareAtomicAssetSwapRequest;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareAtomicAssetSwapRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareAtomicAssetSwapRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareAtomicAssetSwapRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareAtomicAssetSwapRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareAtomicAssetSwapRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareAtomicAssetSwapRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareAtomicAssetSwapRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareAtomicAssetSwapRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareAtomicAssetSwapRequest> for PrepareAtomicAssetSwapRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareAtomicAssetSwapRequest>)
    where PrepareAtomicAssetSwapRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareAtomicAssetSwapRequest> for PrepareAtomicAssetSwapRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareAtomicAssetSwapRequest>)
    where PrepareAtomicAssetSwapRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareAtomicAssetSwapRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareAtomicAssetSwapRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareAtomicAssetSwapRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareAtomicAssetSwapRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareAtomicAssetSwapRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_respondent(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.respondent_mut().set(val);
  }
  fn respondent_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__RESPONDENT_VTABLE,
        )
      )
    }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.respondent_amount_entry().or_default()
  }
  fn respondent_amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_respondent_amount);
    unsafe {
      let has = self.has_respondent_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn respondent_amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn set_respondent_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.respondent_amount_entry().set(val);
  }
  pub fn has_respondent_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_respondent_amount(self.raw_msg()) }
  }
  pub fn clear_respondent_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__MEMO_VTABLE,
        )
      )
    }
  }

  // timeout: optional uint32
  pub fn timeout(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_timeout(self.raw_msg()) }
  }
  pub fn set_timeout(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_timeout(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `PrepareAtomicAssetSwapRequestMut` does not perform any shared mutation.
// - `PrepareAtomicAssetSwapRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareAtomicAssetSwapRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareAtomicAssetSwapRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareAtomicAssetSwapRequest> {
    PrepareAtomicAssetSwapRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareAtomicAssetSwapRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareAtomicAssetSwapRequestMut<'msg> {
  type Proxied = PrepareAtomicAssetSwapRequest;
  fn as_view(&self) -> ::__pb::View<'_, PrepareAtomicAssetSwapRequest> {
    PrepareAtomicAssetSwapRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareAtomicAssetSwapRequest> where 'msg: 'shorter {
    PrepareAtomicAssetSwapRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareAtomicAssetSwapRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareAtomicAssetSwapRequestView {
    PrepareAtomicAssetSwapRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareAtomicAssetSwapRequestMut {
    PrepareAtomicAssetSwapRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_respondent(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.respondent_mut().set(val);
  }
  const __RESPONDENT_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_respondent,
    );
  fn respondent_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__RESPONDENT_VTABLE,
        )
      )
    }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.respondent_amount_entry().or_default()
  }
  fn respondent_amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_respondent_amount);
    unsafe {
      let has = self.has_respondent_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn respondent_amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn set_respondent_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.respondent_amount_entry().set(val);
  }
  pub fn has_respondent_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_respondent_amount(self.raw_msg()) }
  }
  pub fn clear_respondent_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  const __MEMO_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_memo,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_memo,
    );
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapRequest::__MEMO_VTABLE,
        )
      )
    }
  }

  // timeout: optional uint32
  pub fn timeout(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_timeout(self.raw_msg()) }
  }
  pub fn set_timeout(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_timeout(self.raw_msg(), val) }
  }

}  // impl PrepareAtomicAssetSwapRequest

impl ::__std::ops::Drop for PrepareAtomicAssetSwapRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_respondent(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_mut_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_clear_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_has_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_memo(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_memo(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_get_timeout(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapRequest_set_timeout(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for PrepareAtomicAssetSwapRequest


impl PrepareAtomicAssetSwapRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareAtomicAssetSwapRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareAtomicAssetSwapRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareAtomicAssetSwapResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareAtomicAssetSwapResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareAtomicAssetSwapResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareAtomicAssetSwapResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareAtomicAssetSwapResponseMut`.
unsafe impl Sync for PrepareAtomicAssetSwapResponse {}

// SAFETY:
// - `PrepareAtomicAssetSwapResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareAtomicAssetSwapResponse {}

impl ::__pb::Proxied for PrepareAtomicAssetSwapResponse {
  type View<'msg> = PrepareAtomicAssetSwapResponseView<'msg>;
  type Mut<'msg> = PrepareAtomicAssetSwapResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareAtomicAssetSwapResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareAtomicAssetSwapResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareAtomicAssetSwapResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_serialize(self.raw_msg()) }
  }

  // status: optional enum wallet_api.v1.PrepareAtomicAssetSwapResponse.Status
  pub fn status(self) -> crate::prepare_atomic_asset_swap_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_status(self.raw_msg()) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareAtomicAssetSwapResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareAtomicAssetSwapResponseView<'_> {}

// SAFETY:
// - `PrepareAtomicAssetSwapResponseView` is `Send` because while its alive a `PrepareAtomicAssetSwapResponseMut` cannot.
// - `PrepareAtomicAssetSwapResponseView` does not use thread-local data.
unsafe impl Send for PrepareAtomicAssetSwapResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareAtomicAssetSwapResponseView<'msg> {
  type Proxied = PrepareAtomicAssetSwapResponse;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareAtomicAssetSwapResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareAtomicAssetSwapResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareAtomicAssetSwapResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareAtomicAssetSwapResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareAtomicAssetSwapResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareAtomicAssetSwapResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareAtomicAssetSwapResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareAtomicAssetSwapResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareAtomicAssetSwapResponse> for PrepareAtomicAssetSwapResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareAtomicAssetSwapResponse>)
    where PrepareAtomicAssetSwapResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareAtomicAssetSwapResponse> for PrepareAtomicAssetSwapResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareAtomicAssetSwapResponse>)
    where PrepareAtomicAssetSwapResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareAtomicAssetSwapResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareAtomicAssetSwapResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareAtomicAssetSwapResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareAtomicAssetSwapResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareAtomicAssetSwapResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // status: optional enum wallet_api.v1.PrepareAtomicAssetSwapResponse.Status
  pub fn status(&self) -> crate::prepare_atomic_asset_swap_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_atomic_asset_swap_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapResponse::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareAtomicAssetSwapResponseMut` does not perform any shared mutation.
// - `PrepareAtomicAssetSwapResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareAtomicAssetSwapResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareAtomicAssetSwapResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareAtomicAssetSwapResponse> {
    PrepareAtomicAssetSwapResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareAtomicAssetSwapResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareAtomicAssetSwapResponseMut<'msg> {
  type Proxied = PrepareAtomicAssetSwapResponse;
  fn as_view(&self) -> ::__pb::View<'_, PrepareAtomicAssetSwapResponse> {
    PrepareAtomicAssetSwapResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareAtomicAssetSwapResponse> where 'msg: 'shorter {
    PrepareAtomicAssetSwapResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareAtomicAssetSwapResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareAtomicAssetSwapResponseView {
    PrepareAtomicAssetSwapResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareAtomicAssetSwapResponseMut {
    PrepareAtomicAssetSwapResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // status: optional enum wallet_api.v1.PrepareAtomicAssetSwapResponse.Status
  pub fn status(&self) -> crate::prepare_atomic_asset_swap_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_atomic_asset_swap_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_uetr,
      __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareAtomicAssetSwapResponse::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl PrepareAtomicAssetSwapResponse

impl ::__std::ops::Drop for PrepareAtomicAssetSwapResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> crate::prepare_atomic_asset_swap_response::Status;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: crate::prepare_atomic_asset_swap_response::Status);

  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareAtomicAssetSwapResponse_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareAtomicAssetSwapResponse

pub mod prepare_atomic_asset_swap_response {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Status(i32);

  #[allow(non_upper_case_globals)]
  impl Status {
    pub const Unspecified: Status = Status(0);
    pub const Success: Status = Status(1);
    pub const Failure: Status = Status(2);
  }

  impl ::__std::convert::From<Status> for i32 {
    fn from(val: Status) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Status {
    fn from(val: i32) -> Status {
      Self(val)
    }
  }

  impl ::__std::default::Default for Status {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Status)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Status {
    type View<'a> = Status;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Status>;
  }

  impl ::__pb::ViewProxy<'_> for Status {
    type Proxied = Status;

    fn as_view(&self) -> Status {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Status> {
      self
    }
  }

  impl ::__pb::SettableValue<Status> for Status {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Status>
    ) where Status: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Status {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Status {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Status) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Status> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Status,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Status {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Status {
    const NAME: &'static str = "Status";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareAtomicAssetSwapResponse_Status_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod prepare_atomic_asset_swap_response

impl PrepareAtomicAssetSwapResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareAtomicAssetSwapResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareAtomicAssetSwapResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareCrossBorderPaymentRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareCrossBorderPaymentRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareCrossBorderPaymentRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareCrossBorderPaymentRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareCrossBorderPaymentRequestMut`.
unsafe impl Sync for PrepareCrossBorderPaymentRequest {}

// SAFETY:
// - `PrepareCrossBorderPaymentRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareCrossBorderPaymentRequest {}

impl ::__pb::Proxied for PrepareCrossBorderPaymentRequest {
  type View<'msg> = PrepareCrossBorderPaymentRequestView<'msg>;
  type Mut<'msg> = PrepareCrossBorderPaymentRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareCrossBorderPaymentRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareCrossBorderPaymentRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareCrossBorderPaymentRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_serialize(self.raw_msg()) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // treasury: optional string
  pub fn treasury(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_treasury(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // amount: optional message common.Amount
  pub fn amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn has_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn has_respondent_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // timeout: optional uint32
  pub fn timeout(self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_timeout(self.raw_msg()) }
  }

}

// SAFETY:
// - `PrepareCrossBorderPaymentRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareCrossBorderPaymentRequestView<'_> {}

// SAFETY:
// - `PrepareCrossBorderPaymentRequestView` is `Send` because while its alive a `PrepareCrossBorderPaymentRequestMut` cannot.
// - `PrepareCrossBorderPaymentRequestView` does not use thread-local data.
unsafe impl Send for PrepareCrossBorderPaymentRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareCrossBorderPaymentRequestView<'msg> {
  type Proxied = PrepareCrossBorderPaymentRequest;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareCrossBorderPaymentRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareCrossBorderPaymentRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareCrossBorderPaymentRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareCrossBorderPaymentRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareCrossBorderPaymentRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareCrossBorderPaymentRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareCrossBorderPaymentRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareCrossBorderPaymentRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareCrossBorderPaymentRequest> for PrepareCrossBorderPaymentRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareCrossBorderPaymentRequest>)
    where PrepareCrossBorderPaymentRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareCrossBorderPaymentRequest> for PrepareCrossBorderPaymentRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareCrossBorderPaymentRequest>)
    where PrepareCrossBorderPaymentRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareCrossBorderPaymentRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareCrossBorderPaymentRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareCrossBorderPaymentRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareCrossBorderPaymentRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareCrossBorderPaymentRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // treasury: optional string
  pub fn treasury(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_treasury(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_treasury(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.treasury_mut().set(val);
  }
  fn treasury_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__TREASURY_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_respondent(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.respondent_mut().set(val);
  }
  fn respondent_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__RESPONDENT_VTABLE,
        )
      )
    }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.respondent_amount_entry().or_default()
  }
  fn respondent_amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_respondent_amount);
    unsafe {
      let has = self.has_respondent_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn respondent_amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn set_respondent_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.respondent_amount_entry().set(val);
  }
  pub fn has_respondent_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_respondent_amount(self.raw_msg()) }
  }
  pub fn clear_respondent_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__MEMO_VTABLE,
        )
      )
    }
  }

  // timeout: optional uint32
  pub fn timeout(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_timeout(self.raw_msg()) }
  }
  pub fn set_timeout(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_timeout(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `PrepareCrossBorderPaymentRequestMut` does not perform any shared mutation.
// - `PrepareCrossBorderPaymentRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareCrossBorderPaymentRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareCrossBorderPaymentRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareCrossBorderPaymentRequest> {
    PrepareCrossBorderPaymentRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareCrossBorderPaymentRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareCrossBorderPaymentRequestMut<'msg> {
  type Proxied = PrepareCrossBorderPaymentRequest;
  fn as_view(&self) -> ::__pb::View<'_, PrepareCrossBorderPaymentRequest> {
    PrepareCrossBorderPaymentRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareCrossBorderPaymentRequest> where 'msg: 'shorter {
    PrepareCrossBorderPaymentRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareCrossBorderPaymentRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareCrossBorderPaymentRequestView {
    PrepareCrossBorderPaymentRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareCrossBorderPaymentRequestMut {
    PrepareCrossBorderPaymentRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // treasury: optional string
  pub fn treasury(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_treasury(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_treasury(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.treasury_mut().set(val);
  }
  const __TREASURY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_treasury,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_treasury,
    );
  fn treasury_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__TREASURY_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_amount(self.raw_msg()) }
  }

  // respondent: optional string
  pub fn respondent(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_respondent(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.respondent_mut().set(val);
  }
  const __RESPONDENT_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_respondent,
    );
  fn respondent_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__RESPONDENT_VTABLE,
        )
      )
    }
  }

  // respondent_amount: optional message common.Amount
  pub fn respondent_amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn respondent_amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.respondent_amount_entry().or_default()
  }
  fn respondent_amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_respondent_amount,
                                __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_respondent_amount);
    unsafe {
      let has = self.has_respondent_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn respondent_amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.respondent_amount();
    ::__pb::Optional::new(view, self.has_respondent_amount())
  }
  pub fn set_respondent_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.respondent_amount_entry().set(val);
  }
  pub fn has_respondent_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_respondent_amount(self.raw_msg()) }
  }
  pub fn clear_respondent_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_respondent_amount(self.raw_msg()) }
  }

  // memo: optional string
  pub fn memo(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_memo(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_memo(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.memo_mut().set(val);
  }
  const __MEMO_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_memo,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_memo,
    );
  fn memo_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentRequest::__MEMO_VTABLE,
        )
      )
    }
  }

  // timeout: optional uint32
  pub fn timeout(&self) -> u32 {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_timeout(self.raw_msg()) }
  }
  pub fn set_timeout(&mut self, val: u32) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_timeout(self.raw_msg(), val) }
  }

}  // impl PrepareCrossBorderPaymentRequest

impl ::__std::ops::Drop for PrepareCrossBorderPaymentRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_treasury(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_treasury(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_respondent(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_mut_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_clear_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_has_respondent_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_memo(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_memo(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_get_timeout(raw_msg: ::__pb::__runtime::RawMessage) -> u32;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentRequest_set_timeout(raw_msg: ::__pb::__runtime::RawMessage, val: u32);


}  // extern "C" for PrepareCrossBorderPaymentRequest


impl PrepareCrossBorderPaymentRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareCrossBorderPaymentRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareCrossBorderPaymentRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PrepareCrossBorderPaymentResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PrepareCrossBorderPaymentResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PrepareCrossBorderPaymentResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PrepareCrossBorderPaymentResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `PrepareCrossBorderPaymentResponseMut`.
unsafe impl Sync for PrepareCrossBorderPaymentResponse {}

// SAFETY:
// - `PrepareCrossBorderPaymentResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PrepareCrossBorderPaymentResponse {}

impl ::__pb::Proxied for PrepareCrossBorderPaymentResponse {
  type View<'msg> = PrepareCrossBorderPaymentResponseView<'msg>;
  type Mut<'msg> = PrepareCrossBorderPaymentResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PrepareCrossBorderPaymentResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PrepareCrossBorderPaymentResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareCrossBorderPaymentResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_serialize(self.raw_msg()) }
  }

  // status: optional enum wallet_api.v1.PrepareCrossBorderPaymentResponse.Status
  pub fn status(self) -> crate::prepare_cross_border_payment_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_status(self.raw_msg()) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PrepareCrossBorderPaymentResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for PrepareCrossBorderPaymentResponseView<'_> {}

// SAFETY:
// - `PrepareCrossBorderPaymentResponseView` is `Send` because while its alive a `PrepareCrossBorderPaymentResponseMut` cannot.
// - `PrepareCrossBorderPaymentResponseView` does not use thread-local data.
unsafe impl Send for PrepareCrossBorderPaymentResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareCrossBorderPaymentResponseView<'msg> {
  type Proxied = PrepareCrossBorderPaymentResponse;

  fn as_view(&self) -> ::__pb::View<'msg, PrepareCrossBorderPaymentResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareCrossBorderPaymentResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PrepareCrossBorderPaymentResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PrepareCrossBorderPaymentResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PrepareCrossBorderPaymentResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PrepareCrossBorderPaymentResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PrepareCrossBorderPaymentResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PrepareCrossBorderPaymentResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PrepareCrossBorderPaymentResponse> for PrepareCrossBorderPaymentResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareCrossBorderPaymentResponse>)
    where PrepareCrossBorderPaymentResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PrepareCrossBorderPaymentResponse> for PrepareCrossBorderPaymentResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PrepareCrossBorderPaymentResponse>)
    where PrepareCrossBorderPaymentResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PrepareCrossBorderPaymentResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PrepareCrossBorderPaymentResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PrepareCrossBorderPaymentResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PrepareCrossBorderPaymentResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PrepareCrossBorderPaymentResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // status: optional enum wallet_api.v1.PrepareCrossBorderPaymentResponse.Status
  pub fn status(&self) -> crate::prepare_cross_border_payment_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_cross_border_payment_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentResponse::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PrepareCrossBorderPaymentResponseMut` does not perform any shared mutation.
// - `PrepareCrossBorderPaymentResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PrepareCrossBorderPaymentResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PrepareCrossBorderPaymentResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PrepareCrossBorderPaymentResponse> {
    PrepareCrossBorderPaymentResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PrepareCrossBorderPaymentResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PrepareCrossBorderPaymentResponseMut<'msg> {
  type Proxied = PrepareCrossBorderPaymentResponse;
  fn as_view(&self) -> ::__pb::View<'_, PrepareCrossBorderPaymentResponse> {
    PrepareCrossBorderPaymentResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PrepareCrossBorderPaymentResponse> where 'msg: 'shorter {
    PrepareCrossBorderPaymentResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PrepareCrossBorderPaymentResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PrepareCrossBorderPaymentResponseView {
    PrepareCrossBorderPaymentResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PrepareCrossBorderPaymentResponseMut {
    PrepareCrossBorderPaymentResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // status: optional enum wallet_api.v1.PrepareCrossBorderPaymentResponse.Status
  pub fn status(&self) -> crate::prepare_cross_border_payment_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_cross_border_payment_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_uetr,
      __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PrepareCrossBorderPaymentResponse::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl PrepareCrossBorderPaymentResponse

impl ::__std::ops::Drop for PrepareCrossBorderPaymentResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> crate::prepare_cross_border_payment_response::Status;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: crate::prepare_cross_border_payment_response::Status);

  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PrepareCrossBorderPaymentResponse_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PrepareCrossBorderPaymentResponse

pub mod prepare_cross_border_payment_response {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Status(i32);

  #[allow(non_upper_case_globals)]
  impl Status {
    pub const Unspecified: Status = Status(0);
    pub const Success: Status = Status(1);
    pub const Failure: Status = Status(2);
  }

  impl ::__std::convert::From<Status> for i32 {
    fn from(val: Status) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Status {
    fn from(val: i32) -> Status {
      Self(val)
    }
  }

  impl ::__std::default::Default for Status {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Status)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Status {
    type View<'a> = Status;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Status>;
  }

  impl ::__pb::ViewProxy<'_> for Status {
    type Proxied = Status;

    fn as_view(&self) -> Status {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Status> {
      self
    }
  }

  impl ::__pb::SettableValue<Status> for Status {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Status>
    ) where Status: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Status {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Status {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Status) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Status> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Status,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Status {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Status {
    const NAME: &'static str = "Status";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PrepareCrossBorderPaymentResponse_Status_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod prepare_cross_border_payment_response

impl PrepareCrossBorderPaymentResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PrepareCrossBorderPaymentResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PrepareCrossBorderPaymentResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PreparePaymentWithImplicitFundsChangeRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PreparePaymentWithImplicitFundsChangeRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `PreparePaymentWithImplicitFundsChangeRequestMut`.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeRequest {}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PreparePaymentWithImplicitFundsChangeRequest {}

impl ::__pb::Proxied for PreparePaymentWithImplicitFundsChangeRequest {
  type View<'msg> = PreparePaymentWithImplicitFundsChangeRequestView<'msg>;
  type Mut<'msg> = PreparePaymentWithImplicitFundsChangeRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PreparePaymentWithImplicitFundsChangeRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PreparePaymentWithImplicitFundsChangeRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_serialize(self.raw_msg()) }
  }

  // recipient: optional string
  pub fn recipient(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_recipient(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // amount: optional message common.Amount
  pub fn amount(self) -> crate::AmountView<'msg> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_opt(self) ->
  ::__pb::Optional<crate::AmountView<'msg>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn has_amount(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_has_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeRequestView<'_> {}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeRequestView` is `Send` because while its alive a `PreparePaymentWithImplicitFundsChangeRequestMut` cannot.
// - `PreparePaymentWithImplicitFundsChangeRequestView` does not use thread-local data.
unsafe impl Send for PreparePaymentWithImplicitFundsChangeRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PreparePaymentWithImplicitFundsChangeRequestView<'msg> {
  type Proxied = PreparePaymentWithImplicitFundsChangeRequest;

  fn as_view(&self) -> ::__pb::View<'msg, PreparePaymentWithImplicitFundsChangeRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PreparePaymentWithImplicitFundsChangeRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PreparePaymentWithImplicitFundsChangeRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PreparePaymentWithImplicitFundsChangeRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PreparePaymentWithImplicitFundsChangeRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PreparePaymentWithImplicitFundsChangeRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PreparePaymentWithImplicitFundsChangeRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PreparePaymentWithImplicitFundsChangeRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PreparePaymentWithImplicitFundsChangeRequest> for PreparePaymentWithImplicitFundsChangeRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PreparePaymentWithImplicitFundsChangeRequest>)
    where PreparePaymentWithImplicitFundsChangeRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PreparePaymentWithImplicitFundsChangeRequest> for PreparePaymentWithImplicitFundsChangeRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PreparePaymentWithImplicitFundsChangeRequest>)
    where PreparePaymentWithImplicitFundsChangeRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PreparePaymentWithImplicitFundsChangeRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PreparePaymentWithImplicitFundsChangeRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PreparePaymentWithImplicitFundsChangeRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PreparePaymentWithImplicitFundsChangeRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // recipient: optional string
  pub fn recipient(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_recipient(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_recipient(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.recipient_mut().set(val);
  }
  fn recipient_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__RECIPIENT_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_user_reference(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.user_reference_mut().set(val);
  }
  fn user_reference_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__USER_REFERENCE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeRequestMut` does not perform any shared mutation.
// - `PreparePaymentWithImplicitFundsChangeRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PreparePaymentWithImplicitFundsChangeRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PreparePaymentWithImplicitFundsChangeRequest> {
    PreparePaymentWithImplicitFundsChangeRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PreparePaymentWithImplicitFundsChangeRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PreparePaymentWithImplicitFundsChangeRequestMut<'msg> {
  type Proxied = PreparePaymentWithImplicitFundsChangeRequest;
  fn as_view(&self) -> ::__pb::View<'_, PreparePaymentWithImplicitFundsChangeRequest> {
    PreparePaymentWithImplicitFundsChangeRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PreparePaymentWithImplicitFundsChangeRequest> where 'msg: 'shorter {
    PreparePaymentWithImplicitFundsChangeRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PreparePaymentWithImplicitFundsChangeRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PreparePaymentWithImplicitFundsChangeRequestView {
    PreparePaymentWithImplicitFundsChangeRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PreparePaymentWithImplicitFundsChangeRequestMut {
    PreparePaymentWithImplicitFundsChangeRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // recipient: optional string
  pub fn recipient(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_recipient(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_recipient(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.recipient_mut().set(val);
  }
  const __RECIPIENT_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_recipient,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_recipient,
    );
  fn recipient_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__RECIPIENT_VTABLE,
        )
      )
    }
  }

  // amount: optional message common.Amount
  pub fn amount(&self) -> crate::AmountView<'_> {
                  let submsg = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount(self.raw_msg()) };
    crate::AmountView::new(::__pb::__internal::Private, submsg)
  }
  pub fn amount_mut(&mut self) -> crate::AmountMut<'_> {
    self.amount_entry().or_default()
  }
  fn amount_entry(&mut self)
      -> ::__pb::FieldEntry<'_, crate::Amount> {
    static VTABLE: ::__pb::__runtime::MessageVTable =
      ::__pb::__runtime::MessageVTable::new(::__pb::__internal::Private,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_mut_amount,
                                __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear_amount);
    unsafe {
      let has = self.has_amount();
      ::__pb::__internal::new_vtable_field_entry(::__pb::__internal::Private,
        self.as_mutator_message_ref(),
        &VTABLE,
        has)
    }
  }
  pub fn amount_opt(&self) ->
  ::__pb::Optional<crate::AmountView<'_>> {
    let view = self.amount();
    ::__pb::Optional::new(view, self.has_amount())
  }
  pub fn set_amount(&mut self, val: impl ::__pb::SettableValue<crate::Amount>) {
    self.amount_entry().set(val);
  }
  pub fn has_amount(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_has_amount(self.raw_msg()) }
  }
  pub fn clear_amount(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear_amount(self.raw_msg()) }
  }

  // user_reference: optional string
  pub fn user_reference(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_user_reference(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_user_reference(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.user_reference_mut().set(val);
  }
  const __USER_REFERENCE_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_user_reference,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_user_reference,
    );
  fn user_reference_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__USER_REFERENCE_VTABLE,
        )
      )
    }
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

}  // impl PreparePaymentWithImplicitFundsChangeRequest

impl ::__std::ops::Drop for PreparePaymentWithImplicitFundsChangeRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_recipient(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_recipient(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_amount(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_mut_amount(raw_msg: ::__pb::__runtime::RawMessage)
     -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_clear_amount(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_has_amount(raw_msg: ::__pb::__runtime::RawMessage) -> bool;

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_user_reference(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_user_reference(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PreparePaymentWithImplicitFundsChangeRequest


impl PreparePaymentWithImplicitFundsChangeRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PreparePaymentWithImplicitFundsChangeRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PreparePaymentWithImplicitFundsChangeRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct PreparePaymentWithImplicitFundsChangeResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for PreparePaymentWithImplicitFundsChangeResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `PreparePaymentWithImplicitFundsChangeResponseMut`.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeResponse {}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for PreparePaymentWithImplicitFundsChangeResponse {}

impl ::__pb::Proxied for PreparePaymentWithImplicitFundsChangeResponse {
  type View<'msg> = PreparePaymentWithImplicitFundsChangeResponseView<'msg>;
  type Mut<'msg> = PreparePaymentWithImplicitFundsChangeResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct PreparePaymentWithImplicitFundsChangeResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PreparePaymentWithImplicitFundsChangeResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_serialize(self.raw_msg()) }
  }

  // status: optional enum wallet_api.v1.PreparePaymentWithImplicitFundsChangeResponse.Status
  pub fn status(self) -> crate::prepare_payment_with_implicit_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_status(self.raw_msg()) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeResponseView<'_> {}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeResponseView` is `Send` because while its alive a `PreparePaymentWithImplicitFundsChangeResponseMut` cannot.
// - `PreparePaymentWithImplicitFundsChangeResponseView` does not use thread-local data.
unsafe impl Send for PreparePaymentWithImplicitFundsChangeResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for PreparePaymentWithImplicitFundsChangeResponseView<'msg> {
  type Proxied = PreparePaymentWithImplicitFundsChangeResponse;

  fn as_view(&self) -> ::__pb::View<'msg, PreparePaymentWithImplicitFundsChangeResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PreparePaymentWithImplicitFundsChangeResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for PreparePaymentWithImplicitFundsChangeResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    PreparePaymentWithImplicitFundsChangeResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for PreparePaymentWithImplicitFundsChangeResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for PreparePaymentWithImplicitFundsChangeResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, PreparePaymentWithImplicitFundsChangeResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, PreparePaymentWithImplicitFundsChangeResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<PreparePaymentWithImplicitFundsChangeResponse> for PreparePaymentWithImplicitFundsChangeResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PreparePaymentWithImplicitFundsChangeResponse>)
    where PreparePaymentWithImplicitFundsChangeResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<PreparePaymentWithImplicitFundsChangeResponse> for PreparePaymentWithImplicitFundsChangeResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, PreparePaymentWithImplicitFundsChangeResponse>)
    where PreparePaymentWithImplicitFundsChangeResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for PreparePaymentWithImplicitFundsChangeResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for PreparePaymentWithImplicitFundsChangeResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct PreparePaymentWithImplicitFundsChangeResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for PreparePaymentWithImplicitFundsChangeResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> PreparePaymentWithImplicitFundsChangeResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // status: optional enum wallet_api.v1.PreparePaymentWithImplicitFundsChangeResponse.Status
  pub fn status(&self) -> crate::prepare_payment_with_implicit_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_payment_with_implicit_funds_change_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeResponse::__UETR_VTABLE,
        )
      )
    }
  }

}

// SAFETY:
// - `PreparePaymentWithImplicitFundsChangeResponseMut` does not perform any shared mutation.
// - `PreparePaymentWithImplicitFundsChangeResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for PreparePaymentWithImplicitFundsChangeResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for PreparePaymentWithImplicitFundsChangeResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, PreparePaymentWithImplicitFundsChangeResponse> {
    PreparePaymentWithImplicitFundsChangeResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, PreparePaymentWithImplicitFundsChangeResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for PreparePaymentWithImplicitFundsChangeResponseMut<'msg> {
  type Proxied = PreparePaymentWithImplicitFundsChangeResponse;
  fn as_view(&self) -> ::__pb::View<'_, PreparePaymentWithImplicitFundsChangeResponse> {
    PreparePaymentWithImplicitFundsChangeResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, PreparePaymentWithImplicitFundsChangeResponse> where 'msg: 'shorter {
    PreparePaymentWithImplicitFundsChangeResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl PreparePaymentWithImplicitFundsChangeResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> PreparePaymentWithImplicitFundsChangeResponseView {
    PreparePaymentWithImplicitFundsChangeResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> PreparePaymentWithImplicitFundsChangeResponseMut {
    PreparePaymentWithImplicitFundsChangeResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // status: optional enum wallet_api.v1.PreparePaymentWithImplicitFundsChangeResponse.Status
  pub fn status(&self) -> crate::prepare_payment_with_implicit_funds_change_response::Status {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_status(self.raw_msg()) }
  }
  pub fn set_status(&mut self, val: crate::prepare_payment_with_implicit_funds_change_response::Status) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_set_status(self.raw_msg(), val) }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_uetr,
      __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          PreparePaymentWithImplicitFundsChangeResponse::__UETR_VTABLE,
        )
      )
    }
  }

}  // impl PreparePaymentWithImplicitFundsChangeResponse

impl ::__std::ops::Drop for PreparePaymentWithImplicitFundsChangeResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_status(raw_msg: ::__pb::__runtime::RawMessage) -> crate::prepare_payment_with_implicit_funds_change_response::Status;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_set_status(raw_msg: ::__pb::__runtime::RawMessage, val: crate::prepare_payment_with_implicit_funds_change_response::Status);

  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);


}  // extern "C" for PreparePaymentWithImplicitFundsChangeResponse

pub mod prepare_payment_with_implicit_funds_change_response {
  #[repr(transparent)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub struct Status(i32);

  #[allow(non_upper_case_globals)]
  impl Status {
    pub const Unspecified: Status = Status(0);
    pub const Success: Status = Status(1);
    pub const Failure: Status = Status(2);
    pub const InsufficientFunds: Status = Status(3);
  }

  impl ::__std::convert::From<Status> for i32 {
    fn from(val: Status) -> i32 {
      val.0
    }
  }

  impl ::__std::convert::From<i32> for Status {
    fn from(val: i32) -> Status {
      Self(val)
    }
  }

  impl ::__std::default::Default for Status {
    fn default() -> Self {
      Self(0)
    }
  }

  impl ::__std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::__std::fmt::Formatter<'_>) -> ::__std::fmt::Result {
      f.debug_tuple(stringify!(Status)).field(&self.0).finish()
    }
  }

  impl ::__pb::Proxied for Status {
    type View<'a> = Status;
    type Mut<'a> = ::__pb::PrimitiveMut<'a, Status>;
  }

  impl ::__pb::ViewProxy<'_> for Status {
    type Proxied = Status;

    fn as_view(&self) -> Status {
      *self
    }

    fn into_view<'shorter>(self) -> ::__pb::View<'shorter, Status> {
      self
    }
  }

  impl ::__pb::SettableValue<Status> for Status {
    fn set_on<'msg>(
        self,
        private: ::__pb::__internal::Private,
        mut mutator: ::__pb::Mut<'msg, Status>
    ) where Status: 'msg {
      mutator.set_primitive(private, self)
    }
  }

  impl ::__pb::ProxiedWithPresence for Status {
    type PresentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;
    type AbsentMutData<'a> = ::__pb::__internal::RawVTableOptionalMutatorData<'a, Status>;

    fn clear_present_field(
      present_mutator: Self::PresentMutData<'_>,
    ) -> Self::AbsentMutData<'_> {
      present_mutator.clear(::__pb::__internal::Private)
    }

    fn set_absent_to_default(
      absent_mutator: Self::AbsentMutData<'_>,
    ) -> Self::PresentMutData<'_> {
      absent_mutator.set_absent_to_default(::__pb::__internal::Private)
    }
  }

  unsafe impl ::__pb::ProxiedInRepeated for Status {
    fn repeated_len(r: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
      ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r).len()
    }

    fn repeated_push(r: ::__pb::Mut<::__pb::Repeated<Self>>, val: Status) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).push(val.into())
    }

    fn repeated_clear(r: ::__pb::Mut<::__pb::Repeated<Self>>) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r).clear()
    }

    unsafe fn repeated_get_unchecked(
        r: ::__pb::View<::__pb::Repeated<Self>>,
        index: usize,
    ) -> ::__pb::View<Status> {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, r)
          .get_unchecked(index)
          .try_into()
          .unwrap_unchecked()
      }
    }

    unsafe fn repeated_set_unchecked(
        r: ::__pb::Mut<::__pb::Repeated<Self>>,
        index: usize,
        val: Status,
    ) {
      // SAFETY: In-bounds as promised by the caller.
      unsafe {
        ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, r)
          .set_unchecked(index, val.into())
      }
    }

    fn repeated_copy_from(
        src: ::__pb::View<::__pb::Repeated<Self>>,
        dest: ::__pb::Mut<::__pb::Repeated<Self>>,
    ) {
      ::__pb::__runtime::cast_enum_repeated_mut(::__pb::__internal::Private, dest)
        .copy_from(::__pb::__runtime::cast_enum_repeated_view(::__pb::__internal::Private, src))
    }
  }

  impl ::__pb::__internal::PrimitiveWithRawVTable for Status {}

  // SAFETY: this is an enum type
  unsafe impl ::__pb::__internal::Enum for Status {
    const NAME: &'static str = "Status";
  }

  extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u32, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u32> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: i64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<i64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: u64, value: Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<u64> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: bool, value: Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<bool> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key, value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ffi_key,
                ::__std::convert::identity,
            )
        }
    }
  }
  extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut Status) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut Status);
  }
  impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for Status {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(unsafe { value.assume_init() })
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_PreparePaymentWithImplicitFundsChangeResponse_Status_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                ::__std::convert::identity,
            )
        }
    }
  }

}  // mod prepare_payment_with_implicit_funds_change_response

impl PreparePaymentWithImplicitFundsChangeResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> PreparePaymentWithImplicitFundsChangeResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> PreparePaymentWithImplicitFundsChangeResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ResumePausedTransactionRequest {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ResumePausedTransactionRequest {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ResumePausedTransactionRequest {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ResumePausedTransactionRequest` is `Sync` because it does not implement interior mutability.
//    Neither does `ResumePausedTransactionRequestMut`.
unsafe impl Sync for ResumePausedTransactionRequest {}

// SAFETY:
// - `ResumePausedTransactionRequest` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ResumePausedTransactionRequest {}

impl ::__pb::Proxied for ResumePausedTransactionRequest {
  type View<'msg> = ResumePausedTransactionRequestView<'msg>;
  type Mut<'msg> = ResumePausedTransactionRequestMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ResumePausedTransactionRequestView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ResumePausedTransactionRequestView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ResumePausedTransactionRequestView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_serialize(self.raw_msg()) }
  }

  // wallet_id: optional string
  pub fn wallet_id(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // api_key: optional string
  pub fn api_key(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // uetr: optional string
  pub fn uetr(self) -> &'msg ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }

  // accept: optional bool
  pub fn accept(self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_accept(self.raw_msg()) }
  }

}

// SAFETY:
// - `ResumePausedTransactionRequestView` is `Sync` because it does not support mutation.
unsafe impl Sync for ResumePausedTransactionRequestView<'_> {}

// SAFETY:
// - `ResumePausedTransactionRequestView` is `Send` because while its alive a `ResumePausedTransactionRequestMut` cannot.
// - `ResumePausedTransactionRequestView` does not use thread-local data.
unsafe impl Send for ResumePausedTransactionRequestView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ResumePausedTransactionRequestView<'msg> {
  type Proxied = ResumePausedTransactionRequest;

  fn as_view(&self) -> ::__pb::View<'msg, ResumePausedTransactionRequest> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ResumePausedTransactionRequest> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ResumePausedTransactionRequest {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ResumePausedTransactionRequestView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ResumePausedTransactionRequestMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ResumePausedTransactionRequest {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ResumePausedTransactionRequest {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ResumePausedTransactionRequest>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ResumePausedTransactionRequest>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ResumePausedTransactionRequest> for ResumePausedTransactionRequestView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ResumePausedTransactionRequest>)
    where ResumePausedTransactionRequest: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ResumePausedTransactionRequest> for ResumePausedTransactionRequest {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ResumePausedTransactionRequest>)
    where ResumePausedTransactionRequest: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ResumePausedTransactionRequest {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_copy_from(
        __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ResumePausedTransactionRequest {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionRequestView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionRequest_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ResumePausedTransactionRequestView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ResumePausedTransactionRequestMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ResumePausedTransactionRequestMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ResumePausedTransactionRequestMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__UETR_VTABLE,
        )
      )
    }
  }

  // accept: optional bool
  pub fn accept(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_accept(self.raw_msg()) }
  }
  pub fn set_accept(&mut self, val: bool) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_accept(self.raw_msg(), val) }
  }

}

// SAFETY:
// - `ResumePausedTransactionRequestMut` does not perform any shared mutation.
// - `ResumePausedTransactionRequestMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ResumePausedTransactionRequestMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ResumePausedTransactionRequestMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ResumePausedTransactionRequest> {
    ResumePausedTransactionRequestMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ResumePausedTransactionRequest> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ResumePausedTransactionRequestMut<'msg> {
  type Proxied = ResumePausedTransactionRequest;
  fn as_view(&self) -> ::__pb::View<'_, ResumePausedTransactionRequest> {
    ResumePausedTransactionRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ResumePausedTransactionRequest> where 'msg: 'shorter {
    ResumePausedTransactionRequestView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ResumePausedTransactionRequest {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ResumePausedTransactionRequestView {
    ResumePausedTransactionRequestView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ResumePausedTransactionRequestMut {
    ResumePausedTransactionRequestMut::new(::__pb::__internal::Private, &mut self.inner)
  }

  // wallet_id: optional string
  pub fn wallet_id(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_wallet_id(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_wallet_id(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.wallet_id_mut().set(val);
  }
  const __WALLET_ID_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_wallet_id,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_wallet_id,
    );
  fn wallet_id_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__WALLET_ID_VTABLE,
        )
      )
    }
  }

  // api_key: optional string
  pub fn api_key(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_api_key(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_api_key(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.api_key_mut().set(val);
  }
  const __API_KEY_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_api_key,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_api_key,
    );
  fn api_key_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__API_KEY_VTABLE,
        )
      )
    }
  }

  // uetr: optional string
  pub fn uetr(&self) -> &'_ ::__pb::ProtoStr {
    let view = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_uetr(self.raw_msg()).as_ref() };
    // SAFETY: The runtime doesn't require ProtoStr to be UTF-8.
    unsafe { ::__pb::ProtoStr::from_utf8_unchecked(view) }
  }
  pub fn set_uetr(&mut self, val: impl ::__pb::SettableValue<::__pb::ProtoStr>) {
    self.uetr_mut().set(val);
  }
  const __UETR_VTABLE: &'static ::__pb::__internal::BytesMutVTable =
    &::__pb::__internal::BytesMutVTable::new(
      ::__pb::__internal::Private,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_uetr,
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_uetr,
    );
  fn uetr_mut(&mut self) -> ::__pb::Mut<'_, ::__pb::ProtoStr> {
    unsafe {
      <::__pb::Mut<::__pb::ProtoStr>>::from_inner(
        ::__pb::__internal::Private,
        ::__pb::__internal::RawVTableMutator::new(
          ::__pb::__internal::Private,
          self.as_mutator_message_ref(),
          ResumePausedTransactionRequest::__UETR_VTABLE,
        )
      )
    }
  }

  // accept: optional bool
  pub fn accept(&self) -> bool {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_accept(self.raw_msg()) }
  }
  pub fn set_accept(&mut self, val: bool) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_accept(self.raw_msg(), val) }
  }

}  // impl ResumePausedTransactionRequest

impl ::__std::ops::Drop for ResumePausedTransactionRequest {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);

  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_wallet_id(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_wallet_id(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_api_key(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_api_key(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_uetr(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::PtrAndLen;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_uetr(raw_msg: ::__pb::__runtime::RawMessage, val: ::__pb::__runtime::PtrAndLen);

  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_get_accept(raw_msg: ::__pb::__runtime::RawMessage) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionRequest_set_accept(raw_msg: ::__pb::__runtime::RawMessage, val: bool);


}  // extern "C" for ResumePausedTransactionRequest


impl ResumePausedTransactionRequest {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ResumePausedTransactionRequestMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ResumePausedTransactionRequestView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

#[allow(non_camel_case_types)]
pub struct ResumePausedTransactionResponse {
  inner: ::__pb::__runtime::MessageInner
}

impl std::fmt::Debug for ResumePausedTransactionResponse {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

impl std::default::Default for ResumePausedTransactionResponse {
  fn default() -> Self {
    Self::new()
  }
}

// SAFETY:
// - `ResumePausedTransactionResponse` is `Sync` because it does not implement interior mutability.
//    Neither does `ResumePausedTransactionResponseMut`.
unsafe impl Sync for ResumePausedTransactionResponse {}

// SAFETY:
// - `ResumePausedTransactionResponse` is `Send` because it uniquely owns its arena and does
//   not use thread-local data.
unsafe impl Send for ResumePausedTransactionResponse {}

impl ::__pb::Proxied for ResumePausedTransactionResponse {
  type View<'msg> = ResumePausedTransactionResponseView<'msg>;
  type Mut<'msg> = ResumePausedTransactionResponseMut<'msg>;
}

#[derive(Copy, Clone)]
#[allow(dead_code)]
pub struct ResumePausedTransactionResponseView<'msg> {
  msg: ::__pb::__runtime::RawMessage,
  _phantom: ::__std::marker::PhantomData<&'msg ()>,
}

impl std::fmt::Debug for ResumePausedTransactionResponseView<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ResumePausedTransactionResponseView<'msg> {
  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { msg, _phantom: ::__std::marker::PhantomData }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_serialize(self.raw_msg()) }
  }

}

// SAFETY:
// - `ResumePausedTransactionResponseView` is `Sync` because it does not support mutation.
unsafe impl Sync for ResumePausedTransactionResponseView<'_> {}

// SAFETY:
// - `ResumePausedTransactionResponseView` is `Send` because while its alive a `ResumePausedTransactionResponseMut` cannot.
// - `ResumePausedTransactionResponseView` does not use thread-local data.
unsafe impl Send for ResumePausedTransactionResponseView<'_> {}

impl<'msg> ::__pb::ViewProxy<'msg> for ResumePausedTransactionResponseView<'msg> {
  type Proxied = ResumePausedTransactionResponse;

  fn as_view(&self) -> ::__pb::View<'msg, ResumePausedTransactionResponse> {
    *self
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ResumePausedTransactionResponse> where 'msg: 'shorter {
    self
  }
}

impl ::__pb::__internal::ProxiedWithRawVTable for ResumePausedTransactionResponse {
  type VTable = ::__pb::__runtime::MessageVTable;

  fn make_view(_private: ::__pb::__internal::Private,
              mut_inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::View<'_, Self> {
    let msg = unsafe {
      (mut_inner.vtable().getter)(mut_inner.msg_ref().msg())
    };
    ResumePausedTransactionResponseView::new(::__pb::__internal::Private, msg)
  }

  fn make_mut(_private: ::__pb::__internal::Private,
              inner: ::__pb::__internal::RawVTableMutator<'_, Self>)
              -> ::__pb::Mut<'_, Self> {
    let raw_submsg = unsafe {
      (inner.vtable().mut_getter)(inner.msg_ref().msg())
    };
    ResumePausedTransactionResponseMut::from_parent(::__pb::__internal::Private, inner.msg_ref(), raw_submsg)
  }
}

impl ::__pb::__internal::ProxiedWithRawOptionalVTable for ResumePausedTransactionResponse {
  type OptionalVTable = ::__pb::__runtime::MessageVTable;

  fn upcast_vtable(_private: ::__pb::__internal::Private,
                   optional_vtable: &'static Self::OptionalVTable)
                  -> &'static Self::VTable {
    &optional_vtable
  }
}

impl ::__pb::ProxiedWithPresence for ResumePausedTransactionResponse {
  type PresentMutData<'a> = ::__pb::__runtime::MessagePresentMutData<'a, ResumePausedTransactionResponse>;
  type AbsentMutData<'a> = ::__pb::__runtime::MessageAbsentMutData<'a, ResumePausedTransactionResponse>;

  fn clear_present_field(present_mutator: Self::PresentMutData<'_>)
     -> Self::AbsentMutData<'_> {
     // SAFETY: The raw ptr msg_ref is valid
    unsafe {
      (present_mutator.optional_vtable().clearer)(present_mutator.msg_ref().msg());

     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       present_mutator.msg_ref(),
       present_mutator.optional_vtable())
    }
  }

  fn set_absent_to_default(absent_mutator: Self::AbsentMutData<'_>)
     -> Self::PresentMutData<'_> {
   unsafe {
     ::__pb::__internal::RawVTableOptionalMutatorData::new(::__pb::__internal::Private,
       absent_mutator.msg_ref(),
       absent_mutator.optional_vtable())
   }
  }
}

impl<'msg> ::__pb::SettableValue<ResumePausedTransactionResponse> for ResumePausedTransactionResponseView<'msg> {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ResumePausedTransactionResponse>)
    where ResumePausedTransactionResponse: 'dst {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_copy_from(mutator.inner.msg(), self.msg) };
  }
}

impl ::__pb::SettableValue<ResumePausedTransactionResponse> for ResumePausedTransactionResponse {
  fn set_on<'dst>(
    self, _private: ::__pb::__internal::Private, mutator: ::__pb::Mut<'dst, ResumePausedTransactionResponse>)
    where ResumePausedTransactionResponse: 'dst {
    self.as_view().set_on(::__pb::__internal::Private, mutator);
  }
}

unsafe impl ::__pb::ProxiedInRepeated for ResumePausedTransactionResponse {
  fn repeated_len(f: ::__pb::View<::__pb::Repeated<Self>>) -> usize {
    // SAFETY: `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_len(f.as_raw(::__pb::__internal::Private)) }
  }

  unsafe fn repeated_set_unchecked(
    mut f: ::__pb::Mut<::__pb::Repeated<Self>>,
    i: usize,
    v: ::__pb::View<Self>,
  ) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `i < len(f)` is promised by caller.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_copy_from(
        __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_get_mut(f.as_raw(::__pb::__internal::Private), i),
        v.raw_msg(),
      );
    }
  }

  unsafe fn repeated_get_unchecked(
    f: ::__pb::View<::__pb::Repeated<Self>>,
    i: usize,
  ) -> ::__pb::View<Self> {
    // SAFETY:
    // - `f.as_raw()` is a valid `const RepeatedPtrField&`.
    // - `i < len(f)` is promised by caller.
    let msg = unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_get(f.as_raw(::__pb::__internal::Private), i) };
    ::__pb::View::<Self>::new(::__pb::__internal::Private, msg)
  }
  fn repeated_clear(mut f: ::__pb::Mut<::__pb::Repeated<Self>>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_clear(f.as_raw(::__pb::__internal::Private)) };
  }

  fn repeated_push(mut f: ::__pb::Mut<::__pb::Repeated<Self>>, v: ::__pb::View<Self>) {
    // SAFETY:
    // - `f.as_raw()` is a valid `RepeatedPtrField*`.
    // - `v.raw_msg()` is a valid `const Message&`.
    unsafe {
      let new_elem = __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_add(f.as_raw(::__pb::__internal::Private));
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_copy_from(new_elem, v.raw_msg());
    }
  }

  fn repeated_copy_from(
    src: ::__pb::View<::__pb::Repeated<Self>>,
    mut dest: ::__pb::Mut<::__pb::Repeated<Self>>,
  ) {
    // SAFETY:
    // - `dest.as_raw()` is a valid `RepeatedPtrField*`.
    // - `src.as_raw()` is a valid `const RepeatedPtrField&`.
    unsafe {
      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_copy_from(dest.as_raw(::__pb::__internal::Private), src.as_raw(::__pb::__internal::Private));
    }
  }
}
extern "C" {
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: i32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: i32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i32> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i32, Self>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>) {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i32, Self>>, key: ::__pb::View<'_, i32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i32, Self>>) -> ::__pb::MapIter<'_, i32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i32, Self>) -> Option<(::__pb::View<'a, i32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i32_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: u32, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: u32, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u32, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u32> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u32, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u32, Self>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>) {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u32, Self>>, key: ::__pb::View<'_, u32>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u32, Self>>) -> ::__pb::MapIter<'_, u32, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u32, Self>) -> Option<(::__pb::View<'a, u32>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u32, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u32_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: i64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: i64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut i64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<i64> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<i64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<i64, Self>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>) {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<i64, Self>>, key: ::__pb::View<'_, i64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<i64, Self>>) -> ::__pb::MapIter<'_, i64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, i64, Self>) -> Option<(::__pb::View<'a, i64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<i64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_i64_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: u64, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: u64, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut u64, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<u64> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<u64, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<u64, Self>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>) {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<u64, Self>>, key: ::__pb::View<'_, u64>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<u64, Self>>) -> ::__pb::MapIter<'_, u64, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, u64, Self>) -> Option<(::__pb::View<'a, u64>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<u64, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_u64_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: bool, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: bool, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut bool, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<bool> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<bool, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<bool, Self>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>) {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key, value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> Option<::__pb::View<'a, Self>> {
        let key = key;
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<bool, Self>>, key: ::__pb::View<'_, bool>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<bool, Self>>) -> ::__pb::MapIter<'_, bool, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, bool, Self>) -> Option<(::__pb::View<'a, bool>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<bool, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_bool_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ffi_key,
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}
extern "C" {
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMap;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_free(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_clear(m: ::__pb::__runtime::RawMap);
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_size(m: ::__pb::__runtime::RawMap) -> usize;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_insert(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_get(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_remove(m: ::__pb::__runtime::RawMap, key: ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage) -> bool;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_iter(m: ::__pb::__runtime::RawMap) -> ::__pb::__runtime::UntypedMapIterator;
    fn __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_iter_get(iter: &mut ::__pb::__runtime::UntypedMapIterator, key: *mut ::__pb::__runtime::PtrAndLen, value: *mut ::__pb::__runtime::RawMessage);
}
impl ::__pb::ProxiedInMapValue<::__pb::ProtoStr> for ResumePausedTransactionResponse {
    fn map_new(_private: ::__pb::__internal::Private) -> ::__pb::Map<::__pb::ProtoStr, Self> {
        unsafe {
            ::__pb::Map::from_inner(
                ::__pb::__internal::Private,
                ::__pb::__runtime::InnerMap::new(::__pb::__internal::Private, __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_new())
            )
        }
    }

    unsafe fn map_free(_private: ::__pb::__internal::Private, map: &mut ::__pb::Map<::__pb::ProtoStr, Self>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_free(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_clear(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_clear(map.as_raw(::__pb::__internal::Private)); }
    }

    fn map_len(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> usize {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_size(map.as_raw(::__pb::__internal::Private)) }
    }

    fn map_insert(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>, value: ::__pb::View<'_, Self>) -> bool {
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_insert(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.raw_msg()) }
    }

    fn map_get<'a>(map: ::__pb::View<'a, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> Option<::__pb::View<'a, Self>> {
        let key = key.as_bytes().into();
        let mut value = ::__std::mem::MaybeUninit::uninit();
        let found = unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_get(map.as_raw(::__pb::__internal::Private), key, value.as_mut_ptr()) };
        if !found {
            return None;
        }
        Some(ResumePausedTransactionResponseView::new(::__pb::__internal::Private, unsafe { value.assume_init() }))
    }

    fn map_remove(mut map: ::__pb::Mut<'_, ::__pb::Map<::__pb::ProtoStr, Self>>, key: ::__pb::View<'_, ::__pb::ProtoStr>) -> bool {
        let mut value = ::__std::mem::MaybeUninit::uninit();
        unsafe { __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_remove(map.as_raw(::__pb::__internal::Private), key.as_bytes().into(), value.as_mut_ptr()) }
    }

    fn map_iter(map: ::__pb::View<'_, ::__pb::Map<::__pb::ProtoStr, Self>>) -> ::__pb::MapIter<'_, ::__pb::ProtoStr, Self> {
        // SAFETY:
        // - The backing map for `map.as_raw` is valid for at least '_.
        // - A View that is live for '_ guarantees the backing map is unmodified for '_.
        // - The `iter` function produces an iterator that is valid for the key
        //   and value types, and live for at least '_.
        unsafe {
            ::__pb::MapIter::from_raw(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_iter(map.as_raw(::__pb::__internal::Private))
            )
        }
    }

    fn map_iter_next<'a>(iter: &mut ::__pb::MapIter<'a, ::__pb::ProtoStr, Self>) -> Option<(::__pb::View<'a, ::__pb::ProtoStr>, ::__pb::View<'a, Self>)> {
        // SAFETY:
        // - The `MapIter` API forbids the backing map from being mutated for 'a,
        //   and guarantees that it's the correct key and value types.
        // - The thunk is safe to call as long as the iterator isn't at the end.
        // - The thunk always writes to key and value fields and does not read.
        // - The thunk does not increment the iterator.
        unsafe {
            iter.as_raw_mut(::__pb::__internal::Private).next_unchecked::<::__pb::ProtoStr, Self, _, _>(
                ::__pb::__internal::Private,
                __rust_proto_thunk__Map_ProtoStr_wallet_api_v1_ResumePausedTransactionResponse_iter_get,
                |ffi_key| ::__pb::ProtoStr::from_utf8_unchecked(ffi_key.as_ref()),
                |raw_msg| ResumePausedTransactionResponseView::new(::__pb::__internal::Private, raw_msg)
            )
        }
    }
}

#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub struct ResumePausedTransactionResponseMut<'msg> {
  inner: ::__pb::__runtime::MutatorMessageRef<'msg>,
}

impl std::fmt::Debug for ResumePausedTransactionResponseMut<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ::__pb::__runtime::debug_string(::__pb::__internal::Private, self.raw_msg(), f)
  }
}

#[allow(dead_code)]
impl<'msg> ResumePausedTransactionResponseMut<'msg> {
  #[doc(hidden)]
  pub fn from_parent(
             _private: ::__pb::__internal::Private,
             parent: ::__pb::__runtime::MutatorMessageRef<'msg>,
             msg: ::__pb::__runtime::RawMessage)
    -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_parent(
               ::__pb::__internal::Private, parent, msg)
    }
  }

  #[doc(hidden)]
  pub fn new(_private: ::__pb::__internal::Private, msg: &'msg mut ::__pb::__runtime::MessageInner) -> Self {
    Self{ inner: ::__pb::__runtime::MutatorMessageRef::new(_private, msg) }
  }

  #[deprecated = "This .or_default() is a no-op, usages can be safely removed"]
  pub fn or_default(self) -> Self { self }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg()
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef<'msg> {
    self.inner
  }

  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    ::__pb::ViewProxy::as_view(self).serialize()
  }


}

// SAFETY:
// - `ResumePausedTransactionResponseMut` does not perform any shared mutation.
// - `ResumePausedTransactionResponseMut` is not `Send`, and so even in the presence of mutator
//   splitting, synchronous access of an arena is impossible.
unsafe impl Sync for ResumePausedTransactionResponseMut<'_> {}

impl<'msg> ::__pb::MutProxy<'msg> for ResumePausedTransactionResponseMut<'msg> {
  fn as_mut(&mut self) -> ::__pb::Mut<'_, ResumePausedTransactionResponse> {
    ResumePausedTransactionResponseMut { inner: self.inner }
  }
  fn into_mut<'shorter>(self) -> ::__pb::Mut<'shorter, ResumePausedTransactionResponse> where 'msg : 'shorter { self }
}

impl<'msg> ::__pb::ViewProxy<'msg> for ResumePausedTransactionResponseMut<'msg> {
  type Proxied = ResumePausedTransactionResponse;
  fn as_view(&self) -> ::__pb::View<'_, ResumePausedTransactionResponse> {
    ResumePausedTransactionResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
  fn into_view<'shorter>(self) -> ::__pb::View<'shorter, ResumePausedTransactionResponse> where 'msg: 'shorter {
    ResumePausedTransactionResponseView { msg: self.raw_msg(), _phantom: ::__std::marker::PhantomData }
  }
}

#[allow(dead_code)]
impl ResumePausedTransactionResponse {
  pub fn new() -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg: unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_new() } } }
  }

  fn raw_msg(&self) -> ::__pb::__runtime::RawMessage {
    self.inner.msg
  }

  fn as_mutator_message_ref(&mut self) -> ::__pb::__runtime::MutatorMessageRef {
    ::__pb::__runtime::MutatorMessageRef::new(::__pb::__internal::Private, &mut self.inner)
  }


  pub fn serialize(&self) -> ::__pb::__runtime::SerializedData {
    self.as_view().serialize()
  }
  #[deprecated = "Prefer Msg::parse(), or use the new name 'clear_and_parse' to parse into a pre-existing message."]
  pub fn deserialize(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    self.clear_and_parse(data)
  }
  pub fn clear_and_parse(&mut self, data: &[u8]) -> Result<(), ::__pb::ParseError> {
    let success = unsafe {
      // SAFETY: `data.as_ptr()` is valid to read for `data.len()`.
      let data = ::__pb::__runtime::SerializedData::from_raw_parts(
        ::__std::ptr::NonNull::new(data.as_ptr() as *mut _).unwrap(),
        data.len(),
      );

      __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_parse(self.raw_msg(), data)
    };
    success.then_some(()).ok_or(::__pb::ParseError)
  }
  pub fn parse(data: &[u8]) -> Result<Self, ::__pb::ParseError> {
    let mut msg = Self::new();
    msg.clear_and_parse(data).map(|_| msg)
  }

  pub fn as_view(&self) -> ResumePausedTransactionResponseView {
    ResumePausedTransactionResponseView::new(::__pb::__internal::Private, self.inner.msg)
  }

  pub fn as_mut(&mut self) -> ResumePausedTransactionResponseMut {
    ResumePausedTransactionResponseMut::new(::__pb::__internal::Private, &mut self.inner)
  }

}  // impl ResumePausedTransactionResponse

impl ::__std::ops::Drop for ResumePausedTransactionResponse {
  fn drop(&mut self) {
    unsafe { __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_delete(self.raw_msg()); }
  }
}

extern "C" {
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_new() -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_delete(raw_msg: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_serialize(raw_msg: ::__pb::__runtime::RawMessage) -> ::__pb::__runtime::SerializedData;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_parse(raw_msg: ::__pb::__runtime::RawMessage, data: ::__pb::__runtime::SerializedData) -> bool;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_copy_from(dst: ::__pb::__runtime::RawMessage, src: ::__pb::__runtime::RawMessage);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_len(raw: ::__pb::__runtime::RawRepeatedField) -> usize;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_add(raw: ::__pb::__runtime::RawRepeatedField) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_get(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_get_mut(raw: ::__pb::__runtime::RawRepeatedField, index: usize) -> ::__pb::__runtime::RawMessage;
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_clear(raw: ::__pb::__runtime::RawRepeatedField);
  fn __rust_proto_thunk__wallet_api_v1_ResumePausedTransactionResponse_repeated_copy_from(dst: ::__pb::__runtime::RawRepeatedField, src: ::__pb::__runtime::RawRepeatedField);


}  // extern "C" for ResumePausedTransactionResponse


impl ResumePausedTransactionResponse {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(msg: ::__pb::__runtime::RawMessage) -> Self {
    Self { inner: ::__pb::__runtime::MessageInner { msg } }
  }
  pub fn __unstable_leak_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    let s = std::mem::ManuallyDrop::new(self);
    s.raw_msg()
  }
}

impl<'a> ResumePausedTransactionResponseMut<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
      msg: &'a mut ::__pb::__runtime::RawMessage) -> Self {
    Self {
      inner: ::__pb::__runtime::MutatorMessageRef::from_raw_msg(::__pb::__internal::Private, msg)
    }
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.raw_msg()
  }
}

impl<'a> ResumePausedTransactionResponseView<'a> {
  pub fn __unstable_wrap_cpp_grant_permission_to_break(
    msg: &'a ::__pb::__runtime::RawMessage) -> Self {
    Self::new(::__pb::__internal::Private, *msg)
  }
  pub fn __unstable_cpp_repr_grant_permission_to_break(self) -> ::__pb::__runtime::RawMessage {
    self.msg
  }
}

