// protoc --go_out=plugins=grpc:. *.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v5.27.1
// source: user_api/v1/user.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	UserApiService_AuthnWithPassword_FullMethodName                     = "/user_api.v1.UserApiService/AuthnWithPassword"
	UserApiService_RefreshAccessToken_FullMethodName                    = "/user_api.v1.UserApiService/RefreshAccessToken"
	UserApiService_AuthnWithProvider_FullMethodName                     = "/user_api.v1.UserApiService/AuthnWithProvider"
	UserApiService_HandleOIDCCallback_FullMethodName                    = "/user_api.v1.UserApiService/HandleOIDCCallback"
	UserApiService_HandleSAMLCallback_FullMethodName                    = "/user_api.v1.UserApiService/HandleSAMLCallback"
	UserApiService_SAMLSPMetadata_FullMethodName                        = "/user_api.v1.UserApiService/SAMLSPMetadata"
	UserApiService_CreateAuthnBrowserWithWalletChallenge_FullMethodName = "/user_api.v1.UserApiService/CreateAuthnBrowserWithWalletChallenge"
	UserApiService_AuthnBrowserWithWallet_FullMethodName                = "/user_api.v1.UserApiService/AuthnBrowserWithWallet"
	UserApiService_CreateAuthnWalletChallenge_FullMethodName            = "/user_api.v1.UserApiService/CreateAuthnWalletChallenge"
	UserApiService_AuthnWallet_FullMethodName                           = "/user_api.v1.UserApiService/AuthnWallet"
	UserApiService_CreateRegisterWalletChallenge_FullMethodName         = "/user_api.v1.UserApiService/CreateRegisterWalletChallenge"
	UserApiService_RegisterWallet_FullMethodName                        = "/user_api.v1.UserApiService/RegisterWallet"
	UserApiService_AssociateWallet_FullMethodName                       = "/user_api.v1.UserApiService/AssociateWallet"
	UserApiService_DissociateWallet_FullMethodName                      = "/user_api.v1.UserApiService/DissociateWallet"
	UserApiService_GetAppSettings_FullMethodName                        = "/user_api.v1.UserApiService/GetAppSettings"
	UserApiService_RegisterUser_FullMethodName                          = "/user_api.v1.UserApiService/RegisterUser"
	UserApiService_ConfirmUser_FullMethodName                           = "/user_api.v1.UserApiService/ConfirmUser"
	UserApiService_FindByEmail_FullMethodName                           = "/user_api.v1.UserApiService/FindByEmail"
	UserApiService_FindByID_FullMethodName                              = "/user_api.v1.UserApiService/FindByID"
	UserApiService_GetMe_FullMethodName                                 = "/user_api.v1.UserApiService/GetMe"
	UserApiService_GetUserByDID_FullMethodName                          = "/user_api.v1.UserApiService/GetUserByDID"
	UserApiService_ListUsers_FullMethodName                             = "/user_api.v1.UserApiService/ListUsers"
)

// UserApiServiceClient is the client API for UserApiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User API Service integrates with existing identity systems (e.g., bank accounts) to bridge traditional account identifiers to DID/public key identifiers used in the Knox ecosytem. Leverages existing KYC/AML data to enable financial transaction compliance.  Supports OIDC, SAML and other traditional AuthN/Z standards.
type UserApiServiceClient interface {
	// Login with username and password for admin and test users.
	AuthnWithPassword(ctx context.Context, in *AuthnWithPasswordRequest, opts ...grpc.CallOption) (*AuthnWithPasswordResponse, error)
	// Login with refresh token and get a new access token.
	RefreshAccessToken(ctx context.Context, in *RefreshAccessTokenRequest, opts ...grpc.CallOption) (*RefreshAccessTokenResponse, error)
	// Start login process against a selected identity provider. Supports OIDC and SAML.
	AuthnWithProvider(ctx context.Context, in *AuthnWithProviderRequest, opts ...grpc.CallOption) (*AuthnWithProviderResponse, error)
	// Complete login process with the information provided by the OIDC identity provider in previous step.
	HandleOIDCCallback(ctx context.Context, in *HandleOIDCCallbackRequest, opts ...grpc.CallOption) (*HandleOIDCCallbackResponse, error)
	// Complete login process with the information provided by the SAML identity provider in previous step.
	HandleSAMLCallback(ctx context.Context, in *HandleSAMLCallbackRequest, opts ...grpc.CallOption) (*HandleSAMLCallbackResponse, error)
	// Retrieve SAML service provider metadata.
	SAMLSPMetadata(ctx context.Context, in *SAMLSPMetadataRequest, opts ...grpc.CallOption) (*SAMLSPMetadataResponse, error)
	// Used for logging into the browser using a device wallet. Called from the browser, bearer token is received from the stream response once authentication is successful via the wallet.
	CreateAuthnBrowserWithWalletChallenge(ctx context.Context, in *CreateAuthnBrowserWithWalletChallengeRequest, opts ...grpc.CallOption) (UserApiService_CreateAuthnBrowserWithWalletChallengeClient, error)
	// Called from the device wallet to authenticate the browser and bearer token is sent to the browser session.
	AuthnBrowserWithWallet(ctx context.Context, in *AuthnBrowserWithWalletRequest, opts ...grpc.CallOption) (*AuthnBrowserWithWalletResponse, error)
	// Start login process on the device wallet.
	CreateAuthnWalletChallenge(ctx context.Context, in *CreateAuthnWalletChallengeRequest, opts ...grpc.CallOption) (*CreateAuthnWalletChallengeResponse, error)
	// Finish login with cryptographic challenge and bearer token is returned to the caller.
	AuthnWallet(ctx context.Context, in *AuthnWalletRequest, opts ...grpc.CallOption) (*AuthnWalletResponse, error)
	// Called by the browser in an authenticated session to start a device wallet registration process. Acknowledgement is received from the stream response once registration is successful via the wallet.
	CreateRegisterWalletChallenge(ctx context.Context, in *CreateRegisterWalletChallengeRequest, opts ...grpc.CallOption) (UserApiService_CreateRegisterWalletChallengeClient, error)
	// Called by the device wallet to register against the given authenticated account.
	RegisterWallet(ctx context.Context, in *RegisterWalletRequest, opts ...grpc.CallOption) (*RegisterWalletResponse, error)
	// Associate Wallet with the authenticated account in the bearer token.
	AssociateWallet(ctx context.Context, in *AssociateWalletRequest, opts ...grpc.CallOption) (*AssociateWalletResponse, error)
	// Dissociate Wallet with the authenticated account in the bearer token.
	DissociateWallet(ctx context.Context, in *DissociateWalletRequest, opts ...grpc.CallOption) (*DissociateWalletResponse, error)
	// Get application specific settings in a given environment.
	GetAppSettings(ctx context.Context, in *GetAppSettingsRequest, opts ...grpc.CallOption) (*GetAppSettingsResponse, error)
	// Admin API to register a user.
	RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error)
	// Admin API to finish the user registration process.
	ConfirmUser(ctx context.Context, in *ConfirmUserRequest, opts ...grpc.CallOption) (*ConfirmUserResponse, error)
	// Admin API to retrieve User object via email.
	FindByEmail(ctx context.Context, in *FindByEmailRequest, opts ...grpc.CallOption) (*FindByEmailResponse, error)
	// Admin API to retrieve User object via user ID.
	FindByID(ctx context.Context, in *FindByIDRequest, opts ...grpc.CallOption) (*FindByIDResponse, error)
	// Get current authenticated User by bearer token.
	GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error)
	// M2M helper API to retrieve User object given a Decentralized Identifier (DID). API Key required for this call.
	GetUserByDID(ctx context.Context, in *GetUserByDIDRequest, opts ...grpc.CallOption) (*GetUserByDIDResponse, error)
	// Get list of users.
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
}

type userApiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserApiServiceClient(cc grpc.ClientConnInterface) UserApiServiceClient {
	return &userApiServiceClient{cc}
}

func (c *userApiServiceClient) AuthnWithPassword(ctx context.Context, in *AuthnWithPasswordRequest, opts ...grpc.CallOption) (*AuthnWithPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthnWithPasswordResponse)
	err := c.cc.Invoke(ctx, UserApiService_AuthnWithPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) RefreshAccessToken(ctx context.Context, in *RefreshAccessTokenRequest, opts ...grpc.CallOption) (*RefreshAccessTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshAccessTokenResponse)
	err := c.cc.Invoke(ctx, UserApiService_RefreshAccessToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) AuthnWithProvider(ctx context.Context, in *AuthnWithProviderRequest, opts ...grpc.CallOption) (*AuthnWithProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthnWithProviderResponse)
	err := c.cc.Invoke(ctx, UserApiService_AuthnWithProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) HandleOIDCCallback(ctx context.Context, in *HandleOIDCCallbackRequest, opts ...grpc.CallOption) (*HandleOIDCCallbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleOIDCCallbackResponse)
	err := c.cc.Invoke(ctx, UserApiService_HandleOIDCCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) HandleSAMLCallback(ctx context.Context, in *HandleSAMLCallbackRequest, opts ...grpc.CallOption) (*HandleSAMLCallbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleSAMLCallbackResponse)
	err := c.cc.Invoke(ctx, UserApiService_HandleSAMLCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) SAMLSPMetadata(ctx context.Context, in *SAMLSPMetadataRequest, opts ...grpc.CallOption) (*SAMLSPMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SAMLSPMetadataResponse)
	err := c.cc.Invoke(ctx, UserApiService_SAMLSPMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) CreateAuthnBrowserWithWalletChallenge(ctx context.Context, in *CreateAuthnBrowserWithWalletChallengeRequest, opts ...grpc.CallOption) (UserApiService_CreateAuthnBrowserWithWalletChallengeClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UserApiService_ServiceDesc.Streams[0], UserApiService_CreateAuthnBrowserWithWalletChallenge_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &userApiServiceCreateAuthnBrowserWithWalletChallengeClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserApiService_CreateAuthnBrowserWithWalletChallengeClient interface {
	Recv() (*CreateAuthnBrowserWithWalletChallengeResponse, error)
	grpc.ClientStream
}

type userApiServiceCreateAuthnBrowserWithWalletChallengeClient struct {
	grpc.ClientStream
}

func (x *userApiServiceCreateAuthnBrowserWithWalletChallengeClient) Recv() (*CreateAuthnBrowserWithWalletChallengeResponse, error) {
	m := new(CreateAuthnBrowserWithWalletChallengeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userApiServiceClient) AuthnBrowserWithWallet(ctx context.Context, in *AuthnBrowserWithWalletRequest, opts ...grpc.CallOption) (*AuthnBrowserWithWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthnBrowserWithWalletResponse)
	err := c.cc.Invoke(ctx, UserApiService_AuthnBrowserWithWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) CreateAuthnWalletChallenge(ctx context.Context, in *CreateAuthnWalletChallengeRequest, opts ...grpc.CallOption) (*CreateAuthnWalletChallengeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAuthnWalletChallengeResponse)
	err := c.cc.Invoke(ctx, UserApiService_CreateAuthnWalletChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) AuthnWallet(ctx context.Context, in *AuthnWalletRequest, opts ...grpc.CallOption) (*AuthnWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthnWalletResponse)
	err := c.cc.Invoke(ctx, UserApiService_AuthnWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) CreateRegisterWalletChallenge(ctx context.Context, in *CreateRegisterWalletChallengeRequest, opts ...grpc.CallOption) (UserApiService_CreateRegisterWalletChallengeClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &UserApiService_ServiceDesc.Streams[1], UserApiService_CreateRegisterWalletChallenge_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &userApiServiceCreateRegisterWalletChallengeClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserApiService_CreateRegisterWalletChallengeClient interface {
	Recv() (*CreateRegisterWalletChallengeResponse, error)
	grpc.ClientStream
}

type userApiServiceCreateRegisterWalletChallengeClient struct {
	grpc.ClientStream
}

func (x *userApiServiceCreateRegisterWalletChallengeClient) Recv() (*CreateRegisterWalletChallengeResponse, error) {
	m := new(CreateRegisterWalletChallengeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userApiServiceClient) RegisterWallet(ctx context.Context, in *RegisterWalletRequest, opts ...grpc.CallOption) (*RegisterWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterWalletResponse)
	err := c.cc.Invoke(ctx, UserApiService_RegisterWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) AssociateWallet(ctx context.Context, in *AssociateWalletRequest, opts ...grpc.CallOption) (*AssociateWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssociateWalletResponse)
	err := c.cc.Invoke(ctx, UserApiService_AssociateWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) DissociateWallet(ctx context.Context, in *DissociateWalletRequest, opts ...grpc.CallOption) (*DissociateWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DissociateWalletResponse)
	err := c.cc.Invoke(ctx, UserApiService_DissociateWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) GetAppSettings(ctx context.Context, in *GetAppSettingsRequest, opts ...grpc.CallOption) (*GetAppSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAppSettingsResponse)
	err := c.cc.Invoke(ctx, UserApiService_GetAppSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterUserResponse)
	err := c.cc.Invoke(ctx, UserApiService_RegisterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) ConfirmUser(ctx context.Context, in *ConfirmUserRequest, opts ...grpc.CallOption) (*ConfirmUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmUserResponse)
	err := c.cc.Invoke(ctx, UserApiService_ConfirmUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) FindByEmail(ctx context.Context, in *FindByEmailRequest, opts ...grpc.CallOption) (*FindByEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindByEmailResponse)
	err := c.cc.Invoke(ctx, UserApiService_FindByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) FindByID(ctx context.Context, in *FindByIDRequest, opts ...grpc.CallOption) (*FindByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindByIDResponse)
	err := c.cc.Invoke(ctx, UserApiService_FindByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMeResponse)
	err := c.cc.Invoke(ctx, UserApiService_GetMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) GetUserByDID(ctx context.Context, in *GetUserByDIDRequest, opts ...grpc.CallOption) (*GetUserByDIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserByDIDResponse)
	err := c.cc.Invoke(ctx, UserApiService_GetUserByDID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userApiServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, UserApiService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserApiServiceServer is the server API for UserApiService service.
// All implementations must embed UnimplementedUserApiServiceServer
// for forward compatibility
//
// User API Service integrates with existing identity systems (e.g., bank accounts) to bridge traditional account identifiers to DID/public key identifiers used in the Knox ecosytem. Leverages existing KYC/AML data to enable financial transaction compliance.  Supports OIDC, SAML and other traditional AuthN/Z standards.
type UserApiServiceServer interface {
	// Login with username and password for admin and test users.
	AuthnWithPassword(context.Context, *AuthnWithPasswordRequest) (*AuthnWithPasswordResponse, error)
	// Login with refresh token and get a new access token.
	RefreshAccessToken(context.Context, *RefreshAccessTokenRequest) (*RefreshAccessTokenResponse, error)
	// Start login process against a selected identity provider. Supports OIDC and SAML.
	AuthnWithProvider(context.Context, *AuthnWithProviderRequest) (*AuthnWithProviderResponse, error)
	// Complete login process with the information provided by the OIDC identity provider in previous step.
	HandleOIDCCallback(context.Context, *HandleOIDCCallbackRequest) (*HandleOIDCCallbackResponse, error)
	// Complete login process with the information provided by the SAML identity provider in previous step.
	HandleSAMLCallback(context.Context, *HandleSAMLCallbackRequest) (*HandleSAMLCallbackResponse, error)
	// Retrieve SAML service provider metadata.
	SAMLSPMetadata(context.Context, *SAMLSPMetadataRequest) (*SAMLSPMetadataResponse, error)
	// Used for logging into the browser using a device wallet. Called from the browser, bearer token is received from the stream response once authentication is successful via the wallet.
	CreateAuthnBrowserWithWalletChallenge(*CreateAuthnBrowserWithWalletChallengeRequest, UserApiService_CreateAuthnBrowserWithWalletChallengeServer) error
	// Called from the device wallet to authenticate the browser and bearer token is sent to the browser session.
	AuthnBrowserWithWallet(context.Context, *AuthnBrowserWithWalletRequest) (*AuthnBrowserWithWalletResponse, error)
	// Start login process on the device wallet.
	CreateAuthnWalletChallenge(context.Context, *CreateAuthnWalletChallengeRequest) (*CreateAuthnWalletChallengeResponse, error)
	// Finish login with cryptographic challenge and bearer token is returned to the caller.
	AuthnWallet(context.Context, *AuthnWalletRequest) (*AuthnWalletResponse, error)
	// Called by the browser in an authenticated session to start a device wallet registration process. Acknowledgement is received from the stream response once registration is successful via the wallet.
	CreateRegisterWalletChallenge(*CreateRegisterWalletChallengeRequest, UserApiService_CreateRegisterWalletChallengeServer) error
	// Called by the device wallet to register against the given authenticated account.
	RegisterWallet(context.Context, *RegisterWalletRequest) (*RegisterWalletResponse, error)
	// Associate Wallet with the authenticated account in the bearer token.
	AssociateWallet(context.Context, *AssociateWalletRequest) (*AssociateWalletResponse, error)
	// Dissociate Wallet with the authenticated account in the bearer token.
	DissociateWallet(context.Context, *DissociateWalletRequest) (*DissociateWalletResponse, error)
	// Get application specific settings in a given environment.
	GetAppSettings(context.Context, *GetAppSettingsRequest) (*GetAppSettingsResponse, error)
	// Admin API to register a user.
	RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error)
	// Admin API to finish the user registration process.
	ConfirmUser(context.Context, *ConfirmUserRequest) (*ConfirmUserResponse, error)
	// Admin API to retrieve User object via email.
	FindByEmail(context.Context, *FindByEmailRequest) (*FindByEmailResponse, error)
	// Admin API to retrieve User object via user ID.
	FindByID(context.Context, *FindByIDRequest) (*FindByIDResponse, error)
	// Get current authenticated User by bearer token.
	GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error)
	// M2M helper API to retrieve User object given a Decentralized Identifier (DID). API Key required for this call.
	GetUserByDID(context.Context, *GetUserByDIDRequest) (*GetUserByDIDResponse, error)
	// Get list of users.
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	mustEmbedUnimplementedUserApiServiceServer()
}

// UnimplementedUserApiServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserApiServiceServer struct {
}

func (UnimplementedUserApiServiceServer) AuthnWithPassword(context.Context, *AuthnWithPasswordRequest) (*AuthnWithPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthnWithPassword not implemented")
}
func (UnimplementedUserApiServiceServer) RefreshAccessToken(context.Context, *RefreshAccessTokenRequest) (*RefreshAccessTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshAccessToken not implemented")
}
func (UnimplementedUserApiServiceServer) AuthnWithProvider(context.Context, *AuthnWithProviderRequest) (*AuthnWithProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthnWithProvider not implemented")
}
func (UnimplementedUserApiServiceServer) HandleOIDCCallback(context.Context, *HandleOIDCCallbackRequest) (*HandleOIDCCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleOIDCCallback not implemented")
}
func (UnimplementedUserApiServiceServer) HandleSAMLCallback(context.Context, *HandleSAMLCallbackRequest) (*HandleSAMLCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleSAMLCallback not implemented")
}
func (UnimplementedUserApiServiceServer) SAMLSPMetadata(context.Context, *SAMLSPMetadataRequest) (*SAMLSPMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SAMLSPMetadata not implemented")
}
func (UnimplementedUserApiServiceServer) CreateAuthnBrowserWithWalletChallenge(*CreateAuthnBrowserWithWalletChallengeRequest, UserApiService_CreateAuthnBrowserWithWalletChallengeServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateAuthnBrowserWithWalletChallenge not implemented")
}
func (UnimplementedUserApiServiceServer) AuthnBrowserWithWallet(context.Context, *AuthnBrowserWithWalletRequest) (*AuthnBrowserWithWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthnBrowserWithWallet not implemented")
}
func (UnimplementedUserApiServiceServer) CreateAuthnWalletChallenge(context.Context, *CreateAuthnWalletChallengeRequest) (*CreateAuthnWalletChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthnWalletChallenge not implemented")
}
func (UnimplementedUserApiServiceServer) AuthnWallet(context.Context, *AuthnWalletRequest) (*AuthnWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthnWallet not implemented")
}
func (UnimplementedUserApiServiceServer) CreateRegisterWalletChallenge(*CreateRegisterWalletChallengeRequest, UserApiService_CreateRegisterWalletChallengeServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateRegisterWalletChallenge not implemented")
}
func (UnimplementedUserApiServiceServer) RegisterWallet(context.Context, *RegisterWalletRequest) (*RegisterWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWallet not implemented")
}
func (UnimplementedUserApiServiceServer) AssociateWallet(context.Context, *AssociateWalletRequest) (*AssociateWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssociateWallet not implemented")
}
func (UnimplementedUserApiServiceServer) DissociateWallet(context.Context, *DissociateWalletRequest) (*DissociateWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DissociateWallet not implemented")
}
func (UnimplementedUserApiServiceServer) GetAppSettings(context.Context, *GetAppSettingsRequest) (*GetAppSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppSettings not implemented")
}
func (UnimplementedUserApiServiceServer) RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedUserApiServiceServer) ConfirmUser(context.Context, *ConfirmUserRequest) (*ConfirmUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmUser not implemented")
}
func (UnimplementedUserApiServiceServer) FindByEmail(context.Context, *FindByEmailRequest) (*FindByEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByEmail not implemented")
}
func (UnimplementedUserApiServiceServer) FindByID(context.Context, *FindByIDRequest) (*FindByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindByID not implemented")
}
func (UnimplementedUserApiServiceServer) GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedUserApiServiceServer) GetUserByDID(context.Context, *GetUserByDIDRequest) (*GetUserByDIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByDID not implemented")
}
func (UnimplementedUserApiServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUserApiServiceServer) mustEmbedUnimplementedUserApiServiceServer() {}

// UnsafeUserApiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserApiServiceServer will
// result in compilation errors.
type UnsafeUserApiServiceServer interface {
	mustEmbedUnimplementedUserApiServiceServer()
}

func RegisterUserApiServiceServer(s grpc.ServiceRegistrar, srv UserApiServiceServer) {
	s.RegisterService(&UserApiService_ServiceDesc, srv)
}

func _UserApiService_AuthnWithPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthnWithPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).AuthnWithPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_AuthnWithPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).AuthnWithPassword(ctx, req.(*AuthnWithPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_RefreshAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).RefreshAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_RefreshAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).RefreshAccessToken(ctx, req.(*RefreshAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_AuthnWithProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthnWithProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).AuthnWithProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_AuthnWithProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).AuthnWithProvider(ctx, req.(*AuthnWithProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_HandleOIDCCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleOIDCCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).HandleOIDCCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_HandleOIDCCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).HandleOIDCCallback(ctx, req.(*HandleOIDCCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_HandleSAMLCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSAMLCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).HandleSAMLCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_HandleSAMLCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).HandleSAMLCallback(ctx, req.(*HandleSAMLCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_SAMLSPMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SAMLSPMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).SAMLSPMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_SAMLSPMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).SAMLSPMetadata(ctx, req.(*SAMLSPMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_CreateAuthnBrowserWithWalletChallenge_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreateAuthnBrowserWithWalletChallengeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserApiServiceServer).CreateAuthnBrowserWithWalletChallenge(m, &userApiServiceCreateAuthnBrowserWithWalletChallengeServer{ServerStream: stream})
}

type UserApiService_CreateAuthnBrowserWithWalletChallengeServer interface {
	Send(*CreateAuthnBrowserWithWalletChallengeResponse) error
	grpc.ServerStream
}

type userApiServiceCreateAuthnBrowserWithWalletChallengeServer struct {
	grpc.ServerStream
}

func (x *userApiServiceCreateAuthnBrowserWithWalletChallengeServer) Send(m *CreateAuthnBrowserWithWalletChallengeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserApiService_AuthnBrowserWithWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthnBrowserWithWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).AuthnBrowserWithWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_AuthnBrowserWithWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).AuthnBrowserWithWallet(ctx, req.(*AuthnBrowserWithWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_CreateAuthnWalletChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAuthnWalletChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).CreateAuthnWalletChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_CreateAuthnWalletChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).CreateAuthnWalletChallenge(ctx, req.(*CreateAuthnWalletChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_AuthnWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthnWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).AuthnWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_AuthnWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).AuthnWallet(ctx, req.(*AuthnWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_CreateRegisterWalletChallenge_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreateRegisterWalletChallengeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserApiServiceServer).CreateRegisterWalletChallenge(m, &userApiServiceCreateRegisterWalletChallengeServer{ServerStream: stream})
}

type UserApiService_CreateRegisterWalletChallengeServer interface {
	Send(*CreateRegisterWalletChallengeResponse) error
	grpc.ServerStream
}

type userApiServiceCreateRegisterWalletChallengeServer struct {
	grpc.ServerStream
}

func (x *userApiServiceCreateRegisterWalletChallengeServer) Send(m *CreateRegisterWalletChallengeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserApiService_RegisterWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).RegisterWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_RegisterWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).RegisterWallet(ctx, req.(*RegisterWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_AssociateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).AssociateWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_AssociateWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).AssociateWallet(ctx, req.(*AssociateWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_DissociateWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DissociateWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).DissociateWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_DissociateWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).DissociateWallet(ctx, req.(*DissociateWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_GetAppSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).GetAppSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_GetAppSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).GetAppSettings(ctx, req.(*GetAppSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_RegisterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).RegisterUser(ctx, req.(*RegisterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_ConfirmUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).ConfirmUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_ConfirmUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).ConfirmUser(ctx, req.(*ConfirmUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_FindByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).FindByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_FindByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).FindByEmail(ctx, req.(*FindByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_FindByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).FindByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_FindByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).FindByID(ctx, req.(*FindByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).GetMe(ctx, req.(*GetMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_GetUserByDID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByDIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).GetUserByDID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_GetUserByDID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).GetUserByDID(ctx, req.(*GetUserByDIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserApiService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserApiServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserApiService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserApiServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserApiService_ServiceDesc is the grpc.ServiceDesc for UserApiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserApiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user_api.v1.UserApiService",
	HandlerType: (*UserApiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthnWithPassword",
			Handler:    _UserApiService_AuthnWithPassword_Handler,
		},
		{
			MethodName: "RefreshAccessToken",
			Handler:    _UserApiService_RefreshAccessToken_Handler,
		},
		{
			MethodName: "AuthnWithProvider",
			Handler:    _UserApiService_AuthnWithProvider_Handler,
		},
		{
			MethodName: "HandleOIDCCallback",
			Handler:    _UserApiService_HandleOIDCCallback_Handler,
		},
		{
			MethodName: "HandleSAMLCallback",
			Handler:    _UserApiService_HandleSAMLCallback_Handler,
		},
		{
			MethodName: "SAMLSPMetadata",
			Handler:    _UserApiService_SAMLSPMetadata_Handler,
		},
		{
			MethodName: "AuthnBrowserWithWallet",
			Handler:    _UserApiService_AuthnBrowserWithWallet_Handler,
		},
		{
			MethodName: "CreateAuthnWalletChallenge",
			Handler:    _UserApiService_CreateAuthnWalletChallenge_Handler,
		},
		{
			MethodName: "AuthnWallet",
			Handler:    _UserApiService_AuthnWallet_Handler,
		},
		{
			MethodName: "RegisterWallet",
			Handler:    _UserApiService_RegisterWallet_Handler,
		},
		{
			MethodName: "AssociateWallet",
			Handler:    _UserApiService_AssociateWallet_Handler,
		},
		{
			MethodName: "DissociateWallet",
			Handler:    _UserApiService_DissociateWallet_Handler,
		},
		{
			MethodName: "GetAppSettings",
			Handler:    _UserApiService_GetAppSettings_Handler,
		},
		{
			MethodName: "RegisterUser",
			Handler:    _UserApiService_RegisterUser_Handler,
		},
		{
			MethodName: "ConfirmUser",
			Handler:    _UserApiService_ConfirmUser_Handler,
		},
		{
			MethodName: "FindByEmail",
			Handler:    _UserApiService_FindByEmail_Handler,
		},
		{
			MethodName: "FindByID",
			Handler:    _UserApiService_FindByID_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _UserApiService_GetMe_Handler,
		},
		{
			MethodName: "GetUserByDID",
			Handler:    _UserApiService_GetUserByDID_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _UserApiService_ListUsers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateAuthnBrowserWithWalletChallenge",
			Handler:       _UserApiService_CreateAuthnBrowserWithWalletChallenge_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateRegisterWalletChallenge",
			Handler:       _UserApiService_CreateRegisterWalletChallenge_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "user_api/v1/user.proto",
}

const (
	ApiKeyManagerService_CreateApiKey_FullMethodName       = "/user_api.v1.ApiKeyManagerService/CreateApiKey"
	ApiKeyManagerService_UpdateApiKeyStatus_FullMethodName = "/user_api.v1.ApiKeyManagerService/UpdateApiKeyStatus"
	ApiKeyManagerService_GetApiKeys_FullMethodName         = "/user_api.v1.ApiKeyManagerService/GetApiKeys"
	ApiKeyManagerService_CheckApiKey_FullMethodName        = "/user_api.v1.ApiKeyManagerService/CheckApiKey"
)

// ApiKeyManagerServiceClient is the client API for ApiKeyManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service for Managing API Keys.
type ApiKeyManagerServiceClient interface {
	// Create API Key.
	CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error)
	// Update API Key Status.
	UpdateApiKeyStatus(ctx context.Context, in *UpdateApiKeyStatusRequest, opts ...grpc.CallOption) (*UpdateApiKeyStatusResponse, error)
	// Get List of API Keys.
	GetApiKeys(ctx context.Context, in *GetApiKeysRequest, opts ...grpc.CallOption) (*GetApiKeysResponse, error)
	// Check API Key Status.
	CheckApiKey(ctx context.Context, in *CheckApiKeyRequest, opts ...grpc.CallOption) (*CheckApiKeyResponse, error)
}

type apiKeyManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewApiKeyManagerServiceClient(cc grpc.ClientConnInterface) ApiKeyManagerServiceClient {
	return &apiKeyManagerServiceClient{cc}
}

func (c *apiKeyManagerServiceClient) CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateApiKeyResponse)
	err := c.cc.Invoke(ctx, ApiKeyManagerService_CreateApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiKeyManagerServiceClient) UpdateApiKeyStatus(ctx context.Context, in *UpdateApiKeyStatusRequest, opts ...grpc.CallOption) (*UpdateApiKeyStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateApiKeyStatusResponse)
	err := c.cc.Invoke(ctx, ApiKeyManagerService_UpdateApiKeyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiKeyManagerServiceClient) GetApiKeys(ctx context.Context, in *GetApiKeysRequest, opts ...grpc.CallOption) (*GetApiKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetApiKeysResponse)
	err := c.cc.Invoke(ctx, ApiKeyManagerService_GetApiKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiKeyManagerServiceClient) CheckApiKey(ctx context.Context, in *CheckApiKeyRequest, opts ...grpc.CallOption) (*CheckApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckApiKeyResponse)
	err := c.cc.Invoke(ctx, ApiKeyManagerService_CheckApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiKeyManagerServiceServer is the server API for ApiKeyManagerService service.
// All implementations must embed UnimplementedApiKeyManagerServiceServer
// for forward compatibility
//
// Service for Managing API Keys.
type ApiKeyManagerServiceServer interface {
	// Create API Key.
	CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error)
	// Update API Key Status.
	UpdateApiKeyStatus(context.Context, *UpdateApiKeyStatusRequest) (*UpdateApiKeyStatusResponse, error)
	// Get List of API Keys.
	GetApiKeys(context.Context, *GetApiKeysRequest) (*GetApiKeysResponse, error)
	// Check API Key Status.
	CheckApiKey(context.Context, *CheckApiKeyRequest) (*CheckApiKeyResponse, error)
	mustEmbedUnimplementedApiKeyManagerServiceServer()
}

// UnimplementedApiKeyManagerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedApiKeyManagerServiceServer struct {
}

func (UnimplementedApiKeyManagerServiceServer) CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApiKey not implemented")
}
func (UnimplementedApiKeyManagerServiceServer) UpdateApiKeyStatus(context.Context, *UpdateApiKeyStatusRequest) (*UpdateApiKeyStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApiKeyStatus not implemented")
}
func (UnimplementedApiKeyManagerServiceServer) GetApiKeys(context.Context, *GetApiKeysRequest) (*GetApiKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApiKeys not implemented")
}
func (UnimplementedApiKeyManagerServiceServer) CheckApiKey(context.Context, *CheckApiKeyRequest) (*CheckApiKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckApiKey not implemented")
}
func (UnimplementedApiKeyManagerServiceServer) mustEmbedUnimplementedApiKeyManagerServiceServer() {}

// UnsafeApiKeyManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiKeyManagerServiceServer will
// result in compilation errors.
type UnsafeApiKeyManagerServiceServer interface {
	mustEmbedUnimplementedApiKeyManagerServiceServer()
}

func RegisterApiKeyManagerServiceServer(s grpc.ServiceRegistrar, srv ApiKeyManagerServiceServer) {
	s.RegisterService(&ApiKeyManagerService_ServiceDesc, srv)
}

func _ApiKeyManagerService_CreateApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiKeyManagerServiceServer).CreateApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiKeyManagerService_CreateApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiKeyManagerServiceServer).CreateApiKey(ctx, req.(*CreateApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiKeyManagerService_UpdateApiKeyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApiKeyStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiKeyManagerServiceServer).UpdateApiKeyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiKeyManagerService_UpdateApiKeyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiKeyManagerServiceServer).UpdateApiKeyStatus(ctx, req.(*UpdateApiKeyStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiKeyManagerService_GetApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApiKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiKeyManagerServiceServer).GetApiKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiKeyManagerService_GetApiKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiKeyManagerServiceServer).GetApiKeys(ctx, req.(*GetApiKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiKeyManagerService_CheckApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiKeyManagerServiceServer).CheckApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiKeyManagerService_CheckApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiKeyManagerServiceServer).CheckApiKey(ctx, req.(*CheckApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiKeyManagerService_ServiceDesc is the grpc.ServiceDesc for ApiKeyManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiKeyManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user_api.v1.ApiKeyManagerService",
	HandlerType: (*ApiKeyManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateApiKey",
			Handler:    _ApiKeyManagerService_CreateApiKey_Handler,
		},
		{
			MethodName: "UpdateApiKeyStatus",
			Handler:    _ApiKeyManagerService_UpdateApiKeyStatus_Handler,
		},
		{
			MethodName: "GetApiKeys",
			Handler:    _ApiKeyManagerService_GetApiKeys_Handler,
		},
		{
			MethodName: "CheckApiKey",
			Handler:    _ApiKeyManagerService_CheckApiKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user_api/v1/user.proto",
}
